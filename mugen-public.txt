-- Load Obsidian Library
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/deividcomsono/Obsidian/refs/heads/main/Library.lua"))()
print("invis hub mugen")
_G.task_delay_original = task.delay

-- Глобальные определения сервисов и модулей
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local MovesetHandler = require(ReplicatedStorage.Knit.Modules.MovesetHandler)
local CharacterDataModule = require(ReplicatedStorage.Knit.Modules.Data.CharacterData)
local CombatController = require(ReplicatedStorage.Knit.Controllers.CombatController)
local GlobalMoveset = require(ReplicatedStorage.Knit.Modules.GlobalMoveset)
local TagModule = require(ReplicatedStorage.Knit.Modules.TagModule)
local RaycastModule = require(ReplicatedStorage.Knit.Modules.Raycast)

_G.AutoBlockAnimFlags = _G.AutoBlockAnimFlags or {}

-- Патч CanAttack (No Stun/No Slow)
MovesetHandler.CanAttack = function(char, ...)
    -- Если включен авто парри и он активен, блокируем атаки
    if autoParryEnabled and autoParryActive and char == LocalPlayer.Character then
        return false
    end
    -- Иначе используем оригинальную логику (всегда true для No Stun)
    return true
end

local originalKnockbackVelocity = nil -- Будет хранить оригинальную функцию для Anti-Knockback
local originalGetData = CharacterDataModule.GetData -- Для No Skill Cooldowns
local originalCanAttack = MovesetHandler.CanAttack -- Для Attack While Stunned
local originalRaycastCast = RaycastModule.Cast

-- Create window
local Window = Library:CreateWindow({
    Title = "Invis Hub",
    Footer = "by kovlost. │ Mugen v1.5",
    Center = true,
    AutoShow = true,
    Font = Enum.Font.Gotham,
    CornerRadius = 8,
    DPIScale = 0.9,
    ToggleKeybind = Enum.KeyCode.RightControl,
})

local MainTab = Window:AddTab("Main", "shield")
local MainLeft = MainTab:AddLeftGroupbox("Main Functions")
local MainRight = MainTab:AddRightGroupbox("Speed Settings")
local BypassMainBox = MainTab:AddLeftGroupbox("Bypass & Utility")

-- No Stun Feature (обновлённая)
local noStunEnabled = false
local noStunConn

noStunToggle = MainLeft:AddToggle("NoStunToggle", {
    Text = "No Stun (anti ragdoll, anti hardstun, anti slow)",
    Default = false,
    Tooltip = "Removes stun (BETA, BETTER TO USE NO SLOW + NO KNOCKBACK)",
    Callback = function(state)
        if isLoadingConfig then return end
        task.spawn(function()
            noStunEnabled = state
            if noStunConn then safeDisconnect(noStunConn) end
            if state then
                local Players = game:GetService("Players")
                local LocalPlayer = Players.LocalPlayer
                local function removeStunAndRestoreSpeed()
                    local char = LocalPlayer.Character
                    if char then
                        local hum = char:FindFirstChildWhichIsA("Humanoid")
                        if hum then
                            hum.PlatformStand = false
                            hum.AutoRotate = true
                            for _, state in ipairs({
                                Enum.HumanoidStateType.FallingDown,
                                Enum.HumanoidStateType.Ragdoll,
                                Enum.HumanoidStateType.Physics,
                                Enum.HumanoidStateType.GettingUp,
                                Enum.HumanoidStateType.Seated,
                            }) do
                                hum:SetStateEnabled(state, false)
                            end
                            hum:ChangeState(Enum.HumanoidStateType.Running)
                            if hum.WalkSpeed < 10 then hum.WalkSpeed = 10 end
                            if hum.JumpPower < 35 then hum.JumpPower = 35 end
                        end
                        if char:GetAttribute("HardStun") and char:GetAttribute("HardStun") > 0 then
                            char:SetAttribute("HardStun", 0)
                        end
                        if char:GetAttribute("Stun") and char:GetAttribute("Stun") > 0 then
                            char:SetAttribute("Stun", 0)
                        end
                        if char:GetAttribute("PunchStun") and char:GetAttribute("PunchStun") > 0 then
                            char:SetAttribute("PunchStun", 0)
                        end
                        if char:GetAttribute("Slow") then
                            char:SetAttribute("Slow", nil)
                        end
                    end
                end
                noStunConn = game:GetService("RunService").RenderStepped:Connect(removeStunAndRestoreSpeed)
                Library:Notify({
                    Title = "No Stun",
                    Content = "No Stun is now ENABLED.",
                    Duration = 2
                })
            else
                Library:Notify({
                    Title = "No Stun",
                    Content = "No Stun is now DISABLED.",
                    Duration = 2
                })
            end
        end)
    end
})

-- === Exploits Tab ===
local ExploitsTab = Window:AddTab("Exploits (BETA)", "bug")
local CombatExploitsBox = ExploitsTab:AddLeftGroupbox("Combat Exploits")
local StyleBox = ExploitsTab:AddLeftGroupbox("Gyutaro Exploits (MAY NOT WORK)") -- Re-add StyleBox if it was removed

-- Anti-Hitbox Feature
local antiHitboxEnabled = false
local antiHitboxConnection = nil -- New connection for continuous attribute setting
antiHitboxToggle = CombatExploitsBox:AddToggle("AntiHitboxToggle", {
    Text = "Anti-Hitbox",
    Default = false,
    Tooltip = "Constantly sets your character's 'Hitbox' attribute to 0.",
    Callback = function(state)
        if isLoadingConfig then return end
        antiHitboxEnabled = state
        if antiHitboxConnection then safeDisconnect(antiHitboxConnection) end
        if state then
            local function setHitboxAttribute()
                local char = LocalPlayer.Character
                if char then
                    char:SetAttribute("Hitbox", 0)
                end
            end
            antiHitboxConnection = RunService.RenderStepped:Connect(setHitboxAttribute)
            Library:Notify({
                Title = "Anti-Hitbox",
                Content = "Anti-Hitbox ENABLED.",
                Duration = 2
            })
        else
            Library:Notify({
                Title = "Anti-Hitbox",
                Content = "Anti-Hitbox DISABLED.",
                Duration = 2
            })
        end
    end
})

-- === Visual Tab ===
local VisualTab = Window:AddTab("Visual", "eye")
local ESPBox = VisualTab:AddLeftGroupbox("ESP Settings")
local UIBox = VisualTab:AddRightGroupbox("UI Settings")
-- === Auto Block Settings Tab ===
local AutoBlockTab = Window:AddTab("Auto Block Settings", "shield")
local AutoBlockSettingsBox = AutoBlockTab:AddLeftGroupbox("Timing Settings")
local AutoBlockAnimsBox = AutoBlockTab:AddRightGroupbox("Dangerous Animations")

-- Тайминги (слайдеры)
_G.AUTO_BLOCK_RELEASE_TIME = _G.AUTO_BLOCK_RELEASE_TIME or 0.26
_G.AUTO_BLOCK_IGNORE_TIME = _G.AUTO_BLOCK_IGNORE_TIME or 0.23

AutoBlockSettingsBox:AddSlider("AutoBlockReleaseTimeSlider", {
    Text = "Release Time (sec)",
    Min = 0.1,
    Max = 1.0,
    Default = _G.AUTO_BLOCK_RELEASE_TIME,
    Rounding = 2,
    Tooltip = "How long to release block after attack",
    Callback = function(val) _G.AUTO_BLOCK_RELEASE_TIME = val end
})
AutoBlockSettingsBox:AddSlider("AutoBlockIgnoreTimeSlider", {
    Text = "Ignore Time (sec)",
    Min = 0.1,
    Max = 1.0,
    Default = _G.AUTO_BLOCK_IGNORE_TIME,
    Rounding = 2,
    Tooltip = "How long to ignore new attacks after block release",
    Callback = function(val) _G.AUTO_BLOCK_IGNORE_TIME = val end
})

strictDangerousAnimBlockToggle = AutoBlockSettingsBox:AddToggle("StrictDangerousAnimBlockToggle", {
    Text = "Strict Dangerous Anim Block",
    Default = false,
    Tooltip = "If enabled, auto-block will always block when dangerous animations (M1-M4/skills) are near you (uses radius). If disabled, auto-block ignores them and works only by your input/release time.",
    Callback = function(state)
        if isLoadingConfig then return end
        strictDangerousAnimBlockEnabled = state
    end
})

-- Список всех опасных анимаций
local allDangerousAnims = {
    "M1-1", "M1-2", "M1-3", "M1-4", "M2",
    "Parry", "Destruct", "Disorder",
    "RampantArc", "SickleThrow",
    -- Новые анимации Gyutaro FreshCleave
    "FreshCleaveStart", "FreshCleaveHit", "FreshCleaveVictim",
    "FlameBarrage", "FlameBarrageFinisher", "RisingSun",
    "FlowingDance", "FlowingDanceNew", "ShiningSun", "WaterSurfaceSlash", "WaterWheel",
    "LoudAct", "MusicalScore", "Performance", "Resounding",
    "EightFoldLand", "EightFoldWindUp", "FallAsleep", "SixFoldBlocked",
    "SixFoldRush", "SixFoldWindUp", "ThunderClapEnd", "ThunderClapStartup",
    -- Tokito (скрин)
    "AwakenCam", "MistBreaker", "Remembrance", "ScatteredMist1", "ScatteredMist2",
    -- Inosuke (скрин)
    "AwakenCam", "BeastRush", "Instinct",
    -- Nezuko (скрин)
    "BloodEruption", "AwakenCam", "BloodLust", "BloodStomp", "BurningKicks", "FieryStrikes"
}

local selectedDangerousAnims = allDangerousAnims
local dangerousAnimsDropdown = AutoBlockAnimsBox:AddDropdown("DangerousAnimsDropdown", {
    Text = "dangerous anims",
    Values = allDangerousAnims,
    Multi = true,
    Default = allDangerousAnims,
    Callback = function(selected)
        _G.AutoBlockAnimFlags = _G.AutoBlockAnimFlags or {}
        if not selected or #selected == 0 then
            selectedDangerousAnims = allDangerousAnims
            dangerousAnimsDropdown:SetValues(allDangerousAnims)
            -- Вызов Callback вручную для синхронизации
            if dangerousAnimsDropdown.Callback then
                dangerousAnimsDropdown.Callback(allDangerousAnims)
            end
            return
        end
        selectedDangerousAnims = selected
        for _, anim in ipairs(allDangerousAnims) do
            _G.AutoBlockAnimFlags[anim] = table.find(selected, anim) ~= nil
        end
    end
})

local dangerousAnims = setmetatable({}, {
    __index = function(_, k)
        return _G.AutoBlockAnimFlags and _G.AutoBlockAnimFlags[k] or false
    end
})

-- ESP Variables
local MaxDistance = 400.5
local NametagsEnabled = false
local HighlightEnabled = false
local ShowDisplayNick = true
local ShowRealNick = false

-- No Smoke Feature
local noSmokeEnabled = false
local noSmokeConnection = nil

-- Function to create a nametag for a player
local function CreateNametag(Player)
    if Player == LocalPlayer then return end

    local function SetupNametag(Character)
        local Head = Character:FindFirstChild("Head")
        if not Head then return end

        local OldNametag = Head:FindFirstChild("Nametag")
        if OldNametag then
            OldNametag:Destroy()
        end

        local BillboardGui = Instance.new("BillboardGui")
        BillboardGui.Name = "Nametag"
        BillboardGui.Adornee = Head
        BillboardGui.Size = UDim2.new(0, 100, 0, 60)
        BillboardGui.StudsOffset = Vector3.new(0, 2, 0)
        BillboardGui.AlwaysOnTop = true

        local NameTextLabel = Instance.new("TextLabel")
        NameTextLabel.Name = "NameTextLabel"
        NameTextLabel.Size = UDim2.new(1, 0, 0.4, 0)
        NameTextLabel.Position = UDim2.new(0, 0, 0, 0)
        if ShowDisplayNick then
            NameTextLabel.Text = Player.DisplayName
        elseif ShowRealNick then
        NameTextLabel.Text = Player.Name
        else
            NameTextLabel.Text = ""
        end
        NameTextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        NameTextLabel.BackgroundTransparency = 1
        NameTextLabel.TextStrokeTransparency = 0.75
        NameTextLabel.Font = Enum.Font.Code
        NameTextLabel.TextScaled = true
        NameTextLabel.Parent = BillboardGui

        local MovesetTextLabel = Instance.new("TextLabel")
        MovesetTextLabel.Name = "MovesetTextLabel"
        MovesetTextLabel.Size = UDim2.new(1, 0, 0.4, 0)
        MovesetTextLabel.Position = UDim2.new(0, 0, 0.4, 0)
        MovesetTextLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
        MovesetTextLabel.BackgroundTransparency = 1
        MovesetTextLabel.TextStrokeTransparency = 0.75
        MovesetTextLabel.Font = Enum.Font.Code
        MovesetTextLabel.TextScaled = true
        MovesetTextLabel.Parent = BillboardGui

        local HealthBarBackground = Instance.new("Frame")
        HealthBarBackground.Name = "HealthBarBackground"
        HealthBarBackground.Size = UDim2.new(1, 0, 0, 10)
        HealthBarBackground.Position = UDim2.new(0, 0, 0.8, 0)
        HealthBarBackground.BackgroundColor3 = (Library and Library.Scheme and Library.Scheme.BackgroundColor) or Color3.fromRGB(50, 50, 50)
        HealthBarBackground.BorderColor3 = Color3.fromRGB(0, 0, 0)
        HealthBarBackground.BorderSizePixel = 1
        HealthBarBackground.Parent = BillboardGui

        local HealthBarFill = Instance.new("Frame")
        HealthBarFill.Name = "HealthBarFill"
        HealthBarFill.Size = UDim2.new(1, 0, 1, 0)
        HealthBarFill.BackgroundColor3 = (Library and Library.Scheme and Library.Scheme.BackgroundColor) or Color3.fromRGB(0, 255, 0)
        HealthBarFill.Parent = HealthBarBackground

        BillboardGui.Parent = Head
    end

    if Player.Character then
        SetupNametag(Player.Character)
    end
    Player.CharacterAdded:Connect(SetupNametag)
end

-- Централизованное обновление ESP (раз в 0.2 сек)
local function UpdateAllNametags()
    for _, Player in ipairs(Players:GetPlayers()) do
        if Player ~= LocalPlayer and Player.Character and Player.Character:FindFirstChild("Head") then
            local BillboardGui = Player.Character.Head:FindFirstChild("Nametag")
            if BillboardGui then
                local NameTextLabel = BillboardGui:FindFirstChild("NameTextLabel")
                local MovesetTextLabel = BillboardGui:FindFirstChild("MovesetTextLabel")
                local HealthBarBackground = BillboardGui:FindFirstChild("HealthBarBackground")
                local HealthBarFill = HealthBarBackground and HealthBarBackground:FindFirstChild("HealthBarFill")
                local hum = Player.Character:FindFirstChildOfClass("Humanoid")
                if NameTextLabel then
                    if ShowDisplayNick then
                        NameTextLabel.Text = Player.DisplayName
                    elseif ShowRealNick then
                        NameTextLabel.Text = Player.Name
                    else
                        NameTextLabel.Text = ""
                    end
                end
                if MovesetTextLabel then
                    local moveset = Player.Character:GetAttribute("Moveset")
                    MovesetTextLabel.Text = "Moveset: " .. (moveset or "N/A")
                end
                if hum and HealthBarFill then
                    local healthRatio = hum.Health / hum.MaxHealth
                    HealthBarFill.Size = UDim2.new(healthRatio, 0, 1, 0)
                    if healthRatio > 0.7 then
                        HealthBarFill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
                    elseif healthRatio > 0.3 then
                        HealthBarFill.BackgroundColor3 = Color3.fromRGB(255, 255, 0)
                    else
                        HealthBarFill.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                    end
                end
                -- Дистанция и видимость
                if NametagsEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") then
                    local Distance = (Player.Character.Head.Position - LocalPlayer.Character.Head.Position).Magnitude
                    BillboardGui.Enabled = (Distance <= MaxDistance)
                else
                    BillboardGui.Enabled = false
                end
            end
        end
    end
end

-- Запускаем централизованный цикл обновления ESP
spawn(function()
    while true do
        UpdateAllNametags()
        task.wait(0.2)
    end
end)

-- Function to apply ESP/Highlight to a player
local function ApplyHighlight(Player)
    if Player == LocalPlayer then return end

    local function SetupHighlight(Character)
        for _, v in pairs(Character:GetChildren()) do
            if v:IsA("Highlight") then
                v:Destroy()
            end
        end

        local Highlighter = Instance.new("Highlight")
        Highlighter.Parent = Character

        local function UpdateFillColor()
            local DefaultColor = Color3.fromRGB(255, 48, 51)
            Highlighter.FillColor = Player.TeamColor and Player.TeamColor.Color or DefaultColor
        end

        UpdateFillColor()
        Player:GetPropertyChangedSignal("TeamColor"):Connect(UpdateFillColor)

        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        if Humanoid then
            Humanoid.Died:Connect(function()
                Highlighter:Destroy()
            end)
        end
    end

    if Player.Character then
        SetupHighlight(Player.Character)
    end
    Player.CharacterAdded:Connect(SetupHighlight)
end

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function(char)
            if NametagsEnabled then
                CreateNametag(player)
                ApplyHighlight(player)
            end
        end)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function(char)
            if NametagsEnabled then
                CreateNametag(player)
                ApplyHighlight(player)
            end
        end)
    end
end)

-- ESP Toggles
espPlayersToggle = ESPBox:AddToggle("ESPPlayersToggle", {
    Text = "ESP Players",
    Default = false,
    Tooltip = "Shows player positions and names",
    Callback = function(state)
        if isLoadingConfig then return end
        NametagsEnabled = state
        HighlightEnabled = state
        
        for _, Player in pairs(Players:GetPlayers()) do
            if Player ~= LocalPlayer then
                if state then
                    CreateNametag(Player)
                    ApplyHighlight(Player)
                else
                    if Player.Character and Player.Character:FindFirstChild("Head") then
                        local Nametag = Player.Character.Head:FindFirstChild("Nametag")
                        if Nametag then
                            Nametag:Destroy()
                        end
                    end
                    if Player.Character then
                        for _, v in pairs(Player.Character:GetChildren()) do
                            if v:IsA("Highlight") then
                                v:Destroy()
                            end
                        end
                    end
                end
            end
        end
    end
})

espDistanceSlider = ESPBox:AddSlider("ESPDistanceSlider", {
    Text = "ESP Distance",
    Default = MaxDistance,
    Min = 100,
    Max = 1000,
    Rounding = 1,
    Tooltip = "Maximum distance for ESP to show",
    Callback = function(val)
        if isLoadingConfig then return end
        MaxDistance = val
    end
})

-- Apply ESP to new players
Players.PlayerAdded:Connect(function(Player)
    if NametagsEnabled then
        CreateNametag(Player)
        ApplyHighlight(Player)
    end
end)

-- Hide UI Elements
local hidePostureBarEnabled = false
hidePostureBarToggle = UIBox:AddToggle("HidePostureBarToggle", {
    Text = "Hide Posture Bar UI",
    Default = false,
    Tooltip = "Hides the posture bar UI.",
    Callback = function(state)
        if isLoadingConfig then return end
        task.spawn(function()
            hidePostureBarEnabled = state
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("Torso") then
                local postureBar = char.Torso:FindFirstChild("PostureBar")
                if postureBar then
                    postureBar.Enabled = not state
                end
            end
            Library:Notify({
                Title = "Hide Posture Bar",
                Content = "Posture Bar UI visibility set to " .. tostring(not state) .. ".",
                Duration = 2
            })
        end)
    end
})

local hideParryBarEnabled = false
hideParryBarToggle = UIBox:AddToggle("HideParryBarToggle", {
    Text = "Hide Parry Bar UI",
    Default = false,
    Tooltip = "Hides the parry bar UI.",
    Callback = function(state)
        if isLoadingConfig then return end
        task.spawn(function()
            hideParryBarEnabled = state
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("Torso") then
                local parryBar = char.Torso:FindFirstChild("ParryBar")
                if parryBar then
                    parryBar.Enabled = not state
                end
            end
            Library:Notify({
                Title = "Hide Parry Bar",
                Content = "Parry Bar UI visibility set to " .. tostring(not state) .. ".",
                Duration = 2
            })
        end)
    end
})

-- === Gyutaro Settings ===
local gyutaroSettings = {
    autoAim = false,
    multiThrow = false,
    autoTarget = false,
    multiThrowCount = 3,
    autoTargetRadius = 60,
}

gyutaroAutoAimToggle = StyleBox:AddToggle("GyutaroAutoAimToggle", {
    Text = "Gyutaro: Auto Aim",
    Default = gyutaroSettings.autoAim,
    Tooltip = "Sickles will fly to the nearest enemy",
    Callback = function(state)
        if isLoadingConfig then return end
        gyutaroSettings.autoAim = state
    end
})
gyutaroMultiThrowToggle = StyleBox:AddToggle("GyutaroMultiThrowToggle", {
    Text = "Gyutaro: Multi Throw",
    Default = gyutaroSettings.multiThrow,
    Tooltip = "Throws several sickles in a row",
    Callback = function(state)
        if isLoadingConfig then return end
        gyutaroSettings.multiThrow = state
    end
})
gyutaroMultiThrowCountSlider = StyleBox:AddSlider("GyutaroMultiThrowCount", {
    Text = "Gyutaro: Sickle Count",
    Default = gyutaroSettings.multiThrowCount,
    Min = 1,
    Max = 5,
    Rounding = 0,
    Tooltip = "How many sickles to throw at once",
    Callback = function(val)
        if isLoadingConfig then return end
        gyutaroSettings.multiThrowCount = val
    end
})
gyutaroAutoTargetToggle = StyleBox:AddToggle("GyutaroAutoTargetToggle", {
    Text = "Gyutaro: Auto Target",
    Default = gyutaroSettings.autoTarget,
    Tooltip = "Automatically selects the nearest enemy and uses the skill",
    Callback = function(state)
        if isLoadingConfig then return end
        gyutaroSettings.autoTarget = state
    end
})
gyutaroAutoTargetRadiusSlider = StyleBox:AddSlider("GyutaroAutoTargetRadius", {
    Text = "Gyutaro: Auto Target Radius",
    Default = gyutaroSettings.autoTargetRadius,
    Min = 10,
    Max = 100,
    Rounding = 0,
    Tooltip = "Radius to search for the nearest enemy for auto target",
    Callback = function(val)
        if isLoadingConfig then return end
        gyutaroSettings.autoTargetRadius = val
    end
})

-- === Gyutaro Auto Target (исправлено) ===
local function patchGyutaroSkills()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    -- Патч FlyingSickleController
    local success, FlyingSickleController = pcall(function()
        return require(ReplicatedStorage.Knit.Controllers.MoveControllers.Gyutaro.FlyingSickleController)
    end)
    
    if success and FlyingSickleController then
        local originalFlyingSickleKnitStart = FlyingSickleController.KnitStart
        FlyingSickleController.KnitStart = function(self, ...)
            originalFlyingSickleKnitStart(self, ...)
            
            local Knit = require(ReplicatedStorage.Knit.Packages.Knit)
            local EmitController = require(ReplicatedStorage.Knit.Modules.EmitController)
            local u5 = Players.LocalPlayer
            local u1 = ReplicatedStorage
            local u13 = u1.Assets.Animations.Moves
            local u14 = {}
            
            local function enhancedFlyingSickleEffect(p15, p16)
                local u17 = p16.Character
                if u17 then
                    local u18 = u17:FindFirstChild("HumanoidRootPart")
                    if u18 then
                        local v19 = u17:FindFirstChild("Humanoid")
                        if v19 then
                            local v20 = Players:GetPlayerFromCharacter(u17)
                            if p15 == "Start" then
                                local v21 = v19.Animator:LoadAnimation(u13.Gyutaro.SickleThrow)
                                v21:Play()
                                v21:AdjustSpeed(10) -- ускоряем анимацию броска
                                u14[u17] = v21
                                local v22 = u1.Assets.Sounds.Moves.Gyutaro.Throw:Clone()
                                v22.Parent = u18
                                v22:Play()
                                game:GetService("Debris"):AddItem(v22, v22.TimeLength)
                                task.delay(0.25, function()
                                    if u14[u17] then
                                        local v23 = script.AngryExplo:Clone()
                                        v23.Parent = workspace.Debris
                                        v23.CFrame = u18.CFrame
                                        EmitController.Weld(u18, v23)
                                        EmitController.Emit(v23, 5)
                                    end
                                end)
                                return
                            elseif p15 == "Shoot" then
                                local target = nil
                                if gyutaroSettings.autoAim then
                                    target = getNearestEnemyModel(u18.Position, gyutaroSettings.autoTargetRadius) or (p16.Target and p16.Target:FindFirstChild("HumanoidRootPart"))
                                else
                                    target = (p16.Target and p16.Target:FindFirstChild("HumanoidRootPart"))
                                end
                                local u25 = 0.1 -- duration полёта sickle (очень быстро)
                                local repeatCount = gyutaroSettings.multiThrow and gyutaroSettings.multiThrowCount or 1
                                local startCFrame = u18.CFrame
                                for i = 1, repeatCount do
                                    task.spawn(function()
                                        local v27 = script.Throw:Clone()
                                        v27.Parent = workspace.Debris
                                        v27:PivotTo(startCFrame)
                                        EmitController.Emit(v27, 5)
                                        local v29 = target and target.Position or (u18.Position + u18.CFrame.LookVector * 20)
                                        local v35 = tick()
                                        local duration = u25 or 0.7
                                        repeat
                                            game:GetService("RunService").Heartbeat:Wait()
                                            local pos = u18.Position:Lerp(v29, math.min((tick() - v35) / duration, 1))
                                            v27.CFrame = CFrame.new(pos, v29)
                                        until (tick() - v35) > duration
                                        -- Попытка нанести урон (если возможно)
                                        if target and target.Parent and target.Parent:FindFirstChild("Humanoid") then
                                            local humanoid = target.Parent:FindFirstChild("Humanoid")
                                            if humanoid and humanoid.Health > 0 then
                                                -- Попытка вызвать урон через RemoteEvent (если есть)
                                                local Remotes = ReplicatedStorage:FindFirstChild("Remotes")
                                                local DamageEvent = Remotes and Remotes:FindFirstChild("Damage")
                                                if DamageEvent then
                                                    DamageEvent:FireServer(target.Parent, 10) -- 10 урона, пример
                                                end
                                            end
                                        end
                                        -- Телепортируем sickle назад и повторяем, если не последний раз
                                        if i < repeatCount then
                                            v27.CFrame = startCFrame
                                            task.wait(0.05)
                                        end
                                        v27:Destroy()
                                    end)
                                    task.wait(0.1)
                                end
                            elseif p15 == "Cancel" and u14[u17] then
                                u14[u17]:Stop()
                                u14[u17] = nil
                            end
                        end
                    end
                end
            end
            
            -- Подключаем патченный обработчик
            EmitController.Effect:Connect(enhancedFlyingSickleEffect)
        end
    end
    
    -- Патч PoisonVeinController
    local success2, PoisonVeinController = pcall(function()
        return require(ReplicatedStorage.Knit.Controllers.MoveControllers.Gyutaro.PoisonVeinController)
    end)
    
    if success2 and PoisonVeinController then
        local originalPoisonVeinKnitStart = PoisonVeinController.KnitStart
        PoisonVeinController.KnitStart = function(self, ...)
            originalPoisonVeinKnitStart(self, ...)
            
            local EmitController = require(ReplicatedStorage.Knit.Modules.EmitController)
            local u1 = ReplicatedStorage
            local u12 = u1.Assets.Animations.Moves
            local u4 = game:GetService("Debris")
            local u3 = game:GetService("TweenService")
            local Players = game:GetService("Players")
            
            local function enhancedPoisonVeinEffect(p13, p14)
                if p14 then
                    local u15 = p14:FindFirstChild("HumanoidRootPart")
                    if u15 then
                        local v16 = p14:FindFirstChild("Humanoid")
                        if v16 then
                            if p13 == "Start" then
                                v16.Animator:LoadAnimation(u12.Gyutaro.PoisonVein):Play()
                                local v17 = u1.Assets.Sounds.Moves.Gyutaro.PoisonVein:Clone()
                                v17.Parent = u15
                                v17:Play()
                                u4:AddItem(v17, v17.TimeLength)
                                local u18 = script.PoisonVein:Clone()
                                u18.Parent = workspace.Debris
                                u18.CFrame = u15.CFrame
                                local u19 = script.Highlight:Clone()
                                u19.Parent = p14
                                u19.OutlineTransparency = 1
                                u19.FillTransparency = 1
                                u3:Create(u19, TweenInfo.new(0.3), {
                                    ["FillTransparency"] = 0,
                                    ["OutlineTransparency"] = 0
                                }):Play()
                                EmitController.Emit(u18.Windup)
                                EmitController.Emit(u18.Smoke.Start)
                                task.delay(0.4, function()
                                    EmitController.Emit(u18["Blood EMit"])
                                    EmitController.Emit(u18["Blood Emit 2"])
                                    EmitController.Enable(u18.Smoke.at, true)
                                    EmitController.Enable(u18.Smoke.Attachment, true)
                                    EmitController.Enable(u18.Roar, true)
                                    u19:Destroy()
                                    if (u15.Position - workspace.CurrentCamera.CFrame.Position).Magnitude <= 100 then
                                        local CameraShakeController = require(ReplicatedStorage.Knit.Controllers.CameraShakeController)
                                        CameraShakeController.CameraShaker:Shake(CameraShakeController.CameraShaker.Presets.Explosion)
                                    end
                                end)
                                task.delay(0.8, function()
                                    EmitController.Enable(u18.Roar, false)
                                    EmitController.Enable(u18.Smoke, false)
                                end)
                                task.delay(30, function() -- buff duration
                                    u18:Destroy()
                                end)
                                if p14 == LocalPlayer.Character then
                                    local hum = p14:FindFirstChild("Humanoid")
                                    if hum then
                                        if not hum:FindFirstChild("PoisonVeinBuff") then
                                            local buff = Instance.new("NumberValue")
                                            buff.Name = "PoisonVeinBuff"
                                            buff.Value = 3.0
                                            buff.Parent = hum
                                        else
                                            hum.PoisonVeinBuff.Value = 3.0
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            
            -- Подключаем патченный обработчик
            local CombatEffects = require(ReplicatedStorage.Knit.Modules.CombatEffects)
            CombatEffects.Effect:Connect(enhancedPoisonVeinEffect)
        end
    end
    
    -- Auto Target для Gyutaro
    if gyutaroSettings.autoTarget then
        local UserInputService = game:GetService("UserInputService")
        UserInputService.InputBegan:Connect(function(input, processed)
            if not processed and input.KeyCode == Enum.KeyCode.One then
                local chars = workspace:FindFirstChild("Characters")
                local myChar = LocalPlayer and LocalPlayer.Character
                if not chars or not myChar or not myChar:FindFirstChild("HumanoidRootPart") then return end
                local target = getNearestEnemyModel(myChar.HumanoidRootPart.Position, gyutaroSettings.autoTargetRadius)
                if target then
                    local lockVal = myChar:FindFirstChild("LockOnTarget")
                    if not lockVal then
                        lockVal = Instance.new("ObjectValue")
                        lockVal.Name = "LockOnTarget"
                        lockVal.Parent = myChar
                    end
                    lockVal.Value = target
                end
            end
        end)
    end
end

-- Akaza Settings Groupbox
local AkazaBox = ExploitsTab:AddRightGroupbox("Akaza Exploits (MAY NOT WORK)")

-- Akaza: Air Control Toggle
local akazaAirControlEnabled = false
local originalAirTypeKnitStart = nil
local airTypePatched = false

akazaAirControlToggle = AkazaBox:AddToggle("AkazaAirControlToggle", {
    Text = "Akaza: Air Control",
    Default = false,
    Tooltip = "Maintain full control while using Akaza's AirType move in the air",
    Callback = function(state)
        if isLoadingConfig then return end
        akazaAirControlEnabled = state
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        
        -- Патчим контроллер только один раз
        if not airTypePatched then
        local success, AirTypeController = pcall(function()
            return require(ReplicatedStorage.Knit.Controllers.MoveControllers.Akaza.AirTypeController)
        end)
            
        if success and AirTypeController then
                -- Сохраняем оригинальную функцию
                originalAirTypeKnitStart = AirTypeController.KnitStart
                
                -- Создаем патченную версию
                AirTypeController.KnitStart = function(self, ...)
                    -- Вызываем оригинальную функцию
                    originalAirTypeKnitStart(self, ...)
                    
                    -- Получаем сервис и патчим его события
                    local Knit = require(ReplicatedStorage.Knit.Packages.Knit)
                    local AirTypeService = Knit.GetService("AirTypeService")
                    
                    if AirTypeService and AirTypeService.Effect then
                        -- Создаем патченный обработчик
                        local function patchedEffectHandler(p15, p16)
                            local v_u_17 = p16.Character
                            if v_u_17 then
                                local v_u_18 = v_u_17:FindFirstChild("HumanoidRootPart")
                                if v_u_18 then
                                    local v19 = v_u_17:FindFirstChild("Humanoid")
                                    if v19 then
                                        local v_u_20 = p16.Target
                                        local v_u_21 = game:GetService("Players"):GetPlayerFromCharacter(v_u_17)
                                        local v_u_5 = game:GetService("Players").LocalPlayer
                                        
                                        if p15 == "Start" then
                                            local v_u_22
                                            if v_u_21 and v_u_21 == v_u_5 then
                                                -- Проверяем, находится ли игрок в воздухе
                                                local isInAir = v19.FloorMaterial == Enum.Material.Air
                                                
                                                if isInAir then
                                                    v_u_22 = v19.Animator:LoadAnimation(ReplicatedStorage.Assets.Animations.Moves.Akaza.AirType.Air)
                                                    v_u_22:Play()
                                                    
                                                    -- ПАТЧ: Если включен Air Control, убираем ограничения
                                                    if akazaAirControlEnabled then
                                                        -- Просто сбрасываем скорость, не создаем BodyGyro/BodyVelocity
                                                        v_u_18.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                                                        
                                                        -- Создаем только минимальный BodyGyro для поворота камеры
                                                        local v_u_24 = Instance.new("BodyGyro")
                                                        v_u_24.Parent = v_u_18
                                                        v_u_24.D = 10
                                                        v_u_24.P = 20000
                                                        v_u_24.MaxTorque = Vector3.new(0, 20000, 0) -- Только Y ось
                                                        
                                                        local v_u_25 = game:GetService("RunService").RenderStepped:Connect(function()
                                                            if v_u_24 and v_u_24.Parent then
                                                                v_u_24.CFrame = CFrame.new(v_u_24.CFrame.Position) * CFrame.Angles(0, workspace.CurrentCamera.CFrame.Y, 0)
                                                            else
                                                                v_u_25:Disconnect()
                                                            end
                                                        end)
                                                        
                                                        -- Удаляем через 0.9 секунды
                                                        task.delay(0.9, function()
                                                            if v_u_24 and v_u_24.Parent then
                                                                v_u_18.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                                                                v_u_25:Disconnect()
                                                                v_u_24:Destroy()
                                                            end
                                                        end)
                                                    else
                                                        -- Оригинальная логика для воздуха
                                                        local v_u_23 = v_u_18.CFrame * CFrame.new(0, 0, -3)
                                                        v_u_18.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                                                        local v_u_24 = Instance.new("BodyGyro")
                                                        v_u_24.Parent = v_u_18
                                                        v_u_24.D = 10
                                                        v_u_24.P = 20000
                                                        v_u_24.MaxTorque = Vector3.new(20000, 20000, 20000)
                                                        local v_u_25 = game:GetService("RunService").RenderStepped:Connect(function()
                                                            v_u_24.CFrame = workspace.CurrentCamera.CFrame
                                                        end)
                                                        local v26 = v_u_18:FindFirstChildWhichIsA("BodyVelocity")
                                                        if v26 then
                                                            v26:Destroy()
                                                        end
                                                        local v_u_27 = Instance.new("BodyVelocity")
                                                        v_u_27.Parent = v_u_18
                                                        v_u_27.MaxForce = Vector3.new(30000, 30000, 30000)
                                                        v_u_27.P = 30000
                                                        v_u_27.Velocity = Vector3.new(0, 0, 0)
                                                        task.delay(0.9, function()
                                                            v_u_18.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                                                            v_u_25:Disconnect()
                                                            v_u_24.CFrame = v_u_23
                                                            v_u_27:Destroy()
                                                            task.wait(0.1)
                                                            v_u_18.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                                                            v_u_24:Destroy()
                                                        end)
                                                    end
                                                else
                                                    v_u_22 = v19.Animator:LoadAnimation(ReplicatedStorage.Assets.Animations.Moves.Akaza.AirType.Ground)
                                                    v_u_22:Play()
                                                end
                                            else
                                                v_u_22 = v19.Animator:LoadAnimation(ReplicatedStorage.Assets.Animations.Moves.Akaza.AirType.Ground)
                                                v_u_22:Play()
                                            end
                                            
                                            -- Остальная логика остается без изменений
                                            local v_u_14 = {}
                                            v_u_14[v_u_17] = true
                                            local v_u_28 = ReplicatedStorage.Assets.VFX.Shockwave.AirType
                                            local function v_u_31()
                                                if v_u_14[v_u_17] == "Cancel" then
                                                    if v_u_22 and v_u_22.IsPlaying then
                                                        v_u_22:Stop()
                                                    end
                                                else
                                                    if v_u_21 == v_u_5 then
                                                        local CameraShakeController = Knit.GetController("CameraShakeController")
                                                        if CameraShakeController then
                                                            CameraShakeController.CameraShaker:Shake(CameraShakeController.CameraShaker.Presets.BigBump)
                                end
                            end
                                                    local v29 = v_u_28.VFX.shoot:Clone()
                                                    v29.Parent = v_u_18
                                                    require(ReplicatedStorage.Knit.Modules.EmitController).Emit(v29, 4)
                                                    local v30 = ReplicatedStorage.Assets.Sounds.Moves.Akaza.AirTypeThrow:Clone()
                                                    v30.Parent = v_u_18
                                                    v30.PlaybackSpeed = math.random(9, 12) / 10
                                                    v30:Play()
                                                    game:GetService("Debris"):AddItem(v30, v30.TimeLength)
                                                    if v_u_5 == v_u_21 then
                                                        AirTypeService.Shoot:Fire(v_u_20)
                                                    end
                                                end
                                            end
                                            task.delay(0.25, v_u_31)
                                            task.delay(0.56, v_u_31)
                                            task.delay(0.85, v_u_31)
                                            task.delay(1.1, function()
                                                v_u_14[v_u_17] = nil
                                            end)
                                        elseif p15 == "Hit" then
                                            if v_u_20 then
                                                local v32 = v_u_20:FindFirstChild("HumanoidRootPart")
                                                if v32 then
                                                    local v33 = ReplicatedStorage.Assets.VFX.Shockwave.AirType.VFX.hit:Clone()
                                                    v33.Parent = v32
                                                    require(ReplicatedStorage.Knit.Modules.EmitController).Emit(v33, 4)
                                                    local v34 = ReplicatedStorage.Assets.Sounds.Moves.Akaza.AirTypeHit:Clone()
                                                    v34.Parent = v_u_20.PrimaryPart
                                                    v34.PlaybackSpeed = math.random(9, 12) / 10
                                                    v34:Play()
                                                    game:GetService("Debris"):AddItem(v34, v34.TimeLength)
                                                end
                                            end
                                        elseif p15 == "StartParry" then
                                            v19.Animator:LoadAnimation(ReplicatedStorage.Assets.Animations.Moves.Akaza.AirType.Parry):Play()
                                            local v35 = v_u_18:FindFirstChildWhichIsA("BodyVelocity")
                                            if v35 then
                                                v35:Destroy()
                                            end
                                            local v_u_36 = ReplicatedStorage.Assets.VFX.Shockwave.AirType
                                            local function v_u_39()
                                                if v_u_21 == v_u_5 then
                                                    local CameraShakeController = Knit.GetController("CameraShakeController")
                                                    if CameraShakeController then
                                                        CameraShakeController.CameraShaker:Shake(CameraShakeController.CameraShaker.Presets.BigBump)
                                                    end
                                                end
                                                local v37 = v_u_36.VFX.shoot:Clone()
                                                v37.Parent = v_u_18
                                                require(ReplicatedStorage.Knit.Modules.EmitController).Emit(v37, 4)
                                                local v38 = ReplicatedStorage.Assets.Sounds.Moves.Akaza.AirTypeThrow:Clone()
                                                v38.Parent = v_u_18
                                                v38.PlaybackSpeed = math.random(9, 12) / 10
                                                v38:Play()
                                                game:GetService("Debris"):AddItem(v38, v38.TimeLength)
                                                AirTypeService.Shoot:Fire(v_u_20)
                                            end
                                            local v_u_40 = Instance.new("BodyVelocity")
                                            v_u_40.Parent = v_u_18
                                            v_u_40.MaxForce = Vector3.new(30000, 30000, 30000)
                                            v_u_40.P = 30000
                                            v_u_40.Velocity = -v_u_18.CFrame.LookVector + Vector3.new(0, 1, 0)
                                            task.delay(0.2, v_u_39)
                                            task.delay(0.6, v_u_39)
                                            task.spawn(function()
                                                local v41 = tick()
                                                local v42 = tick() + 0.5
                                                while tick() <= v42 and v_u_40 do
                                                    local v43 = -((tick() - v41) / (v42 - v41) - 1)
                                                    v_u_40.Velocity = (-v_u_18.CFrame.LookVector + Vector3.new(0, 1, 0)) * (v43 * 90)
                                                    task.wait(0.02)
                                                end
                                                task.wait(0.4)
                                                if v_u_40 then
                                                    v_u_40:Destroy()
                                                end
                                            end)
                                        elseif p15 == "Cancel" then
                                            -- Обработка отмены
                                        end
                                    end
                                end
                            end
                        end
                        
                        -- Подключаем патченный обработчик
                        AirTypeService.Effect:Connect(patchedEffectHandler)
                    end
                end
                
                airTypePatched = true
            end
        end
        
        if state then
                Library:Notify({
                    Title = "Akaza: Air Control",
                    Content = "Akaza Air Control ENABLED.",
                    Duration = 2
                })
            else
                Library:Notify({
                    Title = "Akaza: Air Control",
                    Content = "Akaza Air Control DISABLED.",
                    Duration = 2
            })
        end
    end
})

-- Reapply Akaza patches
if akazaAirControlEnabled then
    local akazaAirControlToggle = AkazaBox.Flags.AkazaAirControlToggle
    if akazaAirControlToggle then
        akazaAirControlToggle:Set(true)
    end
end

-- Free Movesets
local movesetList = {"Akaza", "Default", "Gyutaro", "Rengoku", "Tanjiro", "Tengen"}
local selectedMoveset = nil

local FreeMovesetsBox = MainTab:AddLeftGroupbox("Free Movesets")
FreeMovesetsBox:AddLabel("Select a moveset style:")
FreeMovesetsBox:AddDropdown("MovesetDropdown", {
    Values = movesetList,
    Default = "Default",
    Multi = false,
    Text = "Choose moveset",
    Tooltip = "Change your moveset style instantly",
    Callback = function(val)
        selectedMoveset = val
    end
})
FreeMovesetsBox:AddButton("Apply Moveset", function()
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local Workspace = game:GetService("Workspace")
    local chars = Workspace:FindFirstChild("Characters")
    if LocalPlayer and selectedMoveset then
        LocalPlayer:SetAttribute("Moveset", selectedMoveset)
        local char = LocalPlayer.Character
        if char then
            char:SetAttribute("Moveset", selectedMoveset)
            
            local Knit = require(game:GetService("ReplicatedStorage").Knit.Packages.Knit)
            local MoveController = Knit.GetController("MoveController")
            local GlobalMoveset = require(game:GetService("ReplicatedStorage").Knit.Modules.GlobalMoveset)

            if MoveController and GlobalMoveset then
                MoveController:MovesSetup() 
                GlobalMoveset.SetupControls()
            else
                Library:Notify({
                    Title = "Error",
                    Content = "Failed to load MoveController or GlobalMoveset!",
                    Duration = 3
                })
            end

            local humanoid = char:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.Health = 0
            end

            Library:Notify({
                Title = "Moveset Changed",
                Content = "Your moveset is now: " .. selectedMoveset .. ". Character will reset.",
                Duration = 3
            })
        else
            Library:Notify({
                Title = "Error",
                Content = "Character not found! Cannot set Moveset on character.",
                Duration = 2
            })
        end
    else
        Library:Notify({
            Title = "Error",
            Content = "Select a moveset first!",
            Duration = 2
        })
    end
end)

-- Универсальный обработчик для повторного применения патчей после смерти персонажа
local function reapplyAllPatches()
    -- Главные тогглы и функции
    if noStunToggle and noStunToggle.Value then safeSet(noStunToggle, true) end
    if autoBlockToggle and autoBlockToggle.Value then safeSet(autoBlockToggle, true) end
    if antiHitboxToggle and antiHitboxToggle.Value then safeSet(antiHitboxToggle, true) end
    if espPlayersToggle and espPlayersToggle.Value then safeSet(espPlayersToggle, true) end
    if hidePostureBarToggle and hidePostureBarToggle.Value then safeSet(hidePostureBarToggle, true) end
    if hideParryBarToggle and hideParryBarToggle.Value then safeSet(hideParryBarToggle, true) end
    if gyutaroAutoAimToggle and gyutaroAutoAimToggle.Value then safeSet(gyutaroAutoAimToggle, true) end
    if gyutaroMultiThrowToggle and gyutaroMultiThrowToggle.Value then safeSet(gyutaroMultiThrowToggle, true) end
    if gyutaroAutoTargetToggle and gyutaroAutoTargetToggle.Value then safeSet(gyutaroAutoTargetToggle, true) end
    if akazaAirControlToggle and akazaAirControlToggle.Value then safeSet(akazaAirControlToggle, true) end
    if antiBleedToggle and antiBleedToggle.Value then safeSet(antiBleedToggle, true) end
    if antiPoisonToggle and antiPoisonToggle.Value then safeSet(antiPoisonToggle, true) end
    if antiSlowToggle and antiSlowToggle.Value then safeSet(antiSlowToggle, true) end
    if antiRootToggle and antiRootToggle.Value then safeSet(antiRootToggle, true) end
    if antiFreezeToggle and antiFreezeToggle.Value then safeSet(antiFreezeToggle, true) end
    if antiStunToggle and antiStunToggle.Value then safeSet(antiStunToggle, true) end
    if antiCombatTagToggle and antiCombatTagToggle.Value then safeSet(antiCombatTagToggle, true) end
    if attackAnyStatusToggle and attackAnyStatusToggle.Value then safeSet(attackAnyStatusToggle, true) end
    if fastHeavyClashToggle and fastHeavyClashToggle.Value then safeSet(fastHeavyClashToggle, true) end
    if removeMovementLimitsToggle and removeMovementLimitsToggle.Value then safeSet(removeMovementLimitsToggle, true) end
    if autoRemoveKnockedToggle and autoRemoveKnockedToggle.Value then safeSet(autoRemoveKnockedToggle, true) end
    if dashTowardsCameraToggle and dashTowardsCameraToggle.Value then safeSet(dashTowardsCameraToggle, true) end
    if noDashCooldownToggle and noDashCooldownToggle.Value then safeSet(noDashCooldownToggle, true) end
    if noAttackCooldownToggle and noAttackCooldownToggle.Value then safeSet(noAttackCooldownToggle, true) end
    if noJumpCooldownToggle and noJumpCooldownToggle.Value then safeSet(noJumpCooldownToggle, true) end
    if noHeavyAttackCooldownToggle and noHeavyAttackCooldownToggle.Value then safeSet(noHeavyAttackCooldownToggle, true) end
    if universalAttackToggle and universalAttackToggle.Value then safeSet(universalAttackToggle, true) end
    if forceBlockToggle and forceBlockToggle.Value then safeSet(forceBlockToggle, true) end
    if customAttackRangeToggle and customAttackRangeToggle.Value then safeSet(customAttackRangeToggle, true) end
    if infinitePostureToggle and infinitePostureToggle.Value then safeSet(infinitePostureToggle, true) end
    if infiniteJumpsToggle and infiniteJumpsToggle.Value then safeSet(infiniteJumpsToggle, true) end
    if fastRunAlwaysOnToggle and fastRunAlwaysOnToggle.Value then safeSet(fastRunAlwaysOnToggle, true) end
    if fastRunToggle and fastRunToggle.Value then safeSet(fastRunToggle, true) end
    if instantAttackToggle and instantAttackToggle.Value then safeSet(instantAttackToggle, true) end
    if noKnockbackToggle and noKnockbackToggle.Value then safeSet(noKnockbackToggle, true) end
    if stopStunAnimsToggle and stopStunAnimsToggle.Value then safeSet(stopStunAnimsToggle, true) end
    if noKnockbackMeleeToggle and noKnockbackMeleeToggle.Value then safeSet(noKnockbackMeleeToggle, true) end
    if soundSkillNoSlowToggle and soundSkillNoSlowToggle.Value then safeSet(soundSkillNoSlowToggle, true) end
    if soundLoudActAutoAimToggle and soundLoudActAutoAimToggle.Value then safeSet(soundLoudActAutoAimToggle, true) end
    if soundSkillRealRangeToggle and soundSkillRealRangeToggle.Value then safeSet(soundSkillRealRangeToggle, true) end
    if fastFlyingSickleToggle and fastFlyingSickleToggle.Value then safeSet(fastFlyingSickleToggle, true) end
    if multiCastMovesToggle and multiCastMovesToggle.Value then safeSet(multiCastMovesToggle, true) end
    if autoQEWinToggle and autoQEWinToggle.Value then safeSet(autoQEWinToggle, true) end
    -- Слайдеры и инпуты (пример для основных)
    if espDistanceSlider then safeSet(espDistanceSlider, espDistanceSlider.Value) end
    if heavyClashCooldownSlider then safeSet(heavyClashCooldownSlider, heavyClashCooldownSlider.Value) end
    if attackSpeedSlider then safeSet(attackSpeedSlider, attackSpeedSlider.Value) end
    if punchStunSpeedSlider then safeSet(punchStunSpeedSlider, punchStunSpeedSlider.Value) end
    if hardStunSpeedSlider then safeSet(hardStunSpeedSlider, hardStunSpeedSlider.Value) end
    if stunSpeedSlider then safeSet(stunSpeedSlider, stunSpeedSlider.Value) end
    if blockingSpeedSlider then safeSet(blockingSpeedSlider, blockingSpeedSlider.Value) end
    if knockedSpeedSlider then safeSet(knockedSpeedSlider, knockedSpeedSlider.Value) end
    if frontDashAmountInput then safeSet(frontDashAmountInput, frontDashAmountInput.Value) end
    if backDashAmountInput then safeSet(backDashAmountInput, backDashAmountInput.Value) end
    if leftDashAmountInput then safeSet(leftDashAmountInput, leftDashAmountInput.Value) end
    if rightDashAmountInput then safeSet(rightDashAmountInput, rightDashAmountInput.Value) end
    if customAttackRangeSlider then safeSet(customAttackRangeSlider, customAttackRangeSlider.Value) end
    if customAttackFarAmountSlider then safeSet(customAttackFarAmountSlider, customAttackFarAmountSlider.Value) end
    if customAttackCloseAmountSlider then safeSet(customAttackCloseAmountSlider, customAttackCloseAmountSlider.Value) end
    if customAttackCloseUpRangeSlider then safeSet(customAttackCloseUpRangeSlider, customAttackCloseUpRangeSlider.Value) end
    if customAttackTooFarRangeSlider then safeSet(customAttackTooFarRangeSlider, customAttackTooFarRangeSlider.Value) end
    if loudActVFXScaleSlider then safeSet(loudActVFXScaleSlider, loudActVFXScaleSlider.Value) end
    if musicalScoreVFXScaleSlider then safeSet(musicalScoreVFXScaleSlider, musicalScoreVFXScaleSlider.Value) end
    if performanceVFXScaleSlider then safeSet(performanceVFXScaleSlider, performanceVFXScaleSlider.Value) end
    if resoundingVFXScaleSlider then safeSet(resoundingVFXScaleSlider, resoundingVFXScaleSlider.Value) end
    if movesetDropdown then safeSet(movesetDropdown, movesetDropdown.Value) end
    if fastRunKeyDropdown then safeSet(fastRunKeyDropdown, fastRunKeyDropdown.Value) end
    -- ESP никнеймы
    if showDisplayNickToggle and showDisplayNickToggle.Value then safeSet(showDisplayNickToggle, true) end
    if showRealNickToggle and showRealNickToggle.Value then safeSet(showRealNickToggle, true) end
    -- === AutoBlock: восстановление всех настроек ===
    if autoBlockToggle then safeSet(autoBlockToggle, autoBlockToggle.Value) end
    if AutoBlockSettingsBox and AutoBlockSettingsBox.Flags then
        if AutoBlockSettingsBox.Flags.AutoBlockReleaseTimeSlider then
            safeSet(AutoBlockSettingsBox.Flags.AutoBlockReleaseTimeSlider, AutoBlockSettingsBox.Flags.AutoBlockReleaseTimeSlider.Value)
        end
        if AutoBlockSettingsBox.Flags.AutoBlockIgnoreTimeSlider then
            safeSet(AutoBlockSettingsBox.Flags.AutoBlockIgnoreTimeSlider, AutoBlockSettingsBox.Flags.AutoBlockIgnoreTimeSlider.Value)
        end
        if AutoBlockSettingsBox.Flags.StrictDangerousAnimBlockToggle then
            safeSet(AutoBlockSettingsBox.Flags.StrictDangerousAnimBlockToggle, AutoBlockSettingsBox.Flags.StrictDangerousAnimBlockToggle.Value)
        end
    end
    if dangerousAnimsDropdown and selectedDangerousAnims then
        dangerousAnimsDropdown.Values = allDangerousAnims
        safeSet(dangerousAnimsDropdown, selectedDangerousAnims)
    end
    if AutoBlockAnimsBox and AutoBlockAnimsBox.Flags then
        for anim, _ in pairs(_G.AutoBlockAnimFlags) do
            local toggle = AutoBlockAnimsBox.Flags["AutoBlockAnim_"..anim]
            if toggle then
                safeSet(toggle, toggle.Value)
            end
        end
    end
    -- Патчи и спец. функции
    if type(patchGyutaroSkills)=="function" then patchGyutaroSkills() end
    if akazaAirControlEnabled then
        local akazaAirControlToggle = AkazaBox.Flags and AkazaBox.Flags.AkazaAirControlToggle
        if akazaAirControlToggle then
            akazaAirControlToggle:Set(true)
        end
    end
    if type(updateNoKnockbackPatch)=="function" then updateNoKnockbackPatch() end
    -- === AutoBlock: восстановление всех настроек ===
    if AutoBlockSettingsBox and AutoBlockSettingsBox.Flags then
        if AutoBlockSettingsBox.Flags.AutoBlockReleaseTimeSlider then
            safeSet(AutoBlockSettingsBox.Flags.AutoBlockReleaseTimeSlider, AUTO_BLOCK_RELEASE_TIME)
        end
        if AutoBlockSettingsBox.Flags.AutoBlockIgnoreTimeSlider then
            safeSet(AutoBlockSettingsBox.Flags.AutoBlockIgnoreTimeSlider, AUTO_BLOCK_IGNORE_TIME)
        end
    end
    if AutoBlockAnimsBox and AutoBlockAnimsBox.Flags then
        for anim, flag in pairs(_G.AutoBlockAnimFlags) do
            local toggle = AutoBlockAnimsBox.Flags["AutoBlockAnim_"..anim]
            if toggle then
                safeSet(toggle, flag)
            end
        end
    end
    if autoBlockToggle and autoBlockToggle.Value then
        autoBlockToggle:Set(true)
    end
end

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    reapplyAllPatches()
end)


-- Настройки для анти-статусов
local antiStatusSettings = {
    Bleed = false,
    Poison = false,
    Slow = false,
    Root = false,
    Freeze = false,
    Stun = false,
    CombatTag = false,
}

-- === Переносим UI из AntiStatusBox в BypassMainBox ===
BypassMainBox:AddLabel("Select statuses to remove:")
antiBleedToggle = BypassMainBox:AddToggle("AntiBleedToggle", {
    Text = "Anti-Bleed",
    Default = false,
    Tooltip = "Automatically removes bleed effect",
    Callback = function(state) antiStatusSettings.Bleed = state end
})
antiPoisonToggle = BypassMainBox:AddToggle("AntiPoisonToggle", {
    Text = "Anti-Poison",
    Default = false,
    Tooltip = "Automatically removes poison",
    Callback = function(state) antiStatusSettings.Poison = state end
})
antiSlowToggle = BypassMainBox:AddToggle("AntiSlowToggle", {
    Text = "Anti-Slow",
    Default = false,
    Tooltip = "Automatically removes slowdown",
    Callback = function(state) antiStatusSettings.Slow = state end
})
antiRootToggle = BypassMainBox:AddToggle("AntiRootToggle", {
    Text = "Anti-Root",
    Default = false,
    Tooltip = "Automatically removes root/immobilization",
    Callback = function(state) antiStatusSettings.Root = state end
})
antiFreezeToggle = BypassMainBox:AddToggle("AntiFreezeToggle", {
    Text = "Anti-Freeze",
    Default = false,
    Tooltip = "Automatically removes freezing",
    Callback = function(state) antiStatusSettings.Freeze = state end
})
antiStunToggle = BypassMainBox:AddToggle("AntiStunToggle", {
    Text = "Anti-Stun",
    Default = false,
    Tooltip = "Automatically removes stun",
    Callback = function(state) antiStatusSettings.Stun = state end
})
antiCombatTagToggle = BypassMainBox:AddToggle("AntiCombatTagToggle", {
    Text = "Anti-CombatTag",
    Default = false,
    Tooltip = "Automatically removes CombatTag from character model",
    Callback = function(state) antiStatusSettings.CombatTag = state end
})

-- === Новые патчи с тогглами для обхода ограничений ===
-- 1. Атака при статусах (CanAttack и GetData)
local attackAnyStatusEnabled = false
local originalCanAttackBypass = MovesetHandler.CanAttack
local originalGetDataBypass = CharacterDataModule.GetData
attackAnyStatusToggle = BypassMainBox:AddToggle("AttackAnyStatusToggle", {
    Text = "No slow",
    Default = false,
    Tooltip = "No slowing even when stunned, blocked, etc.",
    Callback = function(state)
        if isLoadingConfig then return end
        attackAnyStatusEnabled = state
        if state then
            MovesetHandler.CanAttack = function(...)
                return true
            end
            CharacterDataModule.GetData = function(self, ...)
                local data = originalGetDataBypass(self, ...)
                data.Stun = 0
                data.HardStun = 0
                data.PunchStun = 0
                data.Blocking = false
                return data
            end
        else
            MovesetHandler.CanAttack = originalCanAttackBypass
            CharacterDataModule.GetData = originalGetDataBypass
        end
    end
})

-- 2. Быстрый HeavyClash (патч TagModule.Cooldown)
local fastHeavyClashEnabled = false
local heavyClashCooldown = 1
local originalCooldownBypass = TagModule.Cooldown
fastHeavyClashToggle = BypassMainBox:AddToggle("FastHeavyClashToggle", {
    Text = "Fast HeavyClash",
    Default = false,
    Tooltip = "Reduces HeavyClash cooldown to the specified value (sec)",
    Callback = function(state)
        if isLoadingConfig then return end
        fastHeavyClashEnabled = state
        if state then
            TagModule.Cooldown = function(self, obj, time, tag, ...)
                if tag == "HeavyClash" then
                    return originalCooldownBypass(self, obj, heavyClashCooldown, tag, ...)
                else
                    return originalCooldownBypass(self, obj, time, tag, ...)
                end
            end
        else
            TagModule.Cooldown = originalCooldownBypass
        end
    end
})
heavyClashCooldownSlider = BypassMainBox:AddSlider("HeavyClashCooldownSlider", {
    Text = "HeavyClash CD (sec)",
    Default = 1,
    Min = 0.1,
    Max = 10,
    Rounding = 1,
    Tooltip = "HeavyClash cooldown time (sec)",
    Callback = function(val)
        heavyClashCooldown = val
    end
})

-- 4. Снятие ограничений движения (PauseMovement, Knocked, Anchored)
local removeMovementLimitsEnabled = false
local removeMovementLimitsConn = nil
removeMovementLimitsToggle = BypassMainBox:AddToggle("RemoveMovementLimitsToggle", {
    Text = "Remove Movement Limits",
    Default = false,
    Tooltip = "Removes movement restrictions: PauseMovement, Knocked, Anchored, etc.",
    Callback = function(state)
        if isLoadingConfig then return end
        removeMovementLimitsEnabled = state
        if removeMovementLimitsConn then safeDisconnect(removeMovementLimitsConn) end
        if state then
            removeMovementLimitsConn = RunService.Heartbeat:Connect(function()
                local char = LocalPlayer.Character
                if char then
                    if char:GetAttribute("PauseMovement") then
                        char:SetAttribute("PauseMovement", nil)
                    end
                    if char:GetAttribute("Knocked") then
                        char:SetAttribute("Knocked", nil)
                    end
                    if char:FindFirstChild("HumanoidRootPart") then
                        char.HumanoidRootPart.Anchored = false
                    end
                end
            end)
        end
    end
})


-- === Сброс Blocking на каждом кадре для обхода блокировки атаки ===
local removeBlockingConn = nil
if removeBlockingConn then safeDisconnect(removeBlockingConn) end
removeBlockingConn = RunService.Heartbeat:Connect(function()
    local char = LocalPlayer.Character
    if char and char:GetAttribute("Blocking") then
        char:SetAttribute("Blocking", false)
    end
end)

-- === Attack Speed Slider (скорость при атаке) ===
local attackSpeedValue = 10
local punchStunSpeedValue = 10

attackSpeedSlider = MainRight:AddSlider("AttackSpeedSlider", {
    Text = "Attack Speed (requires No knockback)",
    Default = 10,
    Min = 1,
    Max = 50,
    Rounding = 0,
    Tooltip = "Set WalkSpeed while Attacking.",
    Callback = function(val)
        attackSpeedValue = val
        print("[Config] AttackSpeedSlider set to:", val)
    end
})

punchStunSpeedSlider = MainRight:AddSlider("PunchStunSpeedSlider", {
    Text = "PunchStun Speed",
    Default = 10,
    Min = 1,
    Max = 50,
    Rounding = 0,
    Tooltip = "Set WalkSpeed while in PunchStun.",
    Callback = function(val)
        punchStunSpeedValue = val
        print("[Config] PunchStunSpeedSlider set to:", val)
    end
})

-- Удаляем старые RenderStepped/Heartbeat патчи, связанные с этими слайдерами
if speedPatchConn then safeDisconnect(speedPatchConn) end
speedPatchConn = nil

-- Жёсткий патч скорости: выставляем WalkSpeed каждый кадр после всех изменений
local forceSpeedConn = nil
if forceSpeedConn then safeDisconnect(forceSpeedConn) end
forceSpeedConn = game:GetService("RunService").RenderStepped:Connect(function()
    local char = LocalPlayer.Character
    if not char then return end
    local hum = char:FindFirstChildWhichIsA("Humanoid")
    if not hum then return end
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local CharacterDataModule = require(ReplicatedStorage.Knit.Modules.Data.CharacterData)
    local data = nil
    pcall(function()
        data = CharacterDataModule.GetData()
    end)
    if not data then return end
    -- Жёстко выставляем скорость в нужных состояниях
    if data.PunchStun and data.PunchStun > 0 then
        hum.WalkSpeed = punchStunSpeedValue
    elseif data.Attacking and data.Attacking > 0 then
        hum.WalkSpeed = attackSpeedValue
    end
end)

-- Патчируем SpeedController
local speedControllerPatched = false
local originalRenderStepped = nil

local function patchSpeedController()
    if speedControllerPatched then return end
    speedControllerPatched = true
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local CharacterDataModule = require(ReplicatedStorage.Knit.Modules.Data.CharacterData)
    local function onStep()
        local char = LocalPlayer.Character
        if not char then return end
        local hum = char:FindFirstChildWhichIsA("Humanoid")
        if not hum then return end
        local data = CharacterDataModule.GetData(char)
        if not data then return end
        if (data.HardStun or 0) > 0 then
            hum.WalkSpeed = 0
            hum.JumpPower = 0
        elseif (data.Stun or 0) > 0 then
            hum.WalkSpeed = 4
            hum.JumpPower = 0
        elseif data.Blocking then
            hum.WalkSpeed = 2
            hum.JumpPower = 0
        elseif (data.PunchStun or 0) > 0 then
            hum.WalkSpeed = punchStunSpeedValue
            hum.JumpPower = 0
        elseif (data.Attacking or 0) > 0 then
            hum.WalkSpeed = attackSpeedValue
            hum.JumpPower = 0
        elseif data.Running then
            hum.WalkSpeed = data.Agility or 20
            hum.JumpPower = 0
        else
            hum.WalkSpeed = 10
            hum.JumpPower = 30
        end
    end
    originalRenderStepped = RunService.RenderStepped:Connect(onStep)
end

patchSpeedController()

-- === Speed Settings (MainRight) ===
local speedValues = speedValues or {
    HardStun = 4,
    Stun = 4,
    Blocking = 2,
    PunchStun = 10,
    Attacking = 10,
    Knocked = 0,
}
local autoRemoveKnocked = autoRemoveKnocked or false

MainRight:AddLabel("Speed Settings")
hardStunSpeedSlider = MainRight:AddSlider("HardStunSpeedSlider", {
    Text = "HardStun Speed (requires no Knockback)",
    Min = 0,
    Max = 30,
    Default = speedValues.HardStun,
    Rounding = 0,
    Tooltip = "Speed during HardStun (requires No Knockback)",
    Callback = function(val) speedValues.HardStun = val end
})
stunSpeedSlider = MainRight:AddSlider("StunSpeedSlider", {
    Text = "Stun Speed (requires No Knockback)",
    Min = 0,
    Max = 30,
    Default = speedValues.Stun,
    Rounding = 0,
    Tooltip = "Speed during Stun (requires No Knockback)",
    Callback = function(val) speedValues.Stun = val end
})
blockingSpeedSlider = MainRight:AddSlider("BlockingSpeedSlider", {
    Text = "Blocking Speed (requires No Knockback)",
    Min = 0,
    Max = 30,
    Default = speedValues.Blocking,
    Rounding = 0,
    Tooltip = "Speed during Blocking (requires No Knockback)",
    Callback = function(val) speedValues.Blocking = val end
})
knockedSpeedSlider = MainRight:AddSlider("KnockedSpeedSlider", {
    Text = "Knocked Speed (requires No Knockback)",
    Min = 0,
    Max = 30,
    Default = speedValues.Knocked,
    Rounding = 0,
    Tooltip = "Speed during Knocked (requires No Knockback)",
    Callback = function(val) speedValues.Knocked = val end
})
autoRemoveKnockedToggle = MainRight:AddToggle("AutoRemoveKnockedToggle", {
    Text = "Auto Remove Knocked",
    Default = autoRemoveKnocked,
    Tooltip = "Automatically removes Knocked status if enabled.",
    Callback = function(state) autoRemoveKnocked = state end
})

-- === Dash Settings (MainRight) ===
local dashAmounts = dashAmounts or {
    Front = 95,
    Back = 110,
    Left = 130,
    Right = 130
}
local dashDuration = dashDuration or 0.15
local dashTowardsCameraEnabled = dashTowardsCameraEnabled or false

MainRight:AddLabel("Dash Settings")
dashTowardsCameraToggle = MainRight:AddToggle("DashTowardsCameraToggle", {
    Text = "Dash Towards Camera",
    Default = dashTowardsCameraEnabled,
    Tooltip = "If enabled, dash uses camera direction. If disabled, uses character direction.",
    Callback = function(state)
        dashTowardsCameraEnabled = state
    end
})
frontDashAmountInput = MainRight:AddInput("FrontDashAmount", {
    Text = "Front Dash Amount",
    Default = tostring(dashAmounts.Front),
    Numeric = true,
    Finished = true,
    Tooltip = "Amount for forward dash (default: 90)",
    Placeholder = "5-900",
    Callback = function(value)
        local num = tonumber(value)
        if num and num >= 5 and num <= 900 then
            dashAmounts.Front = num
        end
    end
})
backDashAmountInput = MainRight:AddInput("BackDashAmount", {
    Text = "Back Dash Amount",
    Default = tostring(dashAmounts.Back),
    Numeric = true,
    Finished = true,
    Tooltip = "Amount for backward dash (default: 90)",
    Placeholder = "5-900",
    Callback = function(value)
        local num = tonumber(value)
        if num and num >= 5 and num <= 900 then
            dashAmounts.Back = num
        end
    end
})
leftDashAmountInput = MainRight:AddInput("LeftDashAmount", {
    Text = "Left Dash Amount",
    Default = tostring(dashAmounts.Left),
    Numeric = true,
    Finished = true,
    Tooltip = "Amount for left dash (default: 90)",
    Placeholder = "5-900",
    Callback = function(value)
        local num = tonumber(value)
        if num and num >= 5 and num <= 900 then
            dashAmounts.Left = num
        end
    end
})
rightDashAmountInput = MainRight:AddInput("RightDashAmount", {
    Text = "Right Dash Amount",
    Default = tostring(dashAmounts.Right),
    Numeric = true,
    Finished = true,
    Tooltip = "Amount for right dash (default: 90)",
    Placeholder = "5-900",
    Callback = function(value)
        local num = tonumber(value)
        if num and num >= 5 and num <= 900 then
            dashAmounts.Right = num
        end
    end
})

-- Dash Hold (hold dash key to repeatedly dash)
local dashHoldEnabled = false
local dashHoldInterval = 0.08
local dashHoldActive = false
local lastDashHoldTick = 0
local dashHoldKeyConns = { began = nil, ended = nil }
local dashHoldMobileConns = {}
local dashHoldLoopConn
local dashGamepadKey = nil

dashHoldToggle = MainRight:AddToggle("DashHoldToggle", {
    Text = "Dash Hold",
    Default = false,
    Tooltip = "Hold dash key/button to dash continuously (best with No Dash Cooldown)",
    Callback = function(state)
        dashHoldEnabled = state
        if not state then
            dashHoldActive = false
        end
    end
})

dashHoldIntervalSlider = MainRight:AddSlider("DashHoldIntervalSlider", {
    Text = "Dash Hold Interval (s)",
    Min = 0.03,
    Max = 0.2,
    Default = dashHoldInterval,
    Rounding = 3,
    Tooltip = "Delay between auto dashes while holding",
    Callback = function(v) dashHoldInterval = v end
})

local function ensureDashControl()
    pcall(function()
        local _, pdata = v_u_7.GetController("DataController"):GetPlayerDataAsync():await()
        dashGamepadKey = pdata and pdata:GetControl("Dash", "Gamepad") or nil
    end)
end

local function setDashHold(state)
    if not dashHoldEnabled then state = false end
    dashHoldActive = state
    if state then lastDashHoldTick = 0 end
end

-- PC/Gamepad listeners
if dashHoldKeyConns.began then dashHoldKeyConns.began:Disconnect() end
if dashHoldKeyConns.ended then dashHoldKeyConns.ended:Disconnect() end
ensureDashControl()
dashHoldKeyConns.began = UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Enum.KeyCode.Q or (dashGamepadKey and input.KeyCode == dashGamepadKey) then
        setDashHold(true)
    end
end)
dashHoldKeyConns.ended = UserInputService.InputEnded:Connect(function(input, _)
    if input.KeyCode == Enum.KeyCode.Q or (dashGamepadKey and input.KeyCode == dashGamepadKey) then
        setDashHold(false)
    end
end)

-- Mobile button listeners
local function disconnectMobileDash()
    for _, c in ipairs(dashHoldMobileConns) do pcall(function() c:Disconnect() end) end
    dashHoldMobileConns = {}
end
local function setupMobileDash()
    disconnectMobileDash()
    local gui = LocalPlayer:FindFirstChild("PlayerGui")
    if not gui then return end
    local hud = gui:FindFirstChild("MobileHUD")
    if not hud then return end
    local controls = hud:FindFirstChild("Controls")
    if not controls then return end
    local dashBtn = controls:FindFirstChild("Dash") or controls:FindFirstChild("DashButton")
    if not dashBtn then return end
    table.insert(dashHoldMobileConns, dashBtn.MouseButton1Down:Connect(function() setDashHold(true) end))
    if dashBtn.MouseButton1Up then
        table.insert(dashHoldMobileConns, dashBtn.MouseButton1Up:Connect(function() setDashHold(false) end))
    else
        table.insert(dashHoldMobileConns, dashBtn.InputEnded:Connect(function() setDashHold(false) end))
    end
end
if UserInputService.TouchEnabled then
    setupMobileDash()
    LocalPlayer.PlayerGui.ChildAdded:Connect(function(child)
        if child.Name == "MobileHUD" then
            task.wait(0.2)
            setupMobileDash()
        end
    end)
end

-- Dash hold loop
if dashHoldLoopConn then dashHoldLoopConn:Disconnect() end
dashHoldLoopConn = RunService.Heartbeat:Connect(function()
    if not dashHoldEnabled or not dashHoldActive then return end
    local now = tick()
    if now - lastDashHoldTick >= dashHoldInterval then
        lastDashHoldTick = now
        -- Optional: unblock if currently blocking
        pcall(function()
            local ch = LocalPlayer.Character
            if ch then
                local d = CharacterDataModule.GetData(ch)
                if d and d.Blocking then
                    local hum = ch:FindFirstChildOfClass("Humanoid")
                    if hum then GlobalMoveset.UnblockAnim(hum) end
                end
            end
        end)
        GlobalMoveset.Dash()
    end
end)

-- Функция для получения направления даша
local function getDashDirection(char)
    local camera = workspace.CurrentCamera
    if not camera then return Vector3.new(0, 0, -1) end
    
    local baseCFrame
    if dashTowardsCameraEnabled then
        baseCFrame = camera.CFrame
    else
        -- Используем CFrame персонажа, если тоггл выключен
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then 
            return camera.CFrame.LookVector -- Fallback to camera if HRP not found
        end
        baseCFrame = hrp.CFrame
    end
    
    -- Получаем базовое направление от CFrame
    local lookVector = baseCFrame.LookVector
    local rightVector = baseCFrame.RightVector
    
    -- Определяем нажатые клавиши
    local moveDir = Vector3.new(0, 0, 0)
    if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveDir = moveDir + lookVector end
    if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveDir = moveDir - lookVector end
    if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveDir = moveDir + rightVector end
    if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveDir = moveDir - rightVector end
    
    -- Если нет инпута, используем направление вперед
    if moveDir.Magnitude < 0.1 then
        return lookVector
    end
    
    -- Нормализуем вектор движения
    return moveDir.Unit
end

-- Патчируем функцию ClientDash для изменения dash только у LocalPlayer
local originalClientDash = GlobalMoveset.ClientDash
GlobalMoveset.ClientDash = function(p29, p_u_30, p31, p32)
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local char = p29 or LocalPlayer.Character
    
    if char and char == LocalPlayer.Character then
        p32 = p32 or {}
        
        -- Получаем направление даша
        local dashDir = getDashDirection(char)
        
        -- Определяем тип даша на основе нажатых клавиш
        local dashAmount = dashAmounts.Front -- По умолчанию используем передний даш
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            dashAmount = dashAmounts.Back
        elseif UserInputService:IsKeyDown(Enum.KeyCode.A) then
            dashAmount = dashAmounts.Left
        elseif UserInputService:IsKeyDown(Enum.KeyCode.D) then
            dashAmount = dashAmounts.Right
        end
        
        -- Применяем выбранное значение DashAmount
        p32.DashAmount = dashAmount
        
        -- Вызов оригинальной функции с обновленными параметрами
        originalClientDash(p29, p_u_30, p31, p32)
        
        -- Получаем HumanoidRootPart
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then
            local bv = hrp:FindFirstChild("DashVelocity")
            if bv and bv:IsA("BodyVelocity") then
                -- Применяем направление и скорость
                bv.MaxForce = Vector3.new(50000, 50000, 50000)
                bv.Velocity = dashDir * dashAmount
                
                -- Удаляем через dashDuration
                task.delay(dashDuration, function()
                    if bv and bv.Parent then
                        bv:Destroy()
                    end
                end)
            end
        end
    else
        -- Вызываем оригинальную функцию для всех остальных игроков
        return originalClientDash(p29, p_u_30, p31, p32)
    end
end

-- === Patch Cooldowns/Delays Toggles ===
local patchCooldowns = {
    Dash = {enabled = false},
    Attack = {enabled = false},
    Jump = {enabled = false},
    HeavyAttack = {enabled = false},
}
local originalCheckCD = TagModule.CheckCD
local originalCooldown = TagModule.Cooldown

local function patchTagModule()
    TagModule.CheckCD = function(self, char, tag, ...)
        tag = tostring(tag)
        if patchCooldowns.Dash.enabled and tag:find("Dash") then
            return false
        end
        if patchCooldowns.Jump.enabled and tag:find("Super Jump") then
            return false
        end
        if patchCooldowns.Attack.enabled and (tag:find("Attack") or tag:find("Swing")) then
            return false
        end
        if patchCooldowns.HeavyAttack.enabled and tag:find("HeavyClash") then
            return false
        end
        return originalCheckCD(self, char, tag, ...)
    end
    TagModule.Cooldown = function(self, char, time, tag, ...)
        tag = tostring(tag)
        if patchCooldowns.Dash.enabled and tag:find("Dash") then
            return -- No cooldown
        end
        if patchCooldowns.Jump.enabled and tag:find("Super Jump") then
            return -- No cooldown
        end
        if patchCooldowns.Attack.enabled and (tag:find("Attack") or tag:find("Swing")) then
            return -- No cooldown
        end
        if patchCooldowns.HeavyAttack.enabled and tag:find("HeavyClash") then
            return -- No cooldown
        end
        return originalCooldown(self, char, time, tag, ...)
    end
end

local function restoreTagModule()
    TagModule.CheckCD = originalCheckCD
    TagModule.Cooldown = originalCooldown
end

-- === UI Toggles ===
BypassMainBox:AddLabel("No Cooldown Options")
noDashCooldownToggle = BypassMainBox:AddToggle("NoDashCooldownToggle", {
    Text = "No Dash Cooldown",
    Default = false,
    Tooltip = "Removes the cooldown between dashes.",
    Callback = function(state)
        patchCooldowns.Dash.enabled = state
        patchTagModule()
    end
})
noAttackCooldownToggle = BypassMainBox:AddToggle("NoAttackCooldownToggle", {
    Text = "No Attack Cooldown",
    Default = false,
    Tooltip = "Removes the cooldown between attacks (M1/M2).",
    Callback = function(state)
        patchCooldowns.Attack.enabled = state
        patchTagModule()
    end
})
noJumpCooldownToggle = BypassMainBox:AddToggle("NoJumpCooldownToggle", {
    Text = "No Jump Cooldown",
    Default = false,
    Tooltip = "Removes the cooldown for Super Jumps.",
    Callback = function(state)
        patchCooldowns.Jump.enabled = state
        patchTagModule()
    end
})
noHeavyAttackCooldownToggle = BypassMainBox:AddToggle("NoHeavyAttackCooldownToggle", {
    Text = "No Heavy Attack Cooldown",
    Default = false,
    Tooltip = "Removes the cooldown for heavy attacks (HeavyClash).",
    Callback = function(state)
        patchCooldowns.HeavyAttack.enabled = state
        patchTagModule()
    end
})

-- === Custom Features (Advanced Patches) - Перенесено в BypassMainBox ===
BypassMainBox:AddLabel("Advanced Features")

universalAttackToggle = BypassMainBox:AddToggle("UniversalAttackToggle", {
    Text = "Universal Attack",
    Default = false,
    Tooltip = "Allows attacking while stunned or blocking.",
    Callback = function(state)
        if isLoadingConfig then return end
        universalAttackEnabled = state
        pcall(function()
            local Knit = require(game:GetService("ReplicatedStorage").Knit.Packages.Knit)
            local CombatController = Knit.GetController("CombatController")
            local CharacterDataModule = require(game:GetService("ReplicatedStorage").Knit.Modules.Data.CharacterData)
            local UserInputService = game:GetService("UserInputService")
            if not originalLeftClick then
                originalLeftClick = CombatController.LeftClick
            end
            if universalAttackConn then safeDisconnect(universalAttackConn) end
            if state then
                universalAttackConn = RunService.Heartbeat:Connect(function()
                    if universalAttackEnabled then
                        local data = CharacterDataModule.GetData(LocalPlayer.Character)
                        if data then
                            data.Stun = 0
                            data.HardStun = 0
                            data.PunchStun = 0
                        end
                    end
                end)
                CombatController.LeftClick = function(...)
                    if universalAttackEnabled and UserInputService:IsKeyDown(Enum.KeyCode.F) then
                        CombatController:StopBlock()
                        task.wait()
                        originalLeftClick(...)
                        task.delay(0.1, function()
                            if UserInputService:IsKeyDown(Enum.KeyCode.F) and universalAttackEnabled then
                               CombatController:Block()
                            end
                        end)
                    else
                        originalLeftClick(...)
                    end
                end
            else
                CombatController.LeftClick = originalLeftClick
            end
        end)
    end
})

forceBlockToggle = BypassMainBox:AddToggle("ForceBlockToggle", {
    Text = "Force Block",
    Default = false,
    Tooltip = "Prevents your block from being interrupted as long as you hold the F key.",
    Callback = function(state)
        forceBlockEnabled = state
        pcall(function()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local Knit = require(ReplicatedStorage.Knit.Packages.Knit)
            local CombatController = Knit.GetController("CombatController")
            if not originalStopBlock then
                originalStopBlock = CombatController.StopBlock
            end
            if state then
                CombatController.StopBlock = function(self, ...)
                    local UserInputService = game:GetService("UserInputService")
                    if forceBlockEnabled and UserInputService:IsKeyDown(Enum.KeyCode.F) then
                        return -- Do nothing, keep blocking
                    end
                    return originalStopBlock(self, ...)
                end
            else
                if originalStopBlock then
                    CombatController.StopBlock = originalStopBlock
                end
            end
        end)
    end
})

-- === Custom Attack Range (исправленная логика) - Перенесено в BypassMainBox ===
customAttackRangeToggle = BypassMainBox:AddToggle("CustomAttackRangeToggle", {
    Text = "aim assist",
    Default = false,
    Tooltip = "aim assist niga",
    Callback = function(state)
        customAttackRangeEnabled = state
        local GlobalMoveset = require(game:GetService("ReplicatedStorage").Knit.Modules.GlobalMoveset)
        if not originalGetHitCharacters then
            originalGetHitCharacters = GlobalMoveset.GetHitCharacters
        end
        if not originalAttackFunc then
            originalAttackFunc = GlobalMoveset.Attack
        end
        if state then
            GlobalMoveset.GetHitCharacters = function(self, cframe, size, ...)
                if customAttackRangeEnabled then
                    size = Vector3.new(customAttackRangeValue, customAttackRangeValue, customAttackRangeValue)
                end
                return originalGetHitCharacters(self, cframe, size, ...)
            end
            GlobalMoveset.Attack = function(p_u_93, p_u_94, p_u_95, p_u_96, p_u_97, p98)
                if customAttackRangeEnabled and p_u_97 then
                    p_u_97.FarAmount = customAttackFarAmount
                    p_u_97.CloseAmount = customAttackCloseAmount
                    p_u_97.CloseUpRange = customAttackCloseUpRange
                    p_u_97.TooFarRange = customAttackTooFarRange
                end
                return originalAttackFunc(p_u_93, p_u_94, p_u_95, p_u_96, p_u_97, p98)
            end
        else
            if originalGetHitCharacters then
                GlobalMoveset.GetHitCharacters = originalGetHitCharacters
            end
            if originalAttackFunc then
                GlobalMoveset.Attack = originalAttackFunc
            end
        end
    end
})
BypassMainBox:AddSlider("CustomAttackRangeSlider", {
    Text = "aim assist Size",
    Min = 10,
    Max = 300,
    Default = 20,
    Rounding = 0,
    Tooltip = "Custom",
    Callback = function(val)
        customAttackRangeValue = val
    end
})
customAttackFarAmountSlider = BypassMainBox:AddSlider("CustomAttackFarAmountSlider", {
    Text = "Far Amount",
    Min = 10,
    Max = 400,
    Default = 70,
    Rounding = 0,
    Tooltip = "FarAmount (distance for far dash)",
    Callback = function(val)
        customAttackFarAmount = val
    end
})
customAttackCloseAmountSlider = BypassMainBox:AddSlider("CustomAttackCloseAmountSlider", {
    Text = "Close Amount",
    Min = 10,
    Max = 400,
    Default = 90,
    Rounding = 0,
    Tooltip = "CloseAmount (distance for close dash)",
    Callback = function(val)
        customAttackCloseAmount = val
    end
})
BypassMainBox:AddSlider("CustomAttackCloseUpRangeSlider", {
    Text = "CloseUp Range",
    Min = 5,
    Max = 150,
    Default = 10,
    Rounding = 0,
    Tooltip = "CloseUpRange (distance for close-up hit)",
    Callback = function(val)
        customAttackCloseUpRange = val
    end
})
BypassMainBox:AddSlider("CustomAttackTooFarRangeSlider", {
    Text = "TooFar Range",
    Min = 50,
    Max = 400,
    Default = 120,
    Rounding = 0,
    Tooltip = "TooFarRange (max distance",
    Callback = function(val)
        customAttackTooFarRange = val
    end
})

infinitePostureToggle = BypassMainBox:AddToggle("InfinitePostureToggle", {
    Text = "Infinite Posture",
    Default = false,
    Tooltip = "Your posture bar will never decrease.",
    Callback = function(state)
        infinitePostureEnabled = state
        if infinitePostureConn then safeDisconnect(infinitePostureConn) infinitePostureConn = nil end
        if state then
            local Players = game:GetService("Players")
            local LocalPlayer = Players.LocalPlayer
            infinitePostureConn = game:GetService("RunService").RenderStepped:Connect(function()
                local char = LocalPlayer.Character
                if char then
                    char:SetAttribute("Posture", 100)
                end
            end)
        end
    end
})


infiniteJumpsToggle = BypassMainBox:AddToggle("InfiniteJumpsToggle", {
    Text = "Infinite Jumps",
    Default = false,
    Tooltip = "Allows you to jump infinitely in the air.",
    Callback = function(state)
        infiniteJumpsEnabled = state
        local PlayerController = require(game:GetService("ReplicatedStorage").Knit.Controllers.PlayerController)
        if not originalGroundCheck then
            originalGroundCheck = PlayerController.GroundCheck
        end
        if state then
            PlayerController.GroundCheck = function(...)
                return true
            end
        else
            if originalGroundCheck then
                PlayerController.GroundCheck = originalGroundCheck
            end
        end
    end
})

instantAttackToggle = BypassMainBox:AddToggle("InstantAttackToggle", {
    Text = "Instant Attack",
    Default = false,
    Tooltip = "Removes attack delay and makes attack animation instant.",
    Callback = function(state)
        instantAttackEnabled = state
        pcall(function()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local GlobalMoveset = require(ReplicatedStorage.Knit.Modules.GlobalMoveset)
            local CharacterDataModule = require(ReplicatedStorage.Knit.Modules.Data.CharacterData)
            local MovesetHandler = require(ReplicatedStorage.Knit.Modules.MovesetHandler)
            if not originalAttack then
                originalAttack = GlobalMoveset.Attack
            end
            if state then
                GlobalMoveset.Attack = function(p_u_93, p_u_94, p_u_95, p_u_96, p_u_97, p98)
                    local v99 = p_u_93:FindFirstChild("HumanoidRootPart")
                    if not v99 then return end
                    local v_u_100 = p_u_93:FindFirstChild("Humanoid")
                    if not v_u_100 then return end
                    if not MovesetHandler.CanAttack(p_u_93) then return end
                    local v_u_101 = CharacterDataModule.GetData(p_u_93)
                    local v_u_103 = v_u_101.CurrentCombo or 1
                    local v_u_108 = GlobalMoveset.GetMovesetAnims(p_u_93)
                    local v_u_135 = nil
                    -- Запуск анимации с ускорением
                    if p_u_96 then
                        v_u_135 = v_u_100.Animator:LoadAnimation(v_u_108.M2)
                    else
                        v_u_135 = v_u_100.Animator:LoadAnimation(v_u_108.M1s:FindFirstChild("M1-" .. v_u_103))
                    end
                    if v_u_135 then
                        v_u_135:Play()
                        v_u_135:AdjustSpeed(999)
                    end
                    -- Мгновенно увеличиваем комбо
                    if v_u_103 > 4 then
                        v_u_101.CurrentCombo = 1
                    else
                        v_u_101.CurrentCombo = v_u_103 + 1
                    end
                    -- Мгновенно наносим урон всем целям в зоне поражения
                    local v_u_137 = v99.CFrame
                    local v138 = GlobalMoveset.GetHitCharacters(nil, v_u_137 * CFrame.new(0, 0, -3.2), Vector3.new(8, 6, 8))
                    local v_u_139 = p_u_97 and p_u_97.DamageSettings or {Damage = 1, Stun = 0.1, Effect = nil, UseStats = false, Knockback = 0}
                    for _, v_u_141 in v138 do
                        if v_u_141 ~= p_u_93 then
                            local v142 = v_u_141:FindFirstChild("Humanoid")
                            if v142 and v_u_141:FindFirstChild("Torso") then
                                GlobalMoveset.MovesetHandler.GlobalMoveset.CombatService:Damage(v_u_141, {
                                    ["AttackedBy"] = p_u_93,
                                    ["Damage"] = v_u_139.Damage,
                                    ["Stun"] = v_u_139.Stun,
                                    ["Effect"] = v_u_139.Effect,
                                    ["UseStats"] = v_u_139.UseStats,
                                    ["Knockback"] = v_u_139.Knockback
                                })
                            end
                        end
                    end
                end
            else
                GlobalMoveset.Attack = originalAttack
            end
        end)
    end
})

-- === Godmode, No Knockback, etc. (Перенесено в BypassMainBox) ===
noKnockbackToggle = BypassMainBox:AddToggle("NoKnockbackToggle", {
    Text = "No Knockback",
    Default = false,
    Tooltip = "Prevents your character from being knocked back or ragdolled.",
    Callback = function(state)
        noKnockbackEnabled = state
        if noKnockbackConn then safeDisconnect(noKnockbackConn) end
        pcall(function()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local MovesetHandler = require(ReplicatedStorage.Knit.Modules.MovesetHandler)
            if not originalKnockbackVelocity then
                originalKnockbackVelocity = MovesetHandler.KnockbackVelocity
            end
            if state then
                MovesetHandler.KnockbackVelocity = function(...) end
                -- Удаляем все BodyVelocity и BodyAngularVelocity кроме dash
                noKnockbackConn = game:GetService("RunService").RenderStepped:Connect(function()
                    local char = LocalPlayer.Character
                    if char then
                        local hrp = char:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            local hasJumpTrails = hrp:FindFirstChild("JumpTrails")
                            if not hasJumpTrails then
                                for _, obj in ipairs(hrp:GetChildren()) do
                                    if (obj:IsA("BodyVelocity") or obj:IsA("BodyAngularVelocity")) and not obj.Name:find("Dash") then
                                        obj:Destroy()
                                    end
                                end
                            end
                        end
                    end
                end)
            else
                MovesetHandler.KnockbackVelocity = originalKnockbackVelocity
                if noKnockbackConn then safeDisconnect(noKnockbackConn) end
            end
        end)
    end
})


stopStunAnimsToggle = BypassMainBox:AddToggle("StopStunAnimsToggle", {
    Text = "Stop All Stun/Flinch Anims",
    Default = false,
    Tooltip = "Instantly stops all stun, flinch, and block animations.",
    Callback = function(state)
        stopStunAnimsEnabled = state
        pcall(function()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local MovesetHandler = require(ReplicatedStorage.Knit.Modules.MovesetHandler)
            if not originalStopEssentialAnims then
                originalStopEssentialAnims = MovesetHandler.StopEssentialAnims
            end
            if state then
                MovesetHandler.StopEssentialAnims = function(char)
                    local hum = char:FindFirstChild("Humanoid")
                    if hum then
                        for _, track in hum.Animator:GetPlayingAnimationTracks() do
                            track:Stop(0)
                        end
                    end
                end
            else
                MovesetHandler.StopEssentialAnims = originalStopEssentialAnims
            end
        end)
    end
})


-- === Knockback Toggles (новая рабочая версия) - Перенесено в BypassMainBox ===
noKnockbackMeleeToggle = BypassMainBox:AddToggle("NoKnockbackMeleeToggle", {
    Text = "No Knockback (Melee Only)",
    Default = false,
    Tooltip = "Blocks knockback from normal attacks (BUGGY) For full protection enable normal no knockback'.",
    Callback = function(state)
        noKnockbackMeleeEnabled = state
        updateNoKnockbackPatch()
    end
})

function updateNoKnockbackPatch()
    -- Отключаем старый RenderStepped
    if noKnockbackConn then safeDisconnect(noKnockbackConn) end
    -- Если оба выключены — возвращаем оригинал
    if not noKnockbackMeleeEnabled and not noKnockbackAllEnabled then
        MovesetHandler.KnockbackVelocity = originalKnockbackVelocity
        return
    end
    -- Патчим KnockbackVelocity
    MovesetHandler.KnockbackVelocity = function(p45, p46, p47)
        local char = LocalPlayer.Character
        if p45 and char and p45 == char then
            local force = tonumber(p46) or 0
            if noKnockbackAllEnabled then
                return -- Блокируем всё
            elseif noKnockbackMeleeEnabled and force > 0 and force <= 150 then
                return -- Блокируем только обычные удары
            else
                return originalKnockbackVelocity(p45, p46, p47)
            end
        else
            return originalKnockbackVelocity(p45, p46, p47)
        end
    end
    -- RenderStepped: удаляем BodyVelocity/BodyAngularVelocity
    noKnockbackConn = RunService.RenderStepped:Connect(function()
        local char = LocalPlayer.Character
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local hasJumpTrails = hrp:FindFirstChild("JumpTrails")
        for _, obj in ipairs(hrp:GetChildren()) do
            if (obj:IsA("BodyVelocity") or obj:IsA("BodyAngularVelocity")) and not obj.Name:find("Dash") then
                if not hasJumpTrails then
                    if noKnockbackAllEnabled then
                        obj:Destroy()
                    elseif noKnockbackMeleeEnabled then
                        local vel = obj.Velocity or obj.AngularVelocity or Vector3.new(0,0,0)
                        if vel.Magnitude <= 150 then
                            obj:Destroy()
                        end
                    end
                end
            end
        end
    end)
end

-- === Sound (Tengen) Skill Exploits ===
local soundSkillNoSlowEnabled = false
local soundSkillAnimSpeed = 1
local soundSkillVFXScale = {
    LoudAct = 1,
    MusicalScore = 1,
    Performance = 1,
    Resounding = 1
}
local soundSkillNoCDEnabled = false
local TagModule = require(game:GetService("ReplicatedStorage").Knit.Modules.TagModule)
local originalSkillCooldown = TagModule.Cooldown

local TengenBox = ExploitsTab:AddRightGroupbox("Tengen Exploits (MAY NOT WORK)")

soundSkillAnimSpeedSlider = TengenBox:AddSlider("SoundSkillAnimSpeedSlider", {
    Text = "Skill Animation Speed",
    Min = 0.5,
    Max = 3,
    Default = 1,
    Rounding = 2,
    Tooltip = "Adjusts animation speed for Sound skills.",
    Callback = function(val)
        soundSkillAnimSpeed = val
    end
})
loudActVFXScaleSlider = TengenBox:AddSlider("LoudActVFXScaleSlider", {
    Text = "LoudAct VFX Scale",
    Min = 1,
    Max = 5,
    Default = 1,
    Rounding = 1,
    Tooltip = "VFX scale for LoudAct skill.",
    Callback = function(val)
        soundSkillVFXScale.LoudAct = val
    end
})
musicalScoreVFXScaleSlider = TengenBox:AddSlider("MusicalScoreVFXScaleSlider", {
    Text = "MusicalScore VFX Scale",
    Min = 1,
    Max = 5,
    Default = 1,
    Rounding = 1,
    Tooltip = "VFX scale for MusicalScore skill.",
    Callback = function(val)
        soundSkillVFXScale.MusicalScore = val
    end
})
performanceVFXScaleSlider = TengenBox:AddSlider("PerformanceVFXScaleSlider", {
    Text = "Performance VFX Scale",
    Min = 1,
    Max = 5,
    Default = 1,
    Rounding = 1,
    Tooltip = "VFX scale for Performance skill.",
    Callback = function(val)
        soundSkillVFXScale.Performance = val
    end
})
resoundingVFXScaleSlider = TengenBox:AddSlider("ResoundingVFXScaleSlider", {
    Text = "Resounding VFX Scale",
    Min = 1,
    Max = 5,
    Default = 1,
    Rounding = 1,
    Tooltip = "VFX scale for Resounding skill.",
    Callback = function(val)
        soundSkillVFXScale.Resounding = val
    end
})
soundLoudActAutoAimToggle = TengenBox:AddToggle("SoundLoudActAutoAimToggle", {
    Text = "LoudAct Auto-Aim",
    Default = false,
    Tooltip = "Automatically aims LoudAct throws at the nearest enemy.",
    Callback = function(state)
        soundLoudActAutoAimEnabled = state
    end
})
soundSkillRealRangeToggle = TengenBox:AddToggle("SoundSkillRealRangeToggle", {
    Text = "Sound Skills: Real Range+",
    Default = false,
    Tooltip = "Increases real hit/area range for Sound skills (LoudAct, Performance, MusicalScore, Resounding).",
    Callback = function(state)
        soundSkillRealRangeEnabled = state
    end
})

-- Реализация патчей для Sound Skills
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local soundSkillConn = nil
if soundSkillConn then safeDisconnect(soundSkillConn) end
soundSkillConn = RunService.RenderStepped:Connect(function()
    local char = LocalPlayer.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    for _, track in ipairs(hum.Animator:GetPlayingAnimationTracks()) do
        -- No Slow: если активна анимация скилла, выставляем WalkSpeed = 10
        if soundSkillNoSlowEnabled and (
            track.Name:find("LoudAct") or track.Name:find("MusicalScore") or track.Name:find("Performance") or track.Name:find("Resounding")
        ) then
            hum.WalkSpeed = 10
        end
        -- Skill Animation Speed: ускоряем анимацию
        if (
            track.Name:find("LoudAct") or track.Name:find("MusicalScore") or track.Name:find("Performance") or track.Name:find("Resounding")
        ) then
            track:AdjustSpeed(soundSkillAnimSpeed)
        end
    end
end)

-- Патчируем создание VFX для увеличения масштаба
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Knit = require(ReplicatedStorage.Knit.Packages.Knit)

local function patchVFXScale(controllerName, skillKey)
    local success, controller = pcall(function()
        return Knit.GetController(controllerName)
    end)
    if success and controller and controller.Effect then
        -- Сохраняем оригинальную функцию Connect
        if not controller._originalConnect then
            controller._originalConnect = controller.Effect.Connect
        end
        
        -- Патчим Connect только если еще не патчили
        if not controller._VFXScalePatched then
            controller._VFXScalePatched = true
            controller.Effect.Connect = function(callback)
                return controller._originalConnect(function(p1, p2, p3)
                    -- Патчим VFX объекты
                    if p2 then
                        for _, obj in ipairs(p2:GetDescendants()) do
                            if obj:IsA("BasePart") or obj:IsA("ParticleEmitter") then
                                if obj.Size then
                                    obj.Size = obj.Size * (soundSkillVFXScale[skillKey] or 1)
                                end
                                if obj.Scale then
                                    obj.Scale = obj.Scale * (soundSkillVFXScale[skillKey] or 1)
                                end
                            end
                        end
                    end
                    callback(p1, p2, p3)
                end)
            end
        end
    end
end

patchVFXScale("LoudActController", "LoudAct")
patchVFXScale("MusicalScoreController", "MusicalScore")
patchVFXScale("PerformanceController", "Performance")
patchVFXScale("ResoundingController", "Resounding")

-- Удаляем No Skill Cooldown (Sound)
soundSkillNoCDEnabled = nil
if StyleBox.Flags and StyleBox.Flags.SoundSkillNoCDToggle then
    StyleBox.Flags.SoundSkillNoCDToggle = nil
end
TagModule.Cooldown = originalSkillCooldown

-- Патч LoudAct: автонаведение бросков
local function patchLoudActAutoAim()
    local success, controller = pcall(function()
        return Knit.GetController("LoudActController")
    end)
    if success and controller and controller.Effect then
        -- Сохраняем оригинальную функцию Connect
        if not controller._originalLoudActConnect then
            controller._originalLoudActConnect = controller.Effect.Connect
        end
        
        -- Патчим Connect только если еще не патчили
        if not controller._AutoAimPatched then
            controller._AutoAimPatched = true
            controller.Effect.Connect = function(callback)
                return controller._originalLoudActConnect(function(p15, p_u_16, p17)
                    if soundLoudActAutoAimEnabled and p15 == "Throw" and p_u_16 and p17 then
                        local myChar = game.Players.LocalPlayer.Character
                        if myChar and myChar == p_u_16 then
                            local hrp = myChar:FindFirstChild("HumanoidRootPart")
                            local target = getNearestEnemyModel(hrp.Position, 100)
                            if target and target:FindFirstChild("HumanoidRootPart") then
                                for _, v_u_26 in ipairs(p17) do
                                    v_u_26.Position = target.HumanoidRootPart.Position + Vector3.new(0,2,0)
                                end
                            end
                        end
                    end
                    callback(p15, p_u_16, p17)
                end)
            end
        end
    end
end
patchLoudActAutoAim()

-- Патч увеличения реального радиуса/дальности урона для Sound Skills
local function patchSoundSkillRealRange()
    local function patchController(controllerName, skillKey)
        local success, controller = pcall(function()
            return Knit.GetController(controllerName)
        end)
        if success and controller and controller.Effect then
            -- Сохраняем оригинальную функцию Connect
            if not controller["_originalConnect_"..skillKey] then
                controller["_originalConnect_"..skillKey] = controller.Effect.Connect
            end
            
            -- Патчим Connect только если еще не патчили
            if not controller["_RealRangePatched_"..skillKey] then
                controller["_RealRangePatched_"..skillKey] = true
                controller.Effect.Connect = function(callback)
                    return controller["_originalConnect_"..skillKey](function(p1, p2, p3)
                        if soundSkillRealRangeEnabled and p2 then
                            for _, obj in ipairs(p2:GetDescendants()) do
                                if obj:IsA("BasePart") and obj.Name:find("Hitbox") then
                                    obj.Size = obj.Size * 2 -- Увеличиваем реальный hitbox в 2 раза
                                end
                            end
                        end
                        callback(p1, p2, p3)
                    end)
                end
            end
        end
    end
    patchController("LoudActController", "LoudAct")
    patchController("MusicalScoreController", "MusicalScore")
    patchController("PerformanceController", "Performance")
    patchController("ResoundingController", "Resounding")
end
patchSoundSkillRealRange()

-- === Fast Skill Toggles ===
local fastAirTypeEnabled = false
local fastFreshCleaveEnabled = false
local fastPoisonVeinEnabled = false
local fastRampantArcEnabled = false
local fastFlyingSickleEnabled = false

fastFlyingSickleToggle = StyleBox:AddToggle("FastFlyingSickleToggle", {
    Text = "Fast FlyingSickle (Gyutaro)",
    Default = false,
    Tooltip = "Makes Gyutaro's FlyingSickle skill play almost instantly.",
    Callback = function(state)
        fastFlyingSickleEnabled = state
    end
})

-- === Fast Skill Animation Patches ===
local function patchFastSkillAnimations()
    -- Akaza AirType
    local successAkaza, AirTypeController = pcall(function()
        return require(ReplicatedStorage.Knit.Controllers.MoveControllers.Akaza.AirTypeController)
    end)
    if successAkaza and AirTypeController then
        local origAkazaKnitStart = AirTypeController.KnitStart
        AirTypeController.KnitStart = function(self, ...)
            origAkazaKnitStart(self, ...)
            local Knit = require(ReplicatedStorage.Knit.Packages.Knit)
            local AirTypeService = Knit.GetService("AirTypeService")
            if AirTypeService and AirTypeService.Effect then
                AirTypeService.Effect:Connect(function(p15, p16)
                    if (p15 == "Start" and fastAirTypeEnabled) or (p15 == "Shoot" and fastAirTypeEnabled) then
                        local char = p16.Character
                        if char then
                            local hum = char:FindFirstChild("Humanoid")
                            if hum then
                                for _, track in ipairs(hum.Animator:GetPlayingAnimationTracks()) do
                                    track:AdjustSpeed(10)
                                end
                            end
                        end
                    end
                end)
            end
        end
    end
    -- FreshCleave
    local successFC, FreshCleaveController = pcall(function()
        return require(ReplicatedStorage.Knit.Controllers.MoveControllers.Gyutaro.FreshCleaveController)
    end)
    if successFC and FreshCleaveController then
        local origFCKnitStart = FreshCleaveController.KnitStart
        FreshCleaveController.KnitStart = function(self, ...)
            origFCKnitStart(self, ...)
            local Knit = require(ReplicatedStorage.Knit.Packages.Knit)
            local FreshCleaveService = Knit.GetService("FreshCleaveService")
            if FreshCleaveService and FreshCleaveService.Effect then
                FreshCleaveService.Effect:Connect(function(p18, p19)
                    if (p18 == "Start" and fastFreshCleaveEnabled) or (p18 == "Shoot" and fastFreshCleaveEnabled) then
                        local char = p19.Character or p19
                        if char then
                            local hum = char:FindFirstChild("Humanoid")
                            if hum then
                                for _, track in ipairs(hum.Animator:GetPlayingAnimationTracks()) do
                                    track:AdjustSpeed(10)
                                end
                            end
                        end
                    end
                end)
            end
        end
    end
    -- PoisonVein
    local successPV, PoisonVeinController = pcall(function()
        return require(ReplicatedStorage.Knit.Controllers.MoveControllers.Gyutaro.PoisonVeinController)
    end)
    if successPV and PoisonVeinController then
        local origPVKnitStart = PoisonVeinController.KnitStart
        PoisonVeinController.KnitStart = function(self, ...)
            origPVKnitStart(self, ...)
            local Knit = require(ReplicatedStorage.Knit.Packages.Knit)
            local PoisonVeinService = Knit.GetService("PoisonVeinService")
            if PoisonVeinService and PoisonVeinService.Effect then
                PoisonVeinService.Effect:Connect(function(p13, p14)
                    if (p13 == "Start" and fastPoisonVeinEnabled) or (p13 == "Shoot" and fastPoisonVeinEnabled) then
                        local char = p14.Character or p14
                        if char then
                            local hum = char:FindFirstChild("Humanoid")
                            if hum then
                                for _, track in ipairs(hum.Animator:GetPlayingAnimationTracks()) do
                                    track:AdjustSpeed(10)
                                end
                            end
                        end
                    end
                end)
            end
        end
    end
    -- RampantArc
    local successRA, RampantArcController = pcall(function()
        return require(ReplicatedStorage.Knit.Controllers.MoveControllers.Gyutaro.RampantArcController)
    end)
    if successRA and RampantArcController then
        local origRAKnitStart = RampantArcController.KnitStart
        RampantArcController.KnitStart = function(self, ...)
            origRAKnitStart(self, ...)
            local Knit = require(ReplicatedStorage.Knit.Packages.Knit)
            local RampantArcService = Knit.GetService("RampantArcService")
            if RampantArcService and RampantArcService.Effect then
                RampantArcService.Effect:Connect(function(p13, p14)
                    if (p13 == "Start" and fastRampantArcEnabled) or (p13 == "Shoot" and fastRampantArcEnabled) then
                        local char = p14.Character or p14
                        if char then
                            local hum = char:FindFirstChild("Humanoid")
                            if hum then
                                for _, track in ipairs(hum.Animator:GetPlayingAnimationTracks()) do
                                    track:AdjustSpeed(10)
                                end
                            end
                        end
                    end
                end)
            end
        end
    end
    -- FlyingSickleController
    local successFS, FlyingSickleController = pcall(function()
        return require(ReplicatedStorage.Knit.Controllers.MoveControllers.Gyutaro.FlyingSickleController)
    end)
    if successFS and FlyingSickleController then
        local origFSKnitStart = FlyingSickleController.KnitStart
        FlyingSickleController.KnitStart = function(self, ...)
            origFSKnitStart(self, ...)
            local Knit = require(ReplicatedStorage.Knit.Packages.Knit)
            local EmitController = require(ReplicatedStorage.Knit.Modules.EmitController)
            if EmitController and EmitController.Effect then
                EmitController.Effect:Connect(function(p15, p16)
                    if ((p15 == "Start" or p15 == "Shoot") and fastFlyingSickleEnabled) then
                        local char = p16.Character
                        if char then
                            local hum = char:FindFirstChild("Humanoid")
                            if hum then
                                for _, track in ipairs(hum.Animator:GetPlayingAnimationTracks()) do
                                    track:AdjustSpeed(10)
                                end
                            end
                        end
                    end
                end)
            end
        end
    end
end
patchFastSkillAnimations()

-- === MultiCast Moves Exploit ===
local multiCastMovesEnabled = false
CombatExploitsBox:AddToggle("MultiCastMovesToggle", {
    Text = "Multi-Cast Moves",
    Default = false,
    Tooltip = "Casts each move several times per press (may work only if server is not strict)",
    Callback = function(state)
        multiCastMovesEnabled = state
    end
})

-- Патч UseMove:Fire для мульти-каста
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Knit = require(ReplicatedStorage.Knit.Packages.Knit)
local MoveController = Knit.GetController("MoveController")
local originalUseMoveFire = nil
if MoveController and MoveController.UseMove and MoveController.UseMove.Fire then
    originalUseMoveFire = MoveController.UseMove.Fire
    MoveController.UseMove.Fire = function(self, ...)
        if multiCastMovesEnabled then
            for i = 1, 3 do -- 3 раза подряд
                originalUseMoveFire(self, ...)
                task.wait(0.05)
            end
        else
            originalUseMoveFire(self, ...)
        end
    end
end

-- === Auto QE Win Exploit ===
local autoQEWinEnabled = false
autoQEWinToggle = CombatExploitsBox:AddToggle("AutoQEWinToggle", {
    Text = "Auto QE Win",
    Default = false,
    Tooltip = "Automatically clicks in Quick Event (Clash) for instant win.",
    Callback = function(state)
        autoQEWinEnabled = state
    end
})

local QEController = nil
pcall(function()
    QEController = Knit.GetController("QEController")
end)
local CharacterDataModule = require(ReplicatedStorage.Knit.Modules.Data.CharacterData)
local RunService = game:GetService("RunService")
local autoQEConn = nil
if autoQEConn then safeDisconnect(autoQEConn) end
autoQEConn = RunService.Heartbeat:Connect(function()
    if autoQEWinEnabled and QEController and QEController.Click then
        local data = CharacterDataModule.GetDataSoft and CharacterDataModule.GetDataSoft() or CharacterDataModule.GetData()
        if data and data.InQE then
            local last = tonumber(data.LastClick or 0)
            if tick() - last >= 0.051 then
                QEController:Click()
            end
        end
    end
end)

-- === Auto QE Input Simulation (PC + Mobile) ===
local VIM = game:GetService("VirtualInputManager")
-- unified under Auto QE Win toggle
local autoQESimEnabled = true
local autoQESimMobile = true
local autoQECPS = 60 -- clicks per second

-- remove extra toggles: controlled by AutoQEWinToggle
CombatExploitsBox:AddSlider("AutoQECpsSlider", {
    Text = "Auto QE CPS",
    Min = 20, Max = 120, Default = autoQECPS, Rounding = 0,
    Callback = function(v) autoQECPS = v end
})

local function _qeTargetPoint()
    local gui = LocalPlayer:FindFirstChild("PlayerGui")
    if gui then
        local qe = gui:FindFirstChild("QuickEvent")
        if qe and qe.Enabled and qe:FindFirstChild("QEFrame") then
            local btn = qe.QEFrame:FindFirstChildOfClass("ImageButton") or qe.QEFrame:FindFirstChild("ImageButton")
            if btn and btn.AbsoluteSize.X > 0 then
                local c = btn.AbsolutePosition + (btn.AbsoluteSize/2)
                return c.X, c.Y
            end
        end
    end
    -- fallback: center of screen
    local cam = workspace.CurrentCamera
    local vps = cam and cam.ViewportSize or Vector2.new(800,600)
    return vps.X/2, vps.Y/2
end

local _autoQESimConn
if _autoQESimConn then _autoQESimConn:Disconnect() end
_autoQESimConn = RunService.RenderStepped:Connect(function(dt)
    if not autoQEWinEnabled then return end
    if not autoQESimEnabled then return end
    if not QEController or not QEController.Click then return end
    local data = (CharacterDataModule.GetDataSoft and CharacterDataModule.GetDataSoft()) or CharacterDataModule.GetData()
    if not (data and data.InQE) then return end

    local clicksThisFrame = math.clamp(math.floor(autoQECPS * dt + 0.5), 1, 5)
    local x, y = _qeTargetPoint()
    for i=1, clicksThisFrame do
        -- Mouse click simulation (PC)
        pcall(function()
            VIM:SendMouseButtonEvent(x, y, 0, true, game, 0)
            VIM:SendMouseButtonEvent(x, y, 0, false, game, 0)
        end)
        -- Touch tap simulation (Mobile)
        if autoQESimMobile and UserInputService.TouchEnabled then
            pcall(function()
                VIM:SendTouchEvent(x, y, 0, true, game)
                VIM:SendTouchEvent(x, y, 0, false, game)
            end)
        end
    end
end)

-- === Auto Dodge (Behind) and Auto Clash ===
-- Toggles and settings
local autoClashEnabled = false

local autoClashMinInterval = 1.2 -- min time between clash attempts

local lastAutoClash = 0

CombatExploitsBox:AddToggle("AutoClashToggle", {
    Text = "Auto Clash",
    Default = false,
    Tooltip = "Automatically attempt HeavyClash on close dangerous attacks",
    Callback = function(state) autoClashEnabled = state end
})

-- Helpers
local function _isDangerousAnim(name)
    if not name then return false end
    if _G.AutoBlockAnimFlags and _G.AutoBlockAnimFlags[name] ~= nil then
        return _G.AutoBlockAnimFlags[name]
    end
    if name:find("^M1%-") or name == "M2" then return true end
    local base = { Parry=true, Destruct=true, Disorder=true, RampantArc=true, SickleThrow=true, FlameBarrage=true }
    return base[name] or false
end

local function _nearestThreat(myChar, radius)
    if not myChar then return nil end
    local myHRP = myChar:FindFirstChild("HumanoidRootPart"); if not myHRP then return nil end
    local best, bestD
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character then
            local ch = pl.Character
            local hrp = ch:FindFirstChild("HumanoidRootPart")
            local hum = ch:FindFirstChildOfClass("Humanoid")
            if hrp and hum and hum.Health > 0 then
                local d = (hrp.Position - myHRP.Position).Magnitude
                if d <= radius then
                    local animator = hum:FindFirstChildOfClass("Animator")
                    local danger = false
                    if animator then
                        for _, tr in ipairs(animator:GetPlayingAnimationTracks()) do
                            if _isDangerousAnim(tr.Name) then danger = true break end
                        end
                    end
                    if danger and (not best or d < bestD) then best, bestD = ch, d end
                end
            end
        end
    end
    return best
end

local function _sideDirAndBehind(myHRP, enemyHRP)
    local sideRight = myHRP.CFrame.RightVector
    local sideLeft  = -sideRight
    local behindPos = enemyHRP.Position - enemyHRP.CFrame.LookVector * (autoDodgeBackOffset + 2)
    local toBehind = (behindPos - myHRP.Position)
    local unit = toBehind.Magnitude > 1e-3 and toBehind.Unit or sideRight
    local projR = unit:Dot(sideRight)
    local projL = unit:Dot(sideLeft)
    return (projR >= projL) and sideRight or sideLeft, behindPos
end

-- Auto Dodge loop
local _autoDodgeConn
if _autoDodgeConn then _autoDodgeConn:Disconnect() end
_autoDodgeConn = RunService.Heartbeat:Connect(function()
    if not autoDodgeEnabled then return end
    local myChar = LocalPlayer.Character; if not myChar then return end
    local myHum = myChar:FindFirstChildOfClass("Humanoid"); if not myHum or myHum.Health <= 0 then return end
    local myHRP = myChar:FindFirstChild("HumanoidRootPart"); if not myHRP then return end
    local data = CharacterDataModule.GetData(myChar)
    if not data or (data.Stun or 0) > 0 or (data.HardStun or 0) > 0 or (data.Blocking or false) then return end

    local threat = _nearestThreat(myChar, autoDodgeRadius)
    if not threat then return end
    if tick() - lastAutoDodge < autoDodgeMinInterval then return end
    lastAutoDodge = tick()

    -- ensure not blocking; some states block dashes
    if data.Blocking then
        pcall(function() GlobalMoveset.UnblockAnim(myHum) end)
    end

    -- start dash
    GlobalMoveset.Dash()

    task.spawn(function()
        task.wait() -- allow BV creation
        local bv = myHRP:FindFirstChild("DashVelocity")
        if (not bv) or (not bv:IsA("BodyVelocity")) then
            -- fallback if dash is on cooldown or blocked: spawn our own dash velocity
            bv = Instance.new("BodyVelocity")
            bv.Name = "DashVelocityAuto" -- contains "Dash" to bypass cleanup filters
            bv.Parent = myHRP
            bv.MaxForce = Vector3.new(50000, 50000, 50000)
            bv.P = 40000
            -- initial side nudge
            local fakeThreat = _nearestThreat(myChar, autoDodgeRadius)
            local enemyHRP = fakeThreat and fakeThreat:FindFirstChild("HumanoidRootPart")
            local sideDir = myHRP.CFrame.RightVector
            if enemyHRP then sideDir = (_sideDirAndBehind(myHRP, enemyHRP)) end
            bv.Velocity = (typeof(sideDir) == "Vector3" and sideDir or myHRP.CFrame.RightVector) * 110
        end
        bv.MaxForce = Vector3.new(50000, 50000, 50000)
        local bg = Instance.new("BodyGyro")
        bg.Parent = myHRP
        bg.D = 10; bg.P = 20000; bg.MaxTorque = Vector3.new(0, 30000, 0)
        local dashSpeed = (bv.Velocity.Magnitude > 1) and bv.Velocity.Magnitude or 120
        local t0 = tick()
        while tick() - t0 < autoDodgeArcTime and bv.Parent and threat.Parent do
            local enemyHRP = threat:FindFirstChild("HumanoidRootPart"); if not enemyHRP then break end
            local sideDir, behindPos = _sideDirAndBehind(myHRP, enemyHRP)
            local toBehind = (behindPos - myHRP.Position)
            local toBehindDir = toBehind.Magnitude > 1e-3 and toBehind.Unit or sideDir
            local alpha = math.clamp((tick() - t0)/autoDodgeArcTime, 0, 1)
            local dir = (sideDir * (1 - alpha) + toBehindDir * (alpha * 1.15)).Unit
            bv.Velocity = dir * dashSpeed
            bg.CFrame = CFrame.lookAt(myHRP.Position, enemyHRP.Position)
            RunService.Heartbeat:Wait()
        end
        if bg then bg:Destroy() end
    end)
end)

-- Auto Clash loop
local function _canClash()
    if tick() - lastAutoClash < autoClashMinInterval then return false end
    local myChar = LocalPlayer.Character; if not myChar then return false end
    local d = CharacterDataModule.GetData(myChar); if not d then return false end
    if (d.Stun or 0) > 0 or (d.HardStun or 0) > 0 then return false end
    return true
end

local _autoClashConn
if _autoClashConn then _autoClashConn:Disconnect() end
_autoClashConn = RunService.Heartbeat:Connect(function()
    if not autoClashEnabled then return end
    if not _canClash() then return end
    local myChar = LocalPlayer.Character; if not myChar then return end
    local myHRP = myChar:FindFirstChild("HumanoidRootPart"); if not myHRP then return end
    local target = _nearestThreat(myChar, 9)
    if not target then return end
    local enemyHRP = target:FindFirstChild("HumanoidRootPart"); if not enemyHRP then return end
    local enemyHum = target:FindFirstChildOfClass("Humanoid"); if not enemyHum or enemyHum.Health <= 0 then return end
    -- ensure roughly frontal
    local facingMe = (myHRP.CFrame.LookVector:Dot((enemyHRP.Position - myHRP.Position).Unit) > 0.5)
    local iFaceEnemy = (enemyHRP.CFrame.LookVector:Dot((myHRP.Position - enemyHRP.Position).Unit) > 0.3)
    if not (facingMe and iFaceEnemy) then return end
    lastAutoClash = tick()
    GlobalMoveset.FireHeavyAttack(target, true)
end)

-- === Новая вкладка Settings ===
local SettingsTab = Window:AddTab("Settings", "settings")
local ThemeBox = SettingsTab:AddLeftGroupbox("UI Theme")
local ConfigBox = SettingsTab:AddRightGroupbox("Config")

-- === Темы ===
local themes = {
    night = {
        MainColor = Color3.fromRGB(25, 25, 25),
        AccentColor = Color3.fromRGB(125, 85, 255),
        BackgroundColor = Color3.fromRGB(15, 15, 15),
        FontColor = Color3.new(1, 1, 1),
    },
    blood = {
        MainColor = Color3.fromRGB(40, 0, 0),
        AccentColor = Color3.fromRGB(200, 0, 0),
        BackgroundColor = Color3.fromRGB(15, 0, 0),
        FontColor = Color3.new(1, 0.8, 0.8),
    },
    blue = {
        MainColor = Color3.fromRGB(20, 20, 40),
        AccentColor = Color3.fromRGB(80, 120, 255),
        BackgroundColor = Color3.fromRGB(10, 10, 30),
        FontColor = Color3.fromRGB(200, 220, 255),
    },
    green = {
        MainColor = Color3.fromRGB(20, 40, 20),
        AccentColor = Color3.fromRGB(80, 255, 120),
        BackgroundColor = Color3.fromRGB(10, 30, 10),
        FontColor = Color3.fromRGB(220, 255, 200),
    },
    white = {
        MainColor = Color3.fromRGB(220, 220, 220),
        AccentColor = Color3.fromRGB(125, 85, 255),
        BackgroundColor = Color3.fromRGB(245, 245, 245),
        FontColor = Color3.fromRGB(30, 30, 30),
    },
}
local themeNames = {}
for name, _ in pairs(themes) do table.insert(themeNames, name) end
local defaultTheme = "night"
local currentTheme = defaultTheme
local function applyTheme(themeName)
    local theme = themes[themeName:lower()]
    if not theme then
        Library:Notify("Theme '"..themeName.."' not found! Using default.")
        theme = themes[defaultTheme]
        currentTheme = defaultTheme
    else
        currentTheme = themeName:lower()
    end
    -- Сначала применяем пресет
    Library.Scheme.MainColor = theme.MainColor
    Library.Scheme.AccentColor = theme.AccentColor
    Library.Scheme.BackgroundColor = theme.BackgroundColor
    Library.Scheme.FontColor = theme.FontColor
    -- Если кастомные цвета включены, они имеют приоритет
    if ThemeBox.Flags then
        if ThemeBox.Flags.CustomMainColorToggle and ThemeBox.Flags.CustomMainColorToggle.Value and customColors.Main then
            Library.Scheme.MainColor = customColors.Main
        end
        if ThemeBox.Flags.CustomAccentColorToggle and ThemeBox.Flags.CustomAccentColorToggle.Value and customColors.Accent then
            Library.Scheme.AccentColor = customColors.Accent
        end
        if ThemeBox.Flags.CustomBackgroundColorToggle and ThemeBox.Flags.CustomBackgroundColorToggle.Value and customColors.Background then
            Library.Scheme.BackgroundColor = customColors.Background
        end
        if ThemeBox.Flags.CustomFontColorToggle and ThemeBox.Flags.CustomFontColorToggle.Value and customColors.Font then
            Library.Scheme.FontColor = customColors.Font
        end
    end
    Library:UpdateColorsUsingRegistry()
end

ThemeBox:AddDropdown("ThemeDropdown", {
    Text = "Theme",
    Values = themeNames,
    Default = currentTheme,
    Callback = function(val)
        applyTheme(val)
    end
})

ThemeBox:AddDivider()
ThemeBox:AddLabel("Custom Colors")

local customColors = {
    Main = nil,
    Accent = nil,
    Background = nil,
    Font = nil
}

local MainColorToggle = ThemeBox:AddToggle("CustomMainColorToggle", {
    Text = "Custom Main Color",
    Default = false,
    Callback = function(state)
        if isLoadingConfig then return end
        if not state then
            customColors.Main = nil
            applyTheme(currentTheme)
        end
    end
})
MainColorToggle:AddColorPicker("CustomMainColor", {
    Default = Library.Scheme.MainColor,
    Title = "Main Color",
    Callback = function(val)
        customColors.Main = val
        Library.Scheme.MainColor = val
        Library:UpdateColorsUsingRegistry()
    end
})

local AccentColorToggle = ThemeBox:AddToggle("CustomAccentColorToggle", {
    Text = "Custom Accent Color",
    Default = false,
    Callback = function(state)
        if isLoadingConfig then return end
        if not state then
            customColors.Accent = nil
            applyTheme(currentTheme)
        end
    end
})
AccentColorToggle:AddColorPicker("CustomAccentColor", {
    Default = Library.Scheme.AccentColor,
    Title = "Accent Color",
    Callback = function(val)
        customColors.Accent = val
        Library.Scheme.AccentColor = val
        Library:UpdateColorsUsingRegistry()
    end
})

local BackgroundColorToggle = ThemeBox:AddToggle("CustomBackgroundColorToggle", {
    Text = "Custom Background Color",
    Default = false,
    Callback = function(state)
        if isLoadingConfig then return end
        if not state then
            customColors.Background = nil
            applyTheme(currentTheme)
        end
    end
})
BackgroundColorToggle:AddColorPicker("CustomBackgroundColor", {
    Default = Library.Scheme.BackgroundColor or Color3.fromRGB(15, 15, 15),
    Title = "Background Color",
    Callback = function(val)
        customColors.Background = val
        Library.Scheme.BackgroundColor = val or Color3.fromRGB(15, 15, 15)
        Library:UpdateColorsUsingRegistry()
    end
})

local FontColorToggle = ThemeBox:AddToggle("CustomFontColorToggle", {
    Text = "Custom Font Color",
    Default = false,
    Callback = function(state)
        if isLoadingConfig then return end
        if not state then
            customColors.Font = nil
            applyTheme(currentTheme)
        end
    end
})
FontColorToggle:AddColorPicker("CustomFontColor", {
    Default = Library.Scheme.FontColor,
    Title = "Font Color",
    Callback = function(val)
        customColors.Font = val
        Library.Scheme.FontColor = val
        Library:UpdateColorsUsingRegistry()
    end
})

-- === Конфиги ===
local configFolder = "INVHubMugen"
local configExt = ".json"
if not isfolder(configFolder) then makefolder(configFolder) end
local isUiReady = false -- Флаг готовности UI
local function getConfigs()
    local files = listfiles(configFolder)
    local configs = {}
    for _, file in ipairs(files) do
        if file:sub(-#configExt) == configExt then
            table.insert(configs, file:match("([^/\\]+)%"..configExt.."$") )
        end
    end
    table.sort(configs)
    return configs
end

-- После создания всех UI-элементов (после последнего AddToggle/AddSlider/AddInput и т.д.)
isUiReady = true

-- === saveConfig ===
local function safeSet(toggle, value)
    if not toggle then
        print("[safeSet] nil toggle!")
        return
    end
    task.spawn(function()
        if type(toggle.SetValue) == "function" then
            toggle:SetValue(value)
        elseif type(toggle.Set) == "function" then
            toggle:Set(value)
        elseif toggle.Value ~= nil then
            toggle.Value = value
        else
            print("[safeSet] toggle без методов:", toggle)
        end
        if type(toggle.Callback) == "function" then
            toggle.Callback(value)
        end
    end)
end

local function saveConfig(name)
    local data = { Theme = currentTheme }
    data.NoStun = noStunToggle and noStunToggle.Value or false
    data.AutoBlock = autoBlockToggle and autoBlockToggle.Value or false
    data.AntiHitbox = antiHitboxToggle and antiHitboxToggle.Value or false
    data.ESPPlayers = espPlayersToggle and espPlayersToggle.Value or false
    data.ESPDistance = espDistanceSlider and espDistanceSlider.Value or 400.5
    data.HidePostureBar = hidePostureBarToggle and hidePostureBarToggle.Value or false
    data.HideParryBar = hideParryBarToggle and hideParryBarToggle.Value or false
    data.GyutaroAutoAim = gyutaroAutoAimToggle and gyutaroAutoAimToggle.Value or false
    data.GyutaroMultiThrow = gyutaroMultiThrowToggle and gyutaroMultiThrowToggle.Value or false
    data.GyutaroMultiThrowCount = gyutaroMultiThrowCountSlider and gyutaroMultiThrowCountSlider.Value or 3
    data.GyutaroAutoTarget = gyutaroAutoTargetToggle and gyutaroAutoTargetToggle.Value or false
    data.GyutaroAutoTargetRadius = gyutaroAutoTargetRadiusSlider and gyutaroAutoTargetRadiusSlider.Value or 60
    data.AkazaAirControl = akazaAirControlToggle and akazaAirControlToggle.Value or false
    data.AntiBleed = antiBleedToggle and antiBleedToggle.Value or false
    data.AntiPoison = antiPoisonToggle and antiPoisonToggle.Value or false
    data.AntiSlow = antiSlowToggle and antiSlowToggle.Value or false
    data.AntiRoot = antiRootToggle and antiRootToggle.Value or false
    data.AntiFreeze = antiFreezeToggle and antiFreezeToggle.Value or false
    data.AntiStun = antiStunToggle and antiStunToggle.Value or false
    data.AntiCombatTag = antiCombatTagToggle and antiCombatTagToggle.Value or false
    data.AttackAnyStatus = attackAnyStatusToggle and attackAnyStatusToggle.Value or false
    data.FastHeavyClash = fastHeavyClashToggle and fastHeavyClashToggle.Value or false
    data.HeavyClashCooldown = heavyClashCooldownSlider and heavyClashCooldownSlider.Value or 1
    data.RemoveMovementLimits = removeMovementLimitsToggle and removeMovementLimitsToggle.Value or false
    data.AttackSpeed = attackSpeedSlider and attackSpeedSlider.Value or 10
    data.PunchStunSpeed = punchStunSpeedSlider and punchStunSpeedSlider.Value or 10
    data.HardStunSpeed = hardStunSpeedSlider and hardStunSpeedSlider.Value or 4
    data.StunSpeed = stunSpeedSlider and stunSpeedSlider.Value or 4
    data.BlockingSpeed = blockingSpeedSlider and blockingSpeedSlider.Value or 2
    data.KnockedSpeed = knockedSpeedSlider and knockedSpeedSlider.Value or 0
    data.AutoRemoveKnocked = autoRemoveKnockedToggle and autoRemoveKnockedToggle.Value or false
    data.DashTowardsCamera = dashTowardsCameraToggle and dashTowardsCameraToggle.Value or false
    data.FrontDashAmount = frontDashAmountInput and tonumber(frontDashAmountInput.Value) or 95
    data.BackDashAmount = backDashAmountInput and tonumber(backDashAmountInput.Value) or 110
    data.LeftDashAmount = leftDashAmountInput and tonumber(leftDashAmountInput.Value) or 130
    data.RightDashAmount = rightDashAmountInput and tonumber(rightDashAmountInput.Value) or 130
    data.NoDashCooldown = noDashCooldownToggle and noDashCooldownToggle.Value or false
    data.NoAttackCooldown = noAttackCooldownToggle and noAttackCooldownToggle.Value or false
    data.NoJumpCooldown = noJumpCooldownToggle and noJumpCooldownToggle.Value or false
    data.NoHeavyAttackCooldown = noHeavyAttackCooldownToggle and noHeavyAttackCooldownToggle.Value or false
    data.UniversalAttack = universalAttackToggle and universalAttackToggle.Value or false
    data.ForceBlock = forceBlockToggle and forceBlockToggle.Value or false
    data.CustomAttackRange = customAttackRangeToggle and customAttackRangeToggle.Value or false
    data.CustomAttackRangeValue = customAttackRangeSlider and customAttackRangeSlider.Value or 20
    data.CustomAttackFarAmount = customAttackFarAmountSlider and customAttackFarAmountSlider.Value or 70
    data.CustomAttackCloseAmount = customAttackCloseAmountSlider and customAttackCloseAmountSlider.Value or 90
    data.CustomAttackCloseUpRange = customAttackCloseUpRangeSlider and customAttackCloseUpRangeSlider.Value or 10
    data.CustomAttackTooFarRange = customAttackTooFarRangeSlider and customAttackTooFarRangeSlider.Value or 120
    data.InfinitePosture = infinitePostureToggle and infinitePostureToggle.Value or false
    data.InfiniteJumps = infiniteJumpsToggle and infiniteJumpsToggle.Value or false
    data.FastRunKey = fastRunKeyDropdown and fastRunKeyDropdown.Value or "E"
    data.FastRunAlwaysOn = fastRunAlwaysOnToggle and fastRunAlwaysOnToggle.Value or false
    data.FastRun = fastRunToggle and fastRunToggle.Value or false
    data.InstantAttack = instantAttackToggle and instantAttackToggle.Value or false
    data.NoKnockback = noKnockbackToggle and noKnockbackToggle.Value or false
    data.StopStunAnims = stopStunAnimsToggle and stopStunAnimsToggle.Value or false
    data.NoKnockbackMelee = noKnockbackMeleeToggle and noKnockbackMeleeToggle.Value or false
    data.SoundSkillNoSlow = soundSkillNoSlowToggle and soundSkillNoSlowToggle.Value or false
    data.SoundLoudActAutoAim = soundLoudActAutoAimToggle and soundLoudActAutoAimToggle.Value or false
    data.SoundSkillRealRange = soundSkillRealRangeToggle and soundSkillRealRangeToggle.Value or false
    data.LoudActVFXScale = loudActVFXScaleSlider and loudActVFXScaleSlider.Value or 1
    data.MusicalScoreVFXScale = musicalScoreVFXScaleSlider and musicalScoreVFXScaleSlider.Value or 1
    data.PerformanceVFXScale = performanceVFXScaleSlider and performanceVFXScaleSlider.Value or 1
    data.ResoundingVFXScale = resoundingVFXScaleSlider and resoundingVFXScaleSlider.Value or 1
    data.FastFlyingSickle = fastFlyingSickleToggle and fastFlyingSickleToggle.Value or false
    data.MultiCastMoves = multiCastMovesToggle and multiCastMovesToggle.Value or false
    data.AutoQEWin = autoQEWinToggle and autoQEWinToggle.Value or false
    data.Moveset = movesetDropdown and movesetDropdown.Value or "Default"
    data.ShowDisplayNick = showDisplayNickToggle and showDisplayNickToggle.Value or false
    data.ShowRealNick = showRealNickToggle and showRealNickToggle.Value or true
    -- === Auto Block Settings ===
    data.StrictDangerousAnimBlock = strictDangerousAnimBlockEnabled
    data.AutoBlockReleaseTime = _G.AUTO_BLOCK_RELEASE_TIME
    data.AutoBlockIgnoreTime = _G.AUTO_BLOCK_IGNORE_TIME
    data.SelectedDangerousAnims = selectedDangerousAnims
    data.SelectedDangerousAnims = selectedDangerousAnims
    data.CustomKillSoundEnabled = customKillSoundEnabled
    data.CustomKillSoundAssetId = customKillSoundAssetId
    data.CustomKillSoundVolume = customKillSoundVolume
    data.CustomKillSoundDuration = customKillSoundDuration
    data.CustomKillSoundTrim = customKillSoundTrim
    data.CustomKillSoundRadius = customKillSoundRadius
    data.CustomHitSoundEnabled = customHitSoundEnabled
    data.CustomHitSoundAssetId = customHitSoundAssetId
    data.CustomHitSoundVolume = customHitSoundVolume
    data.CustomHitSoundDuration = customHitSoundDuration
    data.CustomHitSoundTrim = customHitSoundTrim
    writefile(configFolder.."/"..name..configExt, game:GetService("HttpService"):JSONEncode(data))
    Library:Notify("Config saved: "..name)
    print("[Config] Saving config with AttackSpeed:", attackSpeedSlider and attackSpeedSlider.Value)
    print("[Config] Saving config with PunchStunSpeed:", punchStunSpeedSlider and punchStunSpeedSlider.Value)
end

-- === Глобальный флаг для защиты от зацикливания Callback-ов при загрузке конфига ===
local isLoadingConfig = false

local function loadConfig(name)
    local filePath = configFolder.."/"..name..configExt
    if not isfile(filePath) then
        Library:Notify("Config not found: "..name)
        return
    end
    local success, data = pcall(function()
        local content = readfile(filePath)
        return game:GetService("HttpService"):JSONDecode(content)
    end)
    if not success then
        Library:Notify("Failed to load config: "..(data or "Unknown error"))
        return
    end
    -- Сбросить все тогглы и слайдеры (вызывая safeSet)
    safeSet(noStunToggle, false)
    safeSet(autoBlockToggle, false)
    safeSet(antiHitboxToggle, false)
    safeSet(espPlayersToggle, false)
    safeSet(hidePostureBarToggle, false)
    safeSet(hideParryBarToggle, false)
    safeSet(gyutaroAutoAimToggle, false)
    safeSet(gyutaroMultiThrowToggle, false)
    safeSet(gyutaroAutoTargetToggle, false)
    safeSet(akazaAirControlToggle, false)
    safeSet(antiBleedToggle, false)
    safeSet(antiPoisonToggle, false)
    safeSet(antiSlowToggle, false)
    safeSet(antiRootToggle, false)
    safeSet(antiFreezeToggle, false)
    safeSet(antiStunToggle, false)
    safeSet(antiCombatTagToggle, false)
    safeSet(attackAnyStatusToggle, false)
    safeSet(fastHeavyClashToggle, false)
    safeSet(removeMovementLimitsToggle, false)
    safeSet(autoRemoveKnockedToggle, false)
    safeSet(dashTowardsCameraToggle, false)
    safeSet(noDashCooldownToggle, false)
    safeSet(noAttackCooldownToggle, false)
    safeSet(noJumpCooldownToggle, false)
    safeSet(noHeavyAttackCooldownToggle, false)
    safeSet(universalAttackToggle, false)
    safeSet(forceBlockToggle, false)
    safeSet(customAttackRangeToggle, false)
    safeSet(infinitePostureToggle, false)
    safeSet(infiniteJumpsToggle, false)
    safeSet(fastRunAlwaysOnToggle, false)
    safeSet(fastRunToggle, false)
    safeSet(instantAttackToggle, false)
    safeSet(noKnockbackToggle, false)
    safeSet(stopStunAnimsToggle, false)
    safeSet(noKnockbackMeleeToggle, false)
    safeSet(soundSkillNoSlowToggle, false)
    safeSet(soundLoudActAutoAimToggle, false)
    safeSet(soundSkillRealRangeToggle, false)
    safeSet(fastFlyingSickleToggle, false)
    safeSet(multiCastMovesToggle, false)
    safeSet(autoQEWinToggle, false)
    -- Применить тему
    if data.Theme then applyTheme(data.Theme) end
    -- Восстановить значения (вызывая safeSet)
    safeSet(noStunToggle, data.NoStun)
    safeSet(autoBlockToggle, data.AutoBlock)
    safeSet(antiHitboxToggle, data.AntiHitbox)
    safeSet(espPlayersToggle, data.ESPPlayers)
    if espDistanceSlider then safeSet(espDistanceSlider, data.ESPDistance or 400.5) end
    safeSet(hidePostureBarToggle, data.HidePostureBar)
    safeSet(hideParryBarToggle, data.HideParryBar)
    safeSet(gyutaroAutoAimToggle, data.GyutaroAutoAim)
    safeSet(gyutaroMultiThrowToggle, data.GyutaroMultiThrow)
    if gyutaroMultiThrowCountSlider then safeSet(gyutaroMultiThrowCountSlider, data.GyutaroMultiThrowCount or 3) end
    safeSet(gyutaroAutoTargetToggle, data.GyutaroAutoTarget)
    if gyutaroAutoTargetRadiusSlider then safeSet(gyutaroAutoTargetRadiusSlider, data.GyutaroAutoTargetRadius or 60) end
    safeSet(akazaAirControlToggle, data.AkazaAirControl)
    safeSet(antiBleedToggle, data.AntiBleed)
    safeSet(antiPoisonToggle, data.AntiPoison)
    safeSet(antiSlowToggle, data.AntiSlow)
    safeSet(antiRootToggle, data.AntiRoot)
    safeSet(antiFreezeToggle, data.AntiFreeze)
    safeSet(antiStunToggle, data.AntiStun)
    safeSet(antiCombatTagToggle, data.AntiCombatTag)
    safeSet(attackAnyStatusToggle, data.AttackAnyStatus)
    safeSet(fastHeavyClashToggle, data.FastHeavyClash)
    if heavyClashCooldownSlider then safeSet(heavyClashCooldownSlider, data.HeavyClashCooldown or 1) end
    safeSet(removeMovementLimitsToggle, data.RemoveMovementLimits)
    if attackSpeedSlider then safeSet(attackSpeedSlider, data.AttackSpeed or 10) end
    if punchStunSpeedSlider then safeSet(punchStunSpeedSlider, data.PunchStunSpeed or 10) end
    if hardStunSpeedSlider then safeSet(hardStunSpeedSlider, data.HardStunSpeed or 4) end
    if stunSpeedSlider then safeSet(stunSpeedSlider, data.StunSpeed or 4) end
    if blockingSpeedSlider then safeSet(blockingSpeedSlider, data.BlockingSpeed or 2) end
    if knockedSpeedSlider then safeSet(knockedSpeedSlider, data.KnockedSpeed or 0) end
    safeSet(autoRemoveKnockedToggle, data.AutoRemoveKnocked)
    safeSet(dashTowardsCameraToggle, data.DashTowardsCamera)
    if frontDashAmountInput then safeSet(frontDashAmountInput, tostring(data.FrontDashAmount or 95)) end
    if backDashAmountInput then safeSet(backDashAmountInput, tostring(data.BackDashAmount or 110)) end
    if leftDashAmountInput then safeSet(leftDashAmountInput, tostring(data.LeftDashAmount or 130)) end
    if rightDashAmountInput then safeSet(rightDashAmountInput, tostring(data.RightDashAmount or 130)) end
    safeSet(noDashCooldownToggle, data.NoDashCooldown)
    safeSet(noAttackCooldownToggle, data.NoAttackCooldown)
    safeSet(noJumpCooldownToggle, data.NoJumpCooldown)
    safeSet(noHeavyAttackCooldownToggle, data.NoHeavyAttackCooldown)
    safeSet(universalAttackToggle, data.UniversalAttack)
    safeSet(forceBlockToggle, data.ForceBlock)
    safeSet(customAttackRangeToggle, data.CustomAttackRange)
    if customAttackRangeSlider then safeSet(customAttackRangeSlider, data.CustomAttackRangeValue or 20) end
    if customAttackFarAmountSlider then safeSet(customAttackFarAmountSlider, data.CustomAttackFarAmount or 70) end
    if customAttackCloseAmountSlider then safeSet(customAttackCloseAmountSlider, data.CustomAttackCloseAmount or 90) end
    if customAttackCloseUpRangeSlider then safeSet(customAttackCloseUpRangeSlider, data.CustomAttackCloseUpRange or 10) end
    if customAttackTooFarRangeSlider then safeSet(customAttackTooFarRangeSlider, data.CustomAttackTooFarRange or 120) end
    safeSet(infinitePostureToggle, data.InfinitePosture)
    safeSet(infiniteJumpsToggle, data.InfiniteJumps)
    if fastRunKeyDropdown then safeSet(fastRunKeyDropdown, data.FastRunKey or "E") end
    safeSet(fastRunAlwaysOnToggle, data.FastRunAlwaysOn)
    safeSet(fastRunToggle, data.FastRun)
    safeSet(instantAttackToggle, data.InstantAttack)
    safeSet(noKnockbackToggle, data.NoKnockback)
    safeSet(stopStunAnimsToggle, data.StopStunAnims)
    safeSet(noKnockbackMeleeToggle, data.NoKnockbackMelee)
    safeSet(soundSkillNoSlowToggle, data.SoundSkillNoSlow)
    safeSet(soundLoudActAutoAimToggle, data.SoundLoudActAutoAim)
    safeSet(soundSkillRealRangeToggle, data.SoundSkillRealRange)
    if loudActVFXScaleSlider then safeSet(loudActVFXScaleSlider, data.LoudActVFXScale or 1) end
    if musicalScoreVFXScaleSlider then safeSet(musicalScoreVFXScaleSlider, data.MusicalScoreVFXScale or 1) end
    if performanceVFXScaleSlider then safeSet(performanceVFXScaleSlider, data.PerformanceVFXScale or 1) end
    if resoundingVFXScaleSlider then safeSet(resoundingVFXScaleSlider, data.ResoundingVFXScale or 1) end
    safeSet(fastFlyingSickleToggle, data.FastFlyingSickle)
    safeSet(multiCastMovesToggle, data.MultiCastMoves)
    safeSet(autoQEWinToggle, data.AutoQEWin)
    if movesetDropdown then safeSet(movesetDropdown, data.Moveset or "Default") end
    if showDisplayNickToggle then safeSet(showDisplayNickToggle, data.ShowDisplayNick or false) end
    if showRealNickToggle then safeSet(showRealNickToggle, data.ShowRealNick or true) end
    if data.AutoBlockReleaseTime then
        AUTO_BLOCK_RELEASE_TIME = data.AutoBlockReleaseTime
        if AutoBlockSettingsBox and AutoBlockSettingsBox.Flags and AutoBlockSettingsBox.Flags.AutoBlockReleaseTimeSlider then
            safeSet(AutoBlockSettingsBox.Flags.AutoBlockReleaseTimeSlider, data.AutoBlockReleaseTime)
        end
    end
    if data.AutoBlockIgnoreTime then
        AUTO_BLOCK_IGNORE_TIME = data.AutoBlockIgnoreTime
        if AutoBlockSettingsBox and AutoBlockSettingsBox.Flags and AutoBlockSettingsBox.Flags.AutoBlockIgnoreTimeSlider then
            safeSet(AutoBlockSettingsBox.Flags.AutoBlockIgnoreTimeSlider, data.AutoBlockIgnoreTime)
        end
    end
    if data.StrictDangerousAnimBlock ~= nil then
        strictDangerousAnimBlockEnabled = data.StrictDangerousAnimBlock
        if AutoBlockSettingsBox and AutoBlockSettingsBox.Flags and AutoBlockSettingsBox.Flags.StrictDangerousAnimBlockToggle then
            safeSet(AutoBlockSettingsBox.Flags.StrictDangerousAnimBlockToggle, data.StrictDangerousAnimBlock)
        end
    end
    if data.SelectedDangerousAnims and dangerousAnimsDropdown then
        if #data.SelectedDangerousAnims > 0 then
            selectedDangerousAnims = data.SelectedDangerousAnims
            dangerousAnimsDropdown.Values = allDangerousAnims
            dangerousAnimsDropdown:SetValues(selectedDangerousAnims)
            if dangerousAnimsDropdown.Callback then
                dangerousAnimsDropdown.Callback(selectedDangerousAnims)
            end
        else
            selectedDangerousAnims = allDangerousAnims
            dangerousAnimsDropdown.Values = allDangerousAnims
            dangerousAnimsDropdown:SetValues(allDangerousAnims)
            if dangerousAnimsDropdown.Callback then
                dangerousAnimsDropdown.Callback(allDangerousAnims)
            end
        end
    elseif dangerousAnimsDropdown then
        selectedDangerousAnims = allDangerousAnims
        dangerousAnimsDropdown.Values = allDangerousAnims
        dangerousAnimsDropdown:SetValues(allDangerousAnims)
        if dangerousAnimsDropdown.Callback then
            dangerousAnimsDropdown.Callback(allDangerousAnims)
        end
    end
    if data.CustomKillSoundEnabled ~= nil then customKillSoundEnabled = data.CustomKillSoundEnabled end
    if data.CustomKillSoundAssetId then customKillSoundAssetId = data.CustomKillSoundAssetId end
    if data.CustomKillSoundVolume then customKillSoundVolume = data.CustomKillSoundVolume end
    if data.CustomKillSoundDuration then customKillSoundDuration = data.CustomKillSoundDuration end
    if data.CustomKillSoundTrim then customKillSoundTrim = data.CustomKillSoundTrim end
    if data.CustomKillSoundRadius then customKillSoundRadius = data.CustomKillSoundRadius end
    if data.CustomHitSoundEnabled ~= nil then customHitSoundEnabled = data.CustomHitSoundEnabled end
    if data.CustomHitSoundAssetId then customHitSoundAssetId = data.CustomHitSoundAssetId end
    if data.CustomHitSoundVolume then customHitSoundVolume = data.CustomHitSoundVolume end
    if data.CustomHitSoundDuration then customHitSoundDuration = data.CustomHitSoundDuration end
    if data.CustomHitSoundTrim then customHitSoundTrim = data.CustomHitSoundTrim end
    if CustomBox and CustomBox.Flags then
        if CustomBox.Flags.CustomKillSoundToggle then CustomBox.Flags.CustomKillSoundToggle:Set(customKillSoundEnabled) end
        if CustomBox.Flags.CustomKillSoundAssetId then CustomBox.Flags.CustomKillSoundAssetId:Set(customKillSoundAssetId) end
        if CustomBox.Flags.CustomKillSoundVolume then CustomBox.Flags.CustomKillSoundVolume:Set(customKillSoundVolume) end
        if CustomBox.Flags.CustomKillSoundDuration then CustomBox.Flags.CustomKillSoundDuration:Set(customKillSoundDuration) end
        if CustomBox.Flags.CustomKillSoundTrim then CustomBox.Flags.CustomKillSoundTrim:Set(customKillSoundTrim) end
        if CustomBox.Flags.CustomKillSoundRadius then CustomBox.Flags.CustomKillSoundRadius:Set(customKillSoundRadius) end
        if CustomBox.Flags.CustomHitSoundToggle then CustomBox.Flags.CustomHitSoundToggle:Set(customHitSoundEnabled) end
        if CustomBox.Flags.CustomHitSoundAssetId then CustomBox.Flags.CustomHitSoundAssetId:Set(customHitSoundAssetId) end
        if CustomBox.Flags.CustomHitSoundVolume then CustomBox.Flags.CustomHitSoundVolume:Set(customHitSoundVolume) end
        if CustomBox.Flags.CustomHitSoundDuration then CustomBox.Flags.CustomHitSoundDuration:Set(customHitSoundDuration) end
        if CustomBox.Flags.CustomHitSoundTrim then CustomBox.Flags.CustomHitSoundTrim:Set(customHitSoundTrim) end
    end
    print("[Config] Loaded config value for AttackSpeed:", data.AttackSpeed)
    print("[Config] Loaded config value for PunchStunSpeed:", data.PunchStunSpeed)

    -- После загрузки конфига повторно применяем все патчи и состояния
    if type(reapplyAllPatches) == "function" then
        reapplyAllPatches()
    end

    if data.AutoBlockIgnoreTime then
        _G.AUTO_BLOCK_IGNORE_TIME = data.AutoBlockIgnoreTime
        if AutoBlockSettingsBox and AutoBlockSettingsBox.Flags and AutoBlockSettingsBox.Flags.AutoBlockIgnoreTimeSlider then
            if type(safeSet) == "function" then
                safeSet(AutoBlockSettingsBox.Flags.AutoBlockIgnoreTimeSlider, data.AutoBlockIgnoreTime)
            end
        end
    end

    Library:Notify("Config loaded: "..name)
    isLoadingConfig = false
end

ConfigBox:AddInput("ConfigName", {
    Text = "Config Name",
    Default = "Default",
    Placeholder = "Enter config name...",
    Callback = function(val) currentConfig = val end
})
configDropdown = ConfigBox:AddDropdown("ConfigList", {
    Text = "Saved Configs",
    Values = getConfigs(),
    Default = 1,
    Callback = function(val) currentConfig = val end
})
ConfigBox:AddButton({
    Text = "Save Config",
    Func = function() saveConfig(currentConfig) end
})
ConfigBox:AddButton({
    Text = "Load Config",
    Func = function() loadConfig(currentConfig) end
})
ConfigBox:AddButton({
    Text = "Delete Config",
    Func = function()
        local path = configFolder.."/"..currentConfig..configExt
        if isfile(path) then delfile(path) if configDropdown and configDropdown.SetValues then configDropdown:SetValues(getConfigs()) end Library:Notify({Title = "Config", Content = "Удалено: "..currentConfig, Duration = 2}) end
    end
})
ConfigBox:AddButton({
    Text = "Refresh list",
    Func = function()
        if configDropdown and configDropdown.SetValues then
            configDropdown:SetValues(getConfigs())
            Library:Notify({Title = "Config", Content = "Список конфигов обновлён", Duration = 2})
        end
    end
})

-- Автоматическое восстановление ESP для всех игроков (раз в 0.1 сек)
spawn(function()
    while true do
        if NametagsEnabled then
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    local head = player.Character:FindFirstChild("Head")
                    if head then
                        if not head:FindFirstChild("Nametag") then
                            CreateNametag(player)
                        end
                    end
                    local hasHighlight = false
                    for _, v in ipairs(player.Character:GetChildren()) do
                        if v:IsA("Highlight") then
                            hasHighlight = true
                            break
                        end
                    end
                    if not hasHighlight then
                        ApplyHighlight(player)
                    end
                end
            end
        end
        task.wait(0.1)
    end
end)

showDisplayNickToggle = ESPBox:AddToggle("ShowDisplayNickToggle", {
    Text = "Show Display Nick",
    Default = true,
    Tooltip = "Show player's display name (custom nickname)",
    Callback = function(state)
        ShowDisplayNick = state
        if state then ShowRealNick = false end
        UpdateAllNametags()
    end
})

showRealNickToggle = ESPBox:AddToggle("ShowRealNickToggle", {
    Text = "Show Real Nick",
    Default = false,
    Tooltip = "Show player's real username (registration name)",
    Callback = function(state)
        ShowRealNick = state
        if state then ShowDisplayNick = false end
        UpdateAllNametags()
    end
})

local autoBlockEnabled = false
local autoBlockRadius = 15
local autoBlockConn = nil

local ignoreAnimNames = {
    Running = true, Walking = true, FallDefault = true, FallKatana = true, FlungAir = true, Jump = true, JumpFar = true,
    Idle = true, IdleKatana = true, Blocking = true, DashAnims = true, BlockBreak = true
}
local mustBlockNames = { ["M1-1"] = true, ["M1-2"] = true, ["M1-3"] = true, ["M1-4"] = true, ["M2"] = true }

function isDangerousAnimation(animName)
    local lower = animName:lower()
    for ignore, _ in pairs(ignoreAnimNames) do
        if lower:find(ignore:lower()) then return false end
    end
    for must, _ in pairs(mustBlockNames) do
        if lower == must:lower() then return true end
    end
    return true
end

local Remotes = ReplicatedStorage:FindFirstChild("Remotes")
local BlockRemote = Remotes and Remotes:FindFirstChild("Block")

local lastAttackTime = 0
local ignoreAttackUntil = 0

-- Обработчик нажатий для авто-блока
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1
        or input.KeyCode == Enum.KeyCode.One
        or input.KeyCode == Enum.KeyCode.Two
        or input.KeyCode == Enum.KeyCode.Three
        or input.KeyCode == Enum.KeyCode.Four
        or input.KeyCode == Enum.KeyCode.R then
        local now = tick()
        if now > ignoreAttackUntil then
            lastAttackTime = now
            ignoreAttackUntil = now + _G.AUTO_BLOCK_IGNORE_TIME
        end
    end
end)

local dangerousAnims = {
    -- Akaza
    Parry = true, Destruct = true, Disorder = true,
    -- Gyutaro
    RampantArc = true, SickleThrow = true,
    -- Rengoku
    FlameBarrage = true, FlameBarrageFinisher = true, RisingSun = true,
    -- Tanjiro (SunDance)
    FlowingDance = true, FlowingDanceNew = true, ShiningSun = true, WaterSurfaceSlash = true, WaterWheel = true,
    -- Tengen (MusicalScoreEnd)
    LoudAct = true, MusicalScore = true, Performance = true, Resounding = true,
    -- Zenitsu
    EightFoldLand = true, EightFoldWindUp = true, FallAsleep = true, SixFoldBlocked = true, SixFoldEnd = true,
    SixFoldRush = true, SixFoldWindUp = true, ThunderClapEnd = true, ThunderClapStartup = true
}

local lastAttacking = 0
local attackingListener = nil

-- === AutoBlock: универсальная поддержка для телефона (любое касание) ===
local autoBlockTouchConn = nil
local autoBlockButtonConns = {}
local function connectAllMobileBlockHandlers()
    -- Отключаем старые
    if autoBlockTouchConn then safeDisconnect(autoBlockTouchConn) autoBlockTouchConn = nil end
    for _, conn in pairs(autoBlockButtonConns) do safeDisconnect(conn) end
    autoBlockButtonConns = {}
    -- Любое касание экрана
    autoBlockTouchConn = UserInputService.TouchStarted:Connect(function()
        lastAttackTime = tick()
        ignoreAttackUntil = tick() + _G.AUTO_BLOCK_IGNORE_TIME
    end)
    -- Все кнопки в PlayerGui
    local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
    if playerGui then
        for _, btn in ipairs(playerGui:GetDescendants()) do
            if btn:IsA("TextButton") or btn:IsA("ImageButton") then
                local conn = btn.MouseButton1Down:Connect(function()
                    lastAttackTime = tick()
                    ignoreAttackUntil = tick() + _G.AUTO_BLOCK_IGNORE_TIME
                end)
                table.insert(autoBlockButtonConns, conn)
            end
        end
        -- Новые кнопки
        table.insert(autoBlockButtonConns, playerGui.DescendantAdded:Connect(function(obj)
            if obj:IsA("TextButton") or obj:IsA("ImageButton") then
                local conn = obj.MouseButton1Down:Connect(function()
                    lastAttackTime = tick()
                    ignoreAttackUntil = tick() + _G.AUTO_BLOCK_IGNORE_TIME
                end)
                table.insert(autoBlockButtonConns, conn)
            end
        end))
    end
end

autoBlockToggle = MainLeft:AddToggle("AutoBlockToggle", {
    Text = "Auto Block [REQUIRES NO SLOW]",
    Default = false,
    Tooltip = "REQUIRES NO SLOW AND STRICT DANGEROUS ANIMS BLOCK",
    Callback = function(state)
        if isLoadingConfig then return end
        -- === ДОБАВЛЕНО: всегда обновлять dangerousAnims и тайминги из UI ===
        if state then
            _G.AutoBlockAnimFlags = _G.AutoBlockAnimFlags or {}
            for _, anim in ipairs(allDangerousAnims) do
                _G.AutoBlockAnimFlags[anim] = table.find(selectedDangerousAnims, anim) ~= nil
            end
            -- Обновить тайминги
            if AutoBlockSettingsBox and AutoBlockSettingsBox.Flags then
                if AutoBlockSettingsBox.Flags.AutoBlockReleaseTimeSlider then
                    _G.AUTO_BLOCK_RELEASE_TIME = AutoBlockSettingsBox.Flags.AutoBlockReleaseTimeSlider.Value
                end
                if AutoBlockSettingsBox.Flags.AutoBlockIgnoreTimeSlider then
                    _G.AUTO_BLOCK_IGNORE_TIME = AutoBlockSettingsBox.Flags.AutoBlockIgnoreTimeSlider.Value
                end
            end
        end
        -- === СТАРАЯ ЛОГИКА ===
        autoBlockEnabled = state
        if autoBlockConn then safeDisconnect(autoBlockConn) autoBlockConn = nil end
        if attackingListener then safeDisconnect(attackingListener) attackingListener = nil end
        -- Отключаем мобильные обработчики при выключении
        if not state then
            if autoBlockTouchConn then safeDisconnect(autoBlockTouchConn) autoBlockTouchConn = nil end
            for _, conn in pairs(autoBlockButtonConns) do safeDisconnect(conn) end
            autoBlockButtonConns = {}
        end
        local myData = CharacterDataModule.GetData()
        if state then
            connectAllMobileBlockHandlers()
            attackingListener = CharacterDataModule.ListenTo("Attacking"):Connect(function(val)
                if val > 0 then
                    lastAttackTime = tick()
                    ignoreAttackUntil = tick() + _G.AUTO_BLOCK_IGNORE_TIME
                end
            end)
            autoBlockConn = task.spawn(function()
                while autoBlockEnabled do
                    local now = tick()
                    local shouldBlock
                    if strictDangerousAnimBlockEnabled then
                        -- Строгий режим: реагируем на опасные анимации в радиусе
                        local danger = false
                        local myChar = LocalPlayer.Character
                        if myChar and myChar:FindFirstChild("HumanoidRootPart") then
                            local myPos = myChar.HumanoidRootPart.Position
                            for _, player in ipairs(Players:GetPlayers()) do
                                if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                    local dist = (player.Character.HumanoidRootPart.Position - myPos).Magnitude
                                    if dist <= autoBlockRadius then
                                        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                                        if humanoid and humanoid.Animator then
                                            for _, track in ipairs(humanoid.Animator:GetPlayingAnimationTracks()) do
                                                local animName = track.Name
                                                if animName == "M1-1" or animName == "M1-2" or animName == "M1-3" or animName == "M1-4" or animName == "M2" or dangerousAnims[animName] then
                                                    danger = true
                                                    break
                                                end
                                            end
                                        end
                                    end
                                end
                                if danger then break end
                            end
                        end
                        if danger then
                            shouldBlock = true
                            lastAttackTime = 0
                            ignoreAttackUntil = 0
                        else
                            if now < lastAttackTime + _G.AUTO_BLOCK_RELEASE_TIME then
                                shouldBlock = false
                            elseif now < ignoreAttackUntil then
                                shouldBlock = true
                            else
                                shouldBlock = true
                            end
                        end
                    else
                        -- Обычный режим: только release/ignore time, но с учётом M1-M4 по AnimationId
                        if now < lastAttackTime + _G.AUTO_BLOCK_RELEASE_TIME then
                            if myM1M4Playing then
                                shouldBlock = false
                            else
                                shouldBlock = true
                            end
                        elseif now < ignoreAttackUntil then
                            shouldBlock = true
                        else
                            shouldBlock = true
                        end
                    end
                    if myData then
                        myData.Blocking = shouldBlock
                    end
                    if BlockRemote then
                        BlockRemote:FireServer(shouldBlock)
                    end
                    task.wait(0.05)
                end
            end)
        else
            if myData then
                myData.Blocking = false
            end
            if BlockRemote then
                BlockRemote:FireServer(false)
            end
        end
    end
})

local myM1M4Playing = false
local myAnimator = nil
local myM1M4Ids = {}

local function updateM1M4Ids()
    myM1M4Ids = {}
    local char = LocalPlayer.Character
    if not char then return end
    local moveset = char:GetAttribute("Moveset") or "Default"
    local movesetModule = ReplicatedStorage.Knit.Modules.Movesets:FindFirstChild(moveset)
    if not movesetModule then return end
    local anims = movesetModule:FindFirstChild("Anims")
    if not anims then return end
    local m1s = anims:FindFirstChild("M1s")
    if not m1s then return end
    for i = 1, 4 do
        local anim = m1s:FindFirstChild("M1-"..i)
        if anim and anim:IsA("Animation") then
            table.insert(myM1M4Ids, anim.AnimationId)
        end
    end
end

local function setupMyAnimatorListener()
    local char = LocalPlayer.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    myAnimator = hum:FindFirstChildOfClass("Animator")
    if not myAnimator then return end
    updateM1M4Ids()
    myM1M4Playing = false
    myAnimator.AnimationPlayed:Connect(function(track)
        if track.Animation and table.find(myM1M4Ids, track.Animation.AnimationId) then
            myM1M4Playing = true
            track.Stopped:Connect(function()
                myM1M4Playing = false
            end)
        end
    end)
    for _, track in ipairs(myAnimator:GetPlayingAnimationTracks()) do
        if track.Animation and table.find(myM1M4Ids, track.Animation.AnimationId) then
            myM1M4Playing = true
            track.Stopped:Connect(function()
                myM1M4Playing = false
            end)
        end
    end
end

LocalPlayer.CharacterAdded:Connect(function()
    setupMyAnimatorListener()
end)
setupMyAnimatorListener()

-- === Infinite Posture (новая логика: анти-пробитие блока) ===
if infinitePostureConn then safeDisconnect(infinitePostureConn) infinitePostureConn = nil end
infinitePostureConn = game:GetService("RunService").RenderStepped:Connect(function()
    local char = LocalPlayer.Character
    if not char then return end
    local data = require(game:GetService("ReplicatedStorage").Knit.Modules.Data.CharacterData).GetData(char)
    if data then
        -- 1. Мгновенно восстанавливаем Posture, если оно упало
        if data.Posture and data.Posture < 100 then
            data.Posture = 100
            char:SetAttribute("Posture", 100)
        end
        -- 2. Снимаем статус BlockBreak/BlockStun, если он появился
        if (char:GetAttribute("BlockBreak") and char:GetAttribute("BlockBreak") > 0) or (char:GetAttribute("Stun") and char:GetAttribute("Stun") > 0) then
            char:SetAttribute("BlockBreak", 0)
            char:SetAttribute("Stun", 0)
        end
        -- 3. Останавливаем анимации BlockBreak/BlockFlinch
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then
            for _, track in ipairs(hum.Animator:GetPlayingAnimationTracks()) do
                if track.Name:find("BlockBreak") or track.Name:find("BlockFlinch") then
                    track:Stop(0)
                end
            end
        end
    end
end)

-- === AutoBlock: поддержка мобильной кнопки Attack ===
local function setupMobileAttackListener()
    local playerGui = LocalPlayer:FindFirstChild("PlayerGui")
    if not playerGui then return end
    local mobileHUD = playerGui:FindFirstChild("MobileHUD")
    if not mobileHUD then return end
    local controls = mobileHUD:FindFirstChild("Controls")
    if not controls then return end
    local attackBtn = controls:FindFirstChild("Attack")
    if not attackBtn then return end
    -- Удаляем старый обработчик, если был
    if attackBtn._autoBlockConn then
        attackBtn._autoBlockConn:Disconnect()
        attackBtn._autoBlockConn = nil
    end
    -- Вешаем новый обработчик
    attackBtn._autoBlockConn = attackBtn.MouseButton1Down:Connect(function()
        lastAttackTime = tick()
        ignoreAttackUntil = tick() + _G.AUTO_BLOCK_IGNORE_TIME
    end)
end

if UserInputService.TouchEnabled then
    setupMobileAttackListener()
    LocalPlayer.PlayerGui.ChildAdded:Connect(function(child)
        if child.Name == "MobileHUD" then
            task.wait(0.2)
            setupMobileAttackListener()
        end
    end)
end

-- Хук на RemoteEvent CharacterData.Network для фиксации атаки
local CharacterDataNetwork = ReplicatedStorage.Knit.Modules.Data.CharacterData:FindFirstChild("Network")
if CharacterDataNetwork and CharacterDataNetwork:IsA("RemoteEvent") then
    CharacterDataNetwork.OnClientEvent:Connect(function(...)
        local args = {...}
        for i, v in ipairs(args) do
            if tostring(v) == "Attacking" and tonumber(args[i+1]) and tonumber(args[i+1]) >= 1 then
                playCustomHitSound()
            end
            if (tostring(v) == "Attacking" and args[i+1] == 1)
                or (tostring(v) == "AttackLoop" and args[i+1] == true)
                or (tostring(v) == "LastAttack") then
                lastAttackTime = tick()
                ignoreAttackUntil = tick() + _G.AUTO_BLOCK_IGNORE_TIME
            end
        end
    end)
end

local dangerousAttackers = {}

-- Обновлять список опасных игроков каждую секунду
spawn(function()
    while true do
        dangerousAttackers = {}
        for _, char in ipairs(workspace.Characters:GetChildren()) do
            local attackedBy = char:FindFirstChild("AttackedBy")
            if attackedBy and attackedBy.Value == LocalPlayer.Name then
                table.insert(dangerousAttackers, char)
            end
        end
        wait(1)
    end
end)

-- Проверка строгого блока
local function shouldStrictBlock()
    if not strictDangerousAnimBlockEnabled then return false end
    local myChar = LocalPlayer.Character
    if not myChar then return false end
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return false end
    for _, char in ipairs(dangerousAttackers) do
        local root = char:FindFirstChild("HumanoidRootPart")
        if root and (root.Position - myRoot.Position).Magnitude <= 10 then
            local hum = char:FindFirstChildOfClass("Humanoid")
            local animator = hum and hum:FindFirstChildOfClass("Animator")
            if animator then
                for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                    if dangerousAnims[track.Name] then
                        return true -- Включить строгий блок
                    end
                end
            end
        end
    end
    return false
end

-- === Custom Tab ===
local CustomTab = Window:AddTab("Custom")
local CustomBox = CustomTab:AddLeftGroupbox("Custom Features")
local customKillSoundEnabled = false
local customKillSoundAssetId = ""

-- Отслеживание смертей других игроков, которых ты бил
spawn(function()
    while true do
        if customKillSoundEnabled and customKillSoundAssetId ~= "" then
            for _, char in ipairs(workspace.Characters:GetChildren()) do
                if char ~= LocalPlayer.Character then
                    local attackedBy = char:FindFirstChild("AttackedBy")
                    if attackedBy and attackedBy.Value == LocalPlayer.Name then
                        -- Проверяем, не умер ли игрок (Parent == nil или Humanoid.Health == 0)
                        local hum = char:FindFirstChildOfClass("Humanoid")
                        if hum and hum.Health == 0 and not char:FindFirstChild("_CustomKillSoundPlayed") then
                            -- Помечаем, чтобы не проигрывать повторно
                            local flag = Instance.new("BoolValue")
                            flag.Name = "_CustomKillSoundPlayed"
                            flag.Parent = char
                            -- Проигрываем звук
                            local sound = Instance.new("Sound")
                            sound.SoundId = "rbxassetid://" .. tostring(customKillSoundAssetId)
                            sound.Volume = 1
                            sound.Parent = workspace
                            sound:Play()
                            game:GetService("Debris"):AddItem(sound, 5)
                        end
                    end
                end
            end
        end
        wait(0.5)
    end
end)

-- === Custom Kill Sound (по радиусу, без AttackedBy) ===
local customKillSoundEnabled = false
local customKillSoundAssetId = ""
local customKillSoundVolume = 1
local customKillSoundDuration = 3
local customKillSoundTrim = 0
local customKillSoundRadius = 50

CustomBox:AddToggle("CustomKillSoundToggle", {
    Text = "Custom Kill Sound",
    Default = false,
    Tooltip = "Play a custom sound when any player dies near you (radius 50)",
    Callback = function(state)
        customKillSoundEnabled = state
    end
})
CustomBox:AddInput("CustomKillSoundAssetId", {
    Text = "Kill Sound AssetId",
    Default = "",
    Tooltip = "Roblox AssetId for kill sound (e.g. 1234567890)",
    Callback = function(val)
        customKillSoundAssetId = val
    end
})
CustomBox:AddSlider("CustomKillSoundVolume", {
    Text = "Kill Sound Volume",
    Min = 0, Max = 2, Default = 1, Rounding = 2,
    Callback = function(val) customKillSoundVolume = val end
})
CustomBox:AddSlider("CustomKillSoundDuration", {
    Text = "Kill Sound Duration (sec)",
    Min = 1, Max = 20, Default = 3, Rounding = 0,
    Callback = function(val) customKillSoundDuration = val end
})
CustomBox:AddSlider("CustomKillSoundTrim", {
    Text = "Kill Sound Trim Start (sec)",
    Min = 0, Max = 2, Default = 0, Rounding = 1,
    Callback = function(val) customKillSoundTrim = val end
})
CustomBox:AddSlider("CustomKillSoundRadius", {
    Text = "Kill Sound Radius",
    Min = 10, Max = 200, Default = 50, Rounding = 0,
    Callback = function(val) customKillSoundRadius = val end
})

local function playCustomKillSound()
    if not customKillSoundEnabled or not customKillSoundAssetId or customKillSoundAssetId == "" then return end
    local sound = Instance.new("Sound")
    sound.SoundId = "rbxassetid://"..tostring(customKillSoundAssetId)
    sound.Volume = customKillSoundVolume or 1
    sound.TimePosition = customKillSoundTrim or 0
    sound.Parent = workspace
    sound:Play()
    task.delay(customKillSoundDuration or 3, function()
        if sound then
            sound:Stop()
            sound:Destroy()
        end
    end)
end

-- Подписываемся на смерть для всех игроков, кроме LocalPlayer
local function hookKillSoundForChar(char)
    if not char or char == LocalPlayer.Character then return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if hum and not char:FindFirstChild("_CustomKillSoundHooked") then
        local flag = Instance.new("BoolValue")
        flag.Name = "_CustomKillSoundHooked"
        flag.Parent = char
        hum.Died:Connect(function()
            local myChar = LocalPlayer.Character
            local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
            local theirRoot = char:FindFirstChild("HumanoidRootPart")
            if myRoot and theirRoot then
                local dist = (myRoot.Position - theirRoot.Position).Magnitude
                if dist <= (customKillSoundRadius or 50) then
                    playCustomKillSound()
                end
            end
        end)
    end
end

for _,plr in ipairs(Players:GetPlayers()) do
    if plr ~= LocalPlayer then
        if plr.Character then hookKillSoundForChar(plr.Character) end
        plr.CharacterAdded:Connect(hookKillSoundForChar)
    end
end
Players.PlayerAdded:Connect(function(plr)
    if plr ~= LocalPlayer then
        plr.CharacterAdded:Connect(hookKillSoundForChar)
    end
end)

for _,plr in ipairs(Players:GetPlayers()) do
    if plr ~= LocalPlayer then
        local function hookSwing1Sound(char)
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if hrp then
                hrp.ChildAdded:Connect(function(obj)
                    if obj:IsA("Sound") and obj.Name == "Swing1" then
                        local myChar = LocalPlayer.Character
                        local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
                        if myRoot and (myRoot.Position - hrp.Position).Magnitude <= 20 then
                            if customHitSoundEnabled and customHitSoundAssetId ~= "" then
                                local sound = Instance.new("Sound")
                                sound.SoundId = "rbxassetid://"..tostring(customHitSoundAssetId)
                                sound.Volume = customHitSoundVolume or 1
                                sound.TimePosition = customHitSoundTrim or 0
                                sound.Parent = hrp
                                sound:Play()
                                task.delay(customHitSoundDuration or 1.5, function()
                                    if sound then pcall(function() sound:Destroy() end) end
                                end)
                            end
                        end
                    end
                end)
            end
        end
        if plr.Character then hookSwing1Sound(plr.Character) end
        plr.CharacterAdded:Connect(hookSwing1Sound)
    end
end
Players.PlayerAdded:Connect(function(plr)
    if plr ~= LocalPlayer then
        plr.CharacterAdded:Connect(hookSwing1Sound)
    end
end)

local function safeDisconnect(conn)
    if typeof(conn) == 'RBXScriptConnection' then
        conn:Disconnect()
    end
end


-- === Auto Parry ===
local autoParryEnabled = false
local autoParryRadius = 30
local autoParryConn = nil
local lastAutoParry = 0
local autoParryCooldown = 0.5

-- === Always Selse ===
local alwaysSelseEnabled = false
local selseConn = nil
local selseEffects = {}

-- Функция для создания настоящего эффекта selse (скопировано из GlobalMoveset)
local function createSelseEffect()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local TweenService = game:GetService("TweenService")
    local Debris = game:GetService("Debris")
    
    -- Создаем ColorCorrectionEffect
    local colorCorrection = Instance.new("ColorCorrectionEffect")
    colorCorrection.Name = "Sense"
    colorCorrection.Parent = game.Lighting
    
    -- Создаем Atmosphere
    local atmosphere = Instance.new("Atmosphere")
    atmosphere.Name = "SenseAtmosphere"
    atmosphere.Parent = game.Lighting
    
    -- Создаем SenseHighlight (клонируем из Assets)
    local senseHighlight = ReplicatedStorage.Assets.SenseHighlight:Clone()
    senseHighlight.Parent = workspace.Characters
    
    -- Создаем Highlight для персонажа
    local highlight = Instance.new("Highlight")
    highlight.FillTransparency = 1
    highlight.OutlineTransparency = 1
    highlight.FillColor = Color3.fromRGB(255, 255, 255)
    highlight.Parent = LocalPlayer.Character
    
    -- Создаем звук
    local senseSound = ReplicatedStorage.Assets.Sounds.Sense:Clone()
    senseSound.Parent = workspace.CurrentCamera
    senseSound:Play()
    
    -- Анимации эффектов
    TweenService:Create(senseHighlight, TweenInfo.new(0.356, Enum.EasingStyle.Sine), {
        FillTransparency = 0,
        OutlineTransparency = 0.25
    }):Play()
    
    TweenService:Create(colorCorrection, TweenInfo.new(0.456, Enum.EasingStyle.Sine), {
        TintColor = Color3.fromRGB(98, 105, 168),
        Contrast = 0.1,
        Saturation = 0.4
    }):Play()
    
    TweenService:Create(atmosphere, TweenInfo.new(0.456, Enum.EasingStyle.Sine), {
        Density = 0.297
    }):Play()
    
    TweenService:Create(highlight, TweenInfo.new(0.356, Enum.EasingStyle.Sine), {
        FillTransparency = 0,
        OutlineTransparency = 0.25
    }):Play()
    
    -- Промежуточная анимация
    task.delay(0.456, function()
        TweenService:Create(senseHighlight, TweenInfo.new(0.31, Enum.EasingStyle.Sine), {
            FillTransparency = 0.35
        }):Play()
        TweenService:Create(highlight, TweenInfo.new(0.31, Enum.EasingStyle.Sine), {
            FillTransparency = 0.35
        }):Play()
    end)
    
    -- Убираем финальную анимацию исчезновения - эффект длится вечно
    -- task.delay(5.4, function()
    --     TweenService:Create(senseHighlight, TweenInfo.new(1.6, Enum.EasingStyle.Sine), {
    --         FillTransparency = 1,
    --         OutlineTransparency = 1
    --     }):Play()
    --     TweenService:Create(colorCorrection, TweenInfo.new(1.6, Enum.EasingStyle.Sine), {
    --         TintColor = Color3.fromRGB(255, 255, 255),
    --         Contrast = 0,
    --         Saturation = 0
    --     }):Play()
    --     TweenService:Create(atmosphere, TweenInfo.new(0.456, Enum.EasingStyle.Sine), {
    --         Density = 0.117
    --     }):Play()
    --     TweenService:Create(highlight, TweenInfo.new(1.6, Enum.EasingStyle.Sine), {
    --         FillTransparency = 1,
    --         OutlineTransparency = 1
    --     }):Play()
    -- end)
    
    -- Эффект длится вечно (не удаляем автоматически)
    -- Debris:AddItem(highlight, 7)
    -- Debris:AddItem(senseHighlight, 7)
    -- Debris:AddItem(atmosphere, 7)
    -- Debris:AddItem(colorCorrection, 7)
    -- Debris:AddItem(senseSound, 7)
    
    return {
        colorCorrection = colorCorrection,
        atmosphere = atmosphere,
        senseHighlight = senseHighlight,
        highlight = highlight,
        senseSound = senseSound
    }
end

-- Функция для удаления эффекта selse
local function removeSelseEffect(effects)
    if effects then
        if effects.colorCorrection then effects.colorCorrection:Destroy() end
        if effects.atmosphere then effects.atmosphere:Destroy() end
        if effects.senseHighlight then effects.senseHighlight:Destroy() end
        if effects.highlight then effects.highlight:Destroy() end
        if effects.senseSound then effects.senseSound:Destroy() end
    end
end

-- === Auto Parry Settings ===
local autoParryDirection = "Back" -- Back, Left, Right, Front, Behind
local autoParryDirections = {"Back", "Left", "Right", "Front", "Behind"}

MainLeft:AddDropdown("AutoParryDirectionDropdown", {
    Text = "Auto Parry Direction",
    Values = autoParryDirections,
    Default = "Back",
    Tooltip = "dash direction",
    Callback = function(val)
        autoParryDirection = val
    end
})

local function getDashVector(myRoot, enemyRoot, direction)
    if direction == "Back" then
        return -myRoot.CFrame.LookVector
    elseif direction == "Left" then
        return -myRoot.CFrame.RightVector
    elseif direction == "Right" then
        return myRoot.CFrame.RightVector
    elseif direction == "Front" then
        return myRoot.CFrame.LookVector
    elseif direction == "Behind" and enemyRoot then
        -- Dash за спину врага: вычисляем точку за спиной врага
        local behindPos = enemyRoot.Position - enemyRoot.CFrame.LookVector * 6
        local toBehind = (behindPos - myRoot.Position)
        return toBehind.Unit
    else
        return -myRoot.CFrame.LookVector
    end
end

local dashBaseSpeed = 110
local dashSpeedMultiplier = 1.7 -- только быстрее, не дальше
local dashDuration = 0.12 -- короче по времени
local dashAnimCount = 20 -- для behind

MainLeft:AddToggle("AlwaysSelseToggle", {
    Text = "Always Selse (highlight enemies)",
    Default = false,
    Tooltip = "Постоянно повторяет настоящий эффект selse для подсветки врагов.",
    Callback = function(state)
        alwaysSelseEnabled = state
        if selseConn then safeDisconnect(selseConn) selseConn = nil end
        if state then
            -- Создаем первый эффект сразу
            selseEffects.current = createSelseEffect()
            
            -- Повторяем эффект каждые 6 секунд (чуть меньше чем длительность эффекта)
            selseConn = game:GetService("RunService").Heartbeat:Connect(function()
                if not alwaysSelseEnabled then return end
                
                -- Проверяем, нужно ли создать новый эффект
                local currentEffects = selseEffects.current
                if not currentEffects or not currentEffects.colorCorrection or not currentEffects.colorCorrection.Parent then
                    -- Удаляем старые эффекты если есть
                    if currentEffects then
                        removeSelseEffect(currentEffects)
                    end
                    -- Создаем новый эффект
                    selseEffects.current = createSelseEffect()
                end
            end)
        else
            -- Отключаем все эффекты при выключении
            if selseEffects.current then
                removeSelseEffect(selseEffects.current)
                selseEffects.current = nil
            end
        end
    end
})

if autoParryConn then safeDisconnect(autoParryConn) autoParryConn = nil end
MainLeft:AddToggle("AutoParryToggle", {
    Text = "Auto Parry (dash on danger)",
    Default = false,
    Tooltip = "auto dash when dangerous skills",
    Callback = function(state)
        autoParryEnabled = state
        if autoParryConn then safeDisconnect(autoParryConn) autoParryConn = nil end
        if state then
            autoParryConn = game:GetService("RunService").Heartbeat:Connect(function()
                local Players = game:GetService("Players")
                local LocalPlayer = Players.LocalPlayer
                if not LocalPlayer or not LocalPlayer.Character then return end
                local char = LocalPlayer.Character
                local myRoot = char:FindFirstChild("HumanoidRootPart")
                if not myRoot then return end
                local hum = char:FindFirstChildOfClass("Humanoid")
                if not hum then return end
                local animator = hum:FindFirstChildOfClass("Animator")
                if not animator then return end
                if tick() - lastAutoParry < autoParryCooldown then return end
                
                local autoParryActive = false
                local autoParryStartTime = 0
                if autoParryActive and tick() - autoParryStartTime > 0.3 then
                    autoParryActive = false
                    -- Восстанавливаем блок если авто блок был включен
                    if autoBlockEnabled then
                        local myData = CharacterDataModule.GetData()
                        if myData then
                            myData.Blocking = true
                            if BlockRemote then
                                BlockRemote:FireServer(true)
                            end
                        end
                    end
                end
                
                for _, plr in ipairs(Players:GetPlayers()) do
                    if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                        local enemyRoot = plr.Character.HumanoidRootPart
                        if (enemyRoot.Position - myRoot.Position).Magnitude <= autoParryRadius then
                            local enemyHum = plr.Character:FindFirstChildOfClass("Humanoid")
                            if enemyHum and enemyHum.Animator then
                                for _, track in ipairs(enemyHum.Animator:GetPlayingAnimationTracks()) do
                                    if table.find(allDangerousAnims, track.Name) then
                                        local animKey = "AutoParry_"..plr.Name.."_"..track.Name
                                        if not enemyRoot:GetAttribute(animKey) then
                                            enemyRoot:SetAttribute(animKey, true)
                                            lastAutoParry = tick()
                                            
                                            -- === АВТО ПАРРИ: Активируем и снимаем блок ===
                                            autoParryActive = true
                                            autoParryStartTime = tick()
                                            
                                            -- Снимаем блок если он был включен
                                            local myData = CharacterDataModule.GetData()
                                            if myData and myData.Blocking then
                                                myData.Blocking = false
                                                if BlockRemote then
                                                    BlockRemote:FireServer(false)
                                                end
                                            end
                                            
                                            local dashVec = getDashVector(myRoot, enemyRoot, autoParryDirection)
                                            local hrp = char:FindFirstChild("HumanoidRootPart")
                                            if hrp then
                                                local oldBv = hrp:FindFirstChild("DashVelocity")
                                                if oldBv then oldBv:Destroy() end
                                                local dashAnimFolder = game:GetService("ReplicatedStorage").Knit.Modules.Movesets.Default.Anims.DashAnims
                                                local dashAnim = nil
                                                if autoParryDirection == "Back" then
                                                    dashAnim = dashAnimFolder:FindFirstChild("BackDash")
                                                elseif autoParryDirection == "Front" then
                                                    dashAnim = dashAnimFolder:FindFirstChild("FrontDash")
                                                elseif autoParryDirection == "Left" then
                                                    dashAnim = dashAnimFolder:FindFirstChild("LeftDash")
                                                elseif autoParryDirection == "Right" then
                                                    dashAnim = dashAnimFolder:FindFirstChild("RightDash")
                                                elseif autoParryDirection == "Behind" then
                                                    dashAnim = dashAnimFolder:FindFirstChild("RightDash")
                                                end
                                                if dashAnim then
                                                    local dashTrack = animator:LoadAnimation(dashAnim)
                                                    dashTrack:Play()
                                                    dashTrack:AdjustSpeed(2.2)
                                                end
                                                local bv = Instance.new("BodyVelocity")
                                                bv.Parent = hrp
                                                bv.Name = "DashVelocity"
                                                bv.MaxForce = Vector3.new(100000, 0, 100000)
                                                if autoParryDirection == "Behind" then
                                                    local right = myRoot.CFrame.RightVector
                                                    local forward = myRoot.CFrame.LookVector
                                                    local left = -myRoot.CFrame.RightVector
                                                    -- Правильно вычисляем позицию за спиной врага
                                                    local enemyLookVector = enemyRoot.CFrame.LookVector
                                                    local behindPos = enemyRoot.Position - enemyLookVector * 8
                                                    local toBehind = (behindPos - myRoot.Position)
                                                    local dashSpeed = dashBaseSpeed * dashSpeedMultiplier
                                                    local duration = dashDuration
                                                    local steps = dashAnimCount
                                                    local points = {}
                                                    for i = 1, steps do
                                                        local t = (i-1)/(steps-1)
                                                        local dir
                                                        if t < 0.33 then
                                                            dir = (right * (1 - t/0.33) + forward * (t/0.33)).Unit
                                                        elseif t < 0.66 then
                                                            local a = (t-0.33)/0.33
                                                            dir = (forward * (1 - a) + left * a).Unit
                                                        else
                                                            local a = (t-0.66)/0.34
                                                            dir = (left * (1 - a) + toBehind.Unit * a).Unit
                                                        end
                                                        table.insert(points, dir)
                                                    end
                                                    spawn(function()
                                                        for i, dir in ipairs(points) do
                                                            if not bv.Parent then break end
                                                            bv.Velocity = dir * dashSpeed
                                                            hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + dir)
                                                            game:GetService("RunService").Heartbeat:Wait()
                                                        end
                                                        if bv.Parent then
                                                            bv.Velocity = toBehind.Unit * dashSpeed
                                                            hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + toBehind.Unit)
                                                        end
                                                    end)
                                                else
                                                    bv.Velocity = dashVec.Unit * dashBaseSpeed * dashSpeedMultiplier
                                                    -- Только для Front и Behind меняем CFrame
                                                    if autoParryDirection == "Front" then
                                                        hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + dashVec.Unit)
                                                    end
                                                    -- Для Back/Left/Right не трогаем CFrame (смотрит вперед)
                                                end
                                                task.delay(dashDuration, function()
                                                    if bv and bv.Parent then
                                                        bv:Destroy()
                                                    end
                                                    if autoParryDirection == "Behind" then
                                                        local enemyLookVector = enemyRoot.CFrame.LookVector
                                                        local behindPos = enemyRoot.Position - enemyLookVector * 8
                                                        local dist = (hrp.Position - behindPos).Magnitude
                                                        if dist > 5 then
                                                            local pullBv = Instance.new("BodyVelocity")
                                                            pullBv.Parent = hrp
                                                            pullBv.Name = "DashVelocityPull"
                                                            pullBv.MaxForce = Vector3.new(100000, 0, 100000)
                                                            pullBv.Velocity = (behindPos - hrp.Position).Unit * dashBaseSpeed * 1.2
                                                            hrp.CFrame = CFrame.new(hrp.Position, behindPos)
                                                            task.delay(0.08, function()
                                                                if pullBv and pullBv.Parent then
                                                                    pullBv:Destroy()
                                                                end
                                                            end)
                                                        end
                                                        
                                                        -- Отслеживание врага после behind dash
                                                        local enemyStartPos = enemyRoot.Position
                                                        local trackingStartTime = tick()
                                                        local trackingDuration = 2 -- 2 секунды отслеживания
                                                        
                                                        spawn(function()
                                                            while tick() - trackingStartTime < trackingDuration do
                                                                if not enemyRoot or not enemyRoot.Parent then break end
                                                                local enemyCurrentPos = enemyRoot.Position
                                                                local enemyMovedDistance = (enemyCurrentPos - enemyStartPos).Magnitude
                                                                
                                                                if enemyMovedDistance >= 20 then
                                                                    -- Враг сдвинулся на 20+ единиц, делаем прямой dash к нему
                                                                    local directDashBv = Instance.new("BodyVelocity")
                                                                    directDashBv.Parent = hrp
                                                                    directDashBv.Name = "DashVelocityDirect"
                                                                    directDashBv.MaxForce = Vector3.new(100000, 0, 100000)
                                                                    local toEnemy = (enemyCurrentPos - hrp.Position).Unit
                                                                    directDashBv.Velocity = toEnemy * dashBaseSpeed * dashSpeedMultiplier
                                                                    hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + toEnemy)
                                                                    
                                                                    -- Проигрываем анимацию прямого dash
                                                                    local dashAnimFolder = game:GetService("ReplicatedStorage").Knit.Modules.Movesets.Default.Anims.DashAnims
                                                                    local frontDashAnim = dashAnimFolder:FindFirstChild("FrontDash")
                                                                    if frontDashAnim and animator then
                                                                        local directDashTrack = animator:LoadAnimation(frontDashAnim)
                                                                        directDashTrack:Play()
                                                                        directDashTrack:AdjustSpeed(2.2)
                                                                    end
                                                                    
                                                                    task.delay(0.15, function()
                                                                        if directDashBv and directDashBv.Parent then
                                                                            directDashBv:Destroy()
                                                                        end
                                                                    end)
                                                                    break -- Прекращаем отслеживание после dash
                                                                end
                                                                task.wait(0.1) -- Проверяем каждые 0.1 секунды
                                                            end
                                                        end)
                                                    end
                                                end)
                                            end
                                            task.delay(3, function()
                                                if enemyRoot then
                                                    enemyRoot:SetAttribute(animKey, nil)
                                                end
                                            end)
                                            return
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end)
        end
    end
})
