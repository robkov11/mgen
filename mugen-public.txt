-- Load Obsidian Library
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/deividcomsono/Obsidian/refs/heads/main/Library.lua"))()
print("invis hub mugen")
_G.task_delay_original = task.delay

-- Глобальные определения сервисов и модулей
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local MovesetHandler = require(ReplicatedStorage.Knit.Modules.MovesetHandler)
local CharacterDataModule = require(ReplicatedStorage.Knit.Modules.Data.CharacterData)
local CombatController = require(ReplicatedStorage.Knit.Controllers.CombatController)
local GlobalMoveset = require(ReplicatedStorage.Knit.Modules.GlobalMoveset)
local TagModule = require(ReplicatedStorage.Knit.Modules.TagModule)
local RaycastModule = require(ReplicatedStorage.Knit.Modules.Raycast)

-- Патч CanAttack (No Stun/No Slow)
MovesetHandler.CanAttack = function(...)
    return true
end

local originalKnockbackVelocity = nil -- Будет хранить оригинальную функцию для Anti-Knockback
local originalGetData = CharacterDataModule.GetData -- Для No Skill Cooldowns
local originalCanAttack = MovesetHandler.CanAttack -- Для Attack While Stunned
local originalRaycastCast = RaycastModule.Cast

-- Create window
local Window = Library:CreateWindow({
    Title = "Invis Hub",
    Footer = "by rivv. │ Mugen",
    Center = true,
    AutoShow = true,
    Font = Enum.Font.Gotham,
    CornerRadius = 8,
    DPIScale = 0.9,
    ToggleKeybind = Enum.KeyCode.RightControl,
})

local MainTab = Window:AddTab("Main", "shield")
local MainLeft = MainTab:AddLeftGroupbox("Main Functions")
local MainRight = MainTab:AddRightGroupbox("Speed Settings")
local BypassMainBox = MainTab:AddLeftGroupbox("Bypass & Utility")

-- No Stun Feature (обновлённая)
local noStunEnabled = false
local noStunConn

noStunToggle = MainLeft:AddToggle("NoStunToggle", {
    Text = "No Stun (anti ragdoll, anti hardstun, anti slow)",
    Default = false,
    Tooltip = "Removes stun (BETA, BETTER TO USE NO SLOW + NO KNOCKBACK)",
    Callback = function(state)
        noStunEnabled = state
        if noStunConn then
            noStunConn:Disconnect()
            noStunConn = nil
        end
        if state then
            local Players = game:GetService("Players")
            local LocalPlayer = Players.LocalPlayer
            local function removeStunAndRestoreSpeed()
                local char = LocalPlayer.Character
                if char then
                    local hum = char:FindFirstChildWhichIsA("Humanoid")
                    if hum then
                        -- Remove ragdoll/platformstand
                        hum.PlatformStand = false
                        hum.AutoRotate = true
                        -- Remove all stun states
                        for _, state in ipairs({
                            Enum.HumanoidStateType.FallingDown,
                            Enum.HumanoidStateType.Ragdoll,
                            Enum.HumanoidStateType.Physics,
                            Enum.HumanoidStateType.GettingUp,
                            Enum.HumanoidStateType.Seated,
                        }) do
                            hum:SetStateEnabled(state, false)
                        end
                        hum:ChangeState(Enum.HumanoidStateType.Running)
                        -- Восстановление скорости
                        if hum.WalkSpeed < 10 then hum.WalkSpeed = 10 end
                        if hum.JumpPower < 35 then hum.JumpPower = 35 end
                    end
                    -- Remove stun/slow attributes
                    if char:GetAttribute("HardStun") and char:GetAttribute("HardStun") > 0 then
                        char:SetAttribute("HardStun", 0)
                    end
                    if char:GetAttribute("Stun") and char:GetAttribute("Stun") > 0 then
                        char:SetAttribute("Stun", 0)
                    end
                    if char:GetAttribute("PunchStun") and char:GetAttribute("PunchStun") > 0 then
                        char:SetAttribute("PunchStun", 0)
                    end
                    if char:GetAttribute("Slow") then
                        char:SetAttribute("Slow", nil)
                    end
                end
            end
            -- Run every frame
            noStunConn = game:GetService("RunService").RenderStepped:Connect(removeStunAndRestoreSpeed)
            Library:Notify({
                Title = "No Stun",
                Content = "No Stun is now ENABLED.",
                Duration = 2
            })
        else
            Library:Notify({
                Title = "No Stun",
                Content = "No Stun is now DISABLED.",
                Duration = 2
            })
        end
    end
})

-- === Exploits Tab ===
local ExploitsTab = Window:AddTab("Exploits (BETA)", "bug")
local CombatExploitsBox = ExploitsTab:AddLeftGroupbox("Combat Exploits")
local StyleBox = ExploitsTab:AddLeftGroupbox("Gyutaro Exploits (MAY NOT WORK)") -- Re-add StyleBox if it was removed

-- Anti-Hitbox Feature
local antiHitboxEnabled = false
local antiHitboxConnection = nil -- New connection for continuous attribute setting
antiHitboxToggle = CombatExploitsBox:AddToggle("AntiHitboxToggle", {
    Text = "Anti-Hitbox",
    Default = false,
    Tooltip = "Constantly sets your character's 'Hitbox' attribute to 0.",
    Callback = function(state)
        antiHitboxEnabled = state
        if antiHitboxConnection then
            antiHitboxConnection:Disconnect()
            antiHitboxConnection = nil
        end
        if state then
            local function setHitboxAttribute()
                local char = LocalPlayer.Character
                if char then
                    char:SetAttribute("Hitbox", 0)
                end
            end
            antiHitboxConnection = RunService.RenderStepped:Connect(setHitboxAttribute)
            Library:Notify({
                Title = "Anti-Hitbox",
                Content = "Anti-Hitbox ENABLED.",
                Duration = 2
            })
        else
            Library:Notify({
                Title = "Anti-Hitbox",
                Content = "Anti-Hitbox DISABLED.",
                Duration = 2
            })
        end
    end
})

-- === Visual Tab ===
local VisualTab = Window:AddTab("Visual", "eye")
local ESPBox = VisualTab:AddLeftGroupbox("ESP Settings")
local UIBox = VisualTab:AddRightGroupbox("UI Settings")

-- ESP Variables
local MaxDistance = 400.5
local NametagsEnabled = false
local HighlightEnabled = false
local ShowDisplayNick = true
local ShowRealNick = false

-- No Smoke Feature
local noSmokeEnabled = false
local noSmokeConnection = nil

-- Function to create a nametag for a player
local function CreateNametag(Player)
    if Player == LocalPlayer then return end

    local function SetupNametag(Character)
        local Head = Character:FindFirstChild("Head")
        if not Head then return end

        local OldNametag = Head:FindFirstChild("Nametag")
        if OldNametag then
            OldNametag:Destroy()
        end

        local BillboardGui = Instance.new("BillboardGui")
        BillboardGui.Name = "Nametag"
        BillboardGui.Adornee = Head
        BillboardGui.Size = UDim2.new(0, 100, 0, 60)
        BillboardGui.StudsOffset = Vector3.new(0, 2, 0)
        BillboardGui.AlwaysOnTop = true

        local NameTextLabel = Instance.new("TextLabel")
        NameTextLabel.Name = "NameTextLabel"
        NameTextLabel.Size = UDim2.new(1, 0, 0.4, 0)
        NameTextLabel.Position = UDim2.new(0, 0, 0, 0)
        if ShowDisplayNick then
            NameTextLabel.Text = Player.DisplayName
        elseif ShowRealNick then
            NameTextLabel.Text = Player.Name
        else
            NameTextLabel.Text = ""
        end
        NameTextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        NameTextLabel.BackgroundTransparency = 1
        NameTextLabel.TextStrokeTransparency = 0.75
        NameTextLabel.Font = Enum.Font.Code
        NameTextLabel.TextScaled = true
        NameTextLabel.Parent = BillboardGui

        local MovesetTextLabel = Instance.new("TextLabel")
        MovesetTextLabel.Name = "MovesetTextLabel"
        MovesetTextLabel.Size = UDim2.new(1, 0, 0.4, 0)
        MovesetTextLabel.Position = UDim2.new(0, 0, 0.4, 0)
        MovesetTextLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
        MovesetTextLabel.BackgroundTransparency = 1
        MovesetTextLabel.TextStrokeTransparency = 0.75
        MovesetTextLabel.Font = Enum.Font.Code
        MovesetTextLabel.TextScaled = true
        MovesetTextLabel.Parent = BillboardGui

        local HealthBarBackground = Instance.new("Frame")
        HealthBarBackground.Name = "HealthBarBackground"
        HealthBarBackground.Size = UDim2.new(1, 0, 0, 10)
        HealthBarBackground.Position = UDim2.new(0, 0, 0.8, 0)
        HealthBarBackground.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        HealthBarBackground.BorderColor3 = Color3.fromRGB(0, 0, 0)
        HealthBarBackground.BorderSizePixel = 1
        HealthBarBackground.Parent = BillboardGui

        local HealthBarFill = Instance.new("Frame")
        HealthBarFill.Name = "HealthBarFill"
        HealthBarFill.Size = UDim2.new(1, 0, 1, 0)
        HealthBarFill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
        HealthBarFill.Parent = HealthBarBackground

        BillboardGui.Parent = Head
    end

    if Player.Character then
        SetupNametag(Player.Character)
    end
    Player.CharacterAdded:Connect(SetupNametag)
end

-- Централизованное обновление ESP (раз в 0.2 сек)
local function UpdateAllNametags()
    for _, Player in ipairs(Players:GetPlayers()) do
        if Player ~= LocalPlayer and Player.Character and Player.Character:FindFirstChild("Head") then
            local BillboardGui = Player.Character.Head:FindFirstChild("Nametag")
            if BillboardGui then
                local NameTextLabel = BillboardGui:FindFirstChild("NameTextLabel")
                local MovesetTextLabel = BillboardGui:FindFirstChild("MovesetTextLabel")
                local HealthBarBackground = BillboardGui:FindFirstChild("HealthBarBackground")
                local HealthBarFill = HealthBarBackground and HealthBarBackground:FindFirstChild("HealthBarFill")
                local hum = Player.Character:FindFirstChildOfClass("Humanoid")
                if NameTextLabel then
                    if ShowDisplayNick then
                        NameTextLabel.Text = Player.DisplayName
                    elseif ShowRealNick then
                        NameTextLabel.Text = Player.Name
                    else
                        NameTextLabel.Text = ""
                    end
                end
                if MovesetTextLabel then
                    local moveset = Player.Character:GetAttribute("Moveset")
                    MovesetTextLabel.Text = "Moveset: " .. (moveset or "N/A")
                end
                if hum and HealthBarFill then
                    local healthRatio = hum.Health / hum.MaxHealth
                    HealthBarFill.Size = UDim2.new(healthRatio, 0, 1, 0)
                    if healthRatio > 0.7 then
                        HealthBarFill.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
                    elseif healthRatio > 0.3 then
                        HealthBarFill.BackgroundColor3 = Color3.fromRGB(255, 255, 0)
                    else
                        HealthBarFill.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                    end
                end
                -- Дистанция и видимость
                if NametagsEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") then
                    local Distance = (Player.Character.Head.Position - LocalPlayer.Character.Head.Position).Magnitude
                    BillboardGui.Enabled = (Distance <= MaxDistance)
                else
                    BillboardGui.Enabled = false
                end
            end
        end
    end
end

-- Запускаем централизованный цикл обновления ESP
spawn(function()
    while true do
        UpdateAllNametags()
        task.wait(0.2)
    end
end)

-- Function to apply ESP/Highlight to a player
local function ApplyHighlight(Player)
    if Player == LocalPlayer then return end

    local function SetupHighlight(Character)
        for _, v in pairs(Character:GetChildren()) do
            if v:IsA("Highlight") then
                v:Destroy()
            end
        end

        local Highlighter = Instance.new("Highlight")
        Highlighter.Parent = Character

        local function UpdateFillColor()
            local DefaultColor = Color3.fromRGB(255, 48, 51)
            Highlighter.FillColor = Player.TeamColor and Player.TeamColor.Color or DefaultColor
        end

        UpdateFillColor()
        Player:GetPropertyChangedSignal("TeamColor"):Connect(UpdateFillColor)

        local Humanoid = Character:FindFirstChildOfClass("Humanoid")
        if Humanoid then
            Humanoid.Died:Connect(function()
                Highlighter:Destroy()
            end)
        end
    end

    if Player.Character then
        SetupHighlight(Player.Character)
    end
    Player.CharacterAdded:Connect(SetupHighlight)
end

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function(char)
            if NametagsEnabled then
                CreateNametag(player)
                ApplyHighlight(player)
            end
        end)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function(char)
            if NametagsEnabled then
                CreateNametag(player)
                ApplyHighlight(player)
            end
        end)
    end
end)

-- ESP Toggles
espPlayersToggle = ESPBox:AddToggle("ESPPlayersToggle", {
    Text = "ESP Players",
    Default = false,
    Tooltip = "Shows player positions and names",
    Callback = function(state)
        NametagsEnabled = state
        HighlightEnabled = state
        
        for _, Player in pairs(Players:GetPlayers()) do
            if Player ~= LocalPlayer then
                if state then
                    CreateNametag(Player)
                    ApplyHighlight(Player)
                else
                    if Player.Character and Player.Character:FindFirstChild("Head") then
                        local Nametag = Player.Character.Head:FindFirstChild("Nametag")
                        if Nametag then
                            Nametag:Destroy()
                        end
                    end
                    if Player.Character then
                        for _, v in pairs(Player.Character:GetChildren()) do
                            if v:IsA("Highlight") then
                                v:Destroy()
                            end
                        end
                    end
                end
            end
        end
    end
})

espDistanceSlider = ESPBox:AddSlider("ESPDistanceSlider", {
    Text = "ESP Distance",
    Default = MaxDistance,
    Min = 100,
    Max = 1000,
    Rounding = 1,
    Tooltip = "Maximum distance for ESP to show",
    Callback = function(val)
        MaxDistance = val
    end
})

-- Apply ESP to new players
Players.PlayerAdded:Connect(function(Player)
    if NametagsEnabled then
        CreateNametag(Player)
        ApplyHighlight(Player)
    end
end)

-- Hide UI Elements
local hidePostureBarEnabled = false
hidePostureBarToggle = UIBox:AddToggle("HidePostureBarToggle", {
    Text = "Hide Posture Bar UI",
    Default = false,
    Tooltip = "Hides the posture bar UI.",
    Callback = function(state)
        hidePostureBarEnabled = state
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("Torso") then
            local postureBar = char.Torso:FindFirstChild("PostureBar")
            if postureBar then
                postureBar.Enabled = not state
            end
        end
        Library:Notify({
            Title = "Hide Posture Bar",
            Content = "Posture Bar UI visibility set to " .. tostring(not state) .. ".",
            Duration = 2
        })
    end
})

local hideParryBarEnabled = false
hideParryBarToggle = UIBox:AddToggle("HideParryBarToggle", {
    Text = "Hide Parry Bar UI",
    Default = false,
    Tooltip = "Hides the parry bar UI.",
    Callback = function(state)
        hideParryBarEnabled = state
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("Torso") then
            local parryBar = char.Torso:FindFirstChild("ParryBar")
            if parryBar then
                parryBar.Enabled = not state
            end
        end
        Library:Notify({
            Title = "Hide Parry Bar",
            Content = "Parry Bar UI visibility set to " .. tostring(not state) .. ".",
            Duration = 2
        })
    end
})

-- === Gyutaro Settings ===
local gyutaroSettings = {
    autoAim = false,
    multiThrow = false,
    autoTarget = false,
    multiThrowCount = 3,
    autoTargetRadius = 60,
}

gyutaroAutoAimToggle = StyleBox:AddToggle("GyutaroAutoAimToggle", {
    Text = "Gyutaro: Auto Aim",
    Default = gyutaroSettings.autoAim,
    Tooltip = "Sickles will fly to the nearest enemy",
    Callback = function(state) gyutaroSettings.autoAim = state end
})
gyutaroMultiThrowToggle = StyleBox:AddToggle("GyutaroMultiThrowToggle", {
    Text = "Gyutaro: Multi Throw",
    Default = gyutaroSettings.multiThrow,
    Tooltip = "Throws several sickles in a row",
    Callback = function(state) gyutaroSettings.multiThrow = state end
})
gyutaroMultiThrowCountSlider = StyleBox:AddSlider("GyutaroMultiThrowCount", {
    Text = "Gyutaro: Sickle Count",
    Default = gyutaroSettings.multiThrowCount,
    Min = 1,
    Max = 5,
    Rounding = 0,
    Tooltip = "How many sickles to throw at once",
    Callback = function(val) gyutaroSettings.multiThrowCount = val end
})
gyutaroAutoTargetToggle = StyleBox:AddToggle("GyutaroAutoTargetToggle", {
    Text = "Gyutaro: Auto Target",
    Default = gyutaroSettings.autoTarget,
    Tooltip = "Automatically selects the nearest enemy and uses the skill",
    Callback = function(state) gyutaroSettings.autoTarget = state end
})
gyutaroAutoTargetRadiusSlider = StyleBox:AddSlider("GyutaroAutoTargetRadius", {
    Text = "Gyutaro: Auto Target Radius",
    Default = gyutaroSettings.autoTargetRadius,
    Min = 10,
    Max = 100,
    Rounding = 0,
    Tooltip = "Radius to search for the nearest enemy for auto target",
    Callback = function(val) gyutaroSettings.autoTargetRadius = val end
})

-- === Gyutaro Auto Target (исправлено) ===
local function patchGyutaroSkills()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    -- Патч FlyingSickleController
    local success, FlyingSickleController = pcall(function()
        return require(ReplicatedStorage.Knit.Controllers.MoveControllers.Gyutaro.FlyingSickleController)
    end)
    
    if success and FlyingSickleController then
        local originalFlyingSickleKnitStart = FlyingSickleController.KnitStart
        FlyingSickleController.KnitStart = function(self, ...)
            originalFlyingSickleKnitStart(self, ...)
            
            local Knit = require(ReplicatedStorage.Knit.Packages.Knit)
            local EmitController = require(ReplicatedStorage.Knit.Modules.EmitController)
            local u5 = Players.LocalPlayer
            local u1 = ReplicatedStorage
            local u13 = u1.Assets.Animations.Moves
            local u14 = {}
            
            local function enhancedFlyingSickleEffect(p15, p16)
                local u17 = p16.Character
                if u17 then
                    local u18 = u17:FindFirstChild("HumanoidRootPart")
                    if u18 then
                        local v19 = u17:FindFirstChild("Humanoid")
                        if v19 then
                            local v20 = Players:GetPlayerFromCharacter(u17)
                            if p15 == "Start" then
                                local v21 = v19.Animator:LoadAnimation(u13.Gyutaro.SickleThrow)
                                v21:Play()
                                v21:AdjustSpeed(10) -- ускоряем анимацию броска
                                u14[u17] = v21
                                local v22 = u1.Assets.Sounds.Moves.Gyutaro.Throw:Clone()
                                v22.Parent = u18
                                v22:Play()
                                game:GetService("Debris"):AddItem(v22, v22.TimeLength)
                                task.delay(0.25, function()
                                    if u14[u17] then
                                        local v23 = script.AngryExplo:Clone()
                                        v23.Parent = workspace.Debris
                                        v23.CFrame = u18.CFrame
                                        EmitController.Weld(u18, v23)
                                        EmitController.Emit(v23, 5)
                                    end
                                end)
                                return
                            elseif p15 == "Shoot" then
                                local target = nil
                                if gyutaroSettings.autoAim then
                                    target = getNearestEnemyModel(u18.Position, gyutaroSettings.autoTargetRadius) or (p16.Target and p16.Target:FindFirstChild("HumanoidRootPart"))
                                else
                                    target = (p16.Target and p16.Target:FindFirstChild("HumanoidRootPart"))
                                end
                                local u25 = 0.1 -- duration полёта sickle (очень быстро)
                                local repeatCount = gyutaroSettings.multiThrow and gyutaroSettings.multiThrowCount or 1
                                local startCFrame = u18.CFrame
                                for i = 1, repeatCount do
                                    task.spawn(function()
                                        local v27 = script.Throw:Clone()
                                        v27.Parent = workspace.Debris
                                        v27:PivotTo(startCFrame)
                                        EmitController.Emit(v27, 5)
                                        local v29 = target and target.Position or (u18.Position + u18.CFrame.LookVector * 20)
                                        local v35 = tick()
                                        local duration = u25 or 0.7
                                        repeat
                                            game:GetService("RunService").Heartbeat:Wait()
                                            local pos = u18.Position:Lerp(v29, math.min((tick() - v35) / duration, 1))
                                            v27.CFrame = CFrame.new(pos, v29)
                                        until (tick() - v35) > duration
                                        -- Попытка нанести урон (если возможно)
                                        if target and target.Parent and target.Parent:FindFirstChild("Humanoid") then
                                            local humanoid = target.Parent:FindFirstChild("Humanoid")
                                            if humanoid and humanoid.Health > 0 then
                                                -- Попытка вызвать урон через RemoteEvent (если есть)
                                                local Remotes = ReplicatedStorage:FindFirstChild("Remotes")
                                                local DamageEvent = Remotes and Remotes:FindFirstChild("Damage")
                                                if DamageEvent then
                                                    DamageEvent:FireServer(target.Parent, 10) -- 10 урона, пример
                                                end
                                            end
                                        end
                                        -- Телепортируем sickle назад и повторяем, если не последний раз
                                        if i < repeatCount then
                                            v27.CFrame = startCFrame
                                            task.wait(0.05)
                                        end
                                        v27:Destroy()
                                    end)
                                    task.wait(0.1)
                                end
                            elseif p15 == "Cancel" and u14[u17] then
                                u14[u17]:Stop()
                                u14[u17] = nil
                            end
                        end
                    end
                end
            end
            
            -- Подключаем патченный обработчик
            EmitController.Effect:Connect(enhancedFlyingSickleEffect)
        end
    end
    
    -- Патч PoisonVeinController
    local success2, PoisonVeinController = pcall(function()
        return require(ReplicatedStorage.Knit.Controllers.MoveControllers.Gyutaro.PoisonVeinController)
    end)
    
    if success2 and PoisonVeinController then
        local originalPoisonVeinKnitStart = PoisonVeinController.KnitStart
        PoisonVeinController.KnitStart = function(self, ...)
            originalPoisonVeinKnitStart(self, ...)
            
            local EmitController = require(ReplicatedStorage.Knit.Modules.EmitController)
            local u1 = ReplicatedStorage
            local u12 = u1.Assets.Animations.Moves
            local u4 = game:GetService("Debris")
            local u3 = game:GetService("TweenService")
            local Players = game:GetService("Players")
            
            local function enhancedPoisonVeinEffect(p13, p14)
                if p14 then
                    local u15 = p14:FindFirstChild("HumanoidRootPart")
                    if u15 then
                        local v16 = p14:FindFirstChild("Humanoid")
                        if v16 then
                            if p13 == "Start" then
                                v16.Animator:LoadAnimation(u12.Gyutaro.PoisonVein):Play()
                                local v17 = u1.Assets.Sounds.Moves.Gyutaro.PoisonVein:Clone()
                                v17.Parent = u15
                                v17:Play()
                                u4:AddItem(v17, v17.TimeLength)
                                local u18 = script.PoisonVein:Clone()
                                u18.Parent = workspace.Debris
                                u18.CFrame = u15.CFrame
                                local u19 = script.Highlight:Clone()
                                u19.Parent = p14
                                u19.OutlineTransparency = 1
                                u19.FillTransparency = 1
                                u3:Create(u19, TweenInfo.new(0.3), {
                                    ["FillTransparency"] = 0,
                                    ["OutlineTransparency"] = 0
                                }):Play()
                                EmitController.Emit(u18.Windup)
                                EmitController.Emit(u18.Smoke.Start)
                                task.delay(0.4, function()
                                    EmitController.Emit(u18["Blood EMit"])
                                    EmitController.Emit(u18["Blood Emit 2"])
                                    EmitController.Enable(u18.Smoke.at, true)
                                    EmitController.Enable(u18.Smoke.Attachment, true)
                                    EmitController.Enable(u18.Roar, true)
                                    u19:Destroy()
                                    if (u15.Position - workspace.CurrentCamera.CFrame.Position).Magnitude <= 100 then
                                        local CameraShakeController = require(ReplicatedStorage.Knit.Controllers.CameraShakeController)
                                        CameraShakeController.CameraShaker:Shake(CameraShakeController.CameraShaker.Presets.Explosion)
                                    end
                                end)
                                task.delay(0.8, function()
                                    EmitController.Enable(u18.Roar, false)
                                    EmitController.Enable(u18.Smoke, false)
                                end)
                                task.delay(30, function() -- buff duration
                                    u18:Destroy()
                                end)
                                if p14 == LocalPlayer.Character then
                                    local hum = p14:FindFirstChild("Humanoid")
                                    if hum then
                                        if not hum:FindFirstChild("PoisonVeinBuff") then
                                            local buff = Instance.new("NumberValue")
                                            buff.Name = "PoisonVeinBuff"
                                            buff.Value = 3.0
                                            buff.Parent = hum
                                        else
                                            hum.PoisonVeinBuff.Value = 3.0
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            
            -- Подключаем патченный обработчик
            local CombatEffects = require(ReplicatedStorage.Knit.Modules.CombatEffects)
            CombatEffects.Effect:Connect(enhancedPoisonVeinEffect)
        end
    end
    
    -- Auto Target для Gyutaro
    if gyutaroSettings.autoTarget then
        local UserInputService = game:GetService("UserInputService")
        UserInputService.InputBegan:Connect(function(input, processed)
            if not processed and input.KeyCode == Enum.KeyCode.One then
                local chars = workspace:FindFirstChild("Characters")
                local myChar = LocalPlayer and LocalPlayer.Character
                if not chars or not myChar or not myChar:FindFirstChild("HumanoidRootPart") then return end
                local target = getNearestEnemyModel(myChar.HumanoidRootPart.Position, gyutaroSettings.autoTargetRadius)
                if target then
                    local lockVal = myChar:FindFirstChild("LockOnTarget")
                    if not lockVal then
                        lockVal = Instance.new("ObjectValue")
                        lockVal.Name = "LockOnTarget"
                        lockVal.Parent = myChar
                    end
                    lockVal.Value = target
                end
            end
        end)
    end
end

-- Akaza Settings Groupbox
local AkazaBox = ExploitsTab:AddRightGroupbox("Akaza Exploits (MAY NOT WORK)")

-- Akaza: Air Control Toggle
local akazaAirControlEnabled = false
local originalAirTypeKnitStart = nil
local airTypePatched = false

akazaAirControlToggle = AkazaBox:AddToggle("AkazaAirControlToggle", {
    Text = "Akaza: Air Control",
    Default = false,
    Tooltip = "Maintain full control while using Akaza's AirType move in the air",
    Callback = function(state)
        akazaAirControlEnabled = state
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        
        -- Патчим контроллер только один раз
        if not airTypePatched then
        local success, AirTypeController = pcall(function()
            return require(ReplicatedStorage.Knit.Controllers.MoveControllers.Akaza.AirTypeController)
        end)
            
        if success and AirTypeController then
                -- Сохраняем оригинальную функцию
                originalAirTypeKnitStart = AirTypeController.KnitStart
                
                -- Создаем патченную версию
                AirTypeController.KnitStart = function(self, ...)
                    -- Вызываем оригинальную функцию
                    originalAirTypeKnitStart(self, ...)
                    
                    -- Получаем сервис и патчим его события
                    local Knit = require(ReplicatedStorage.Knit.Packages.Knit)
                    local AirTypeService = Knit.GetService("AirTypeService")
                    
                    if AirTypeService and AirTypeService.Effect then
                        -- Создаем патченный обработчик
                        local function patchedEffectHandler(p15, p16)
                            local v_u_17 = p16.Character
                            if v_u_17 then
                                local v_u_18 = v_u_17:FindFirstChild("HumanoidRootPart")
                                if v_u_18 then
                                    local v19 = v_u_17:FindFirstChild("Humanoid")
                                    if v19 then
                                        local v_u_20 = p16.Target
                                        local v_u_21 = game:GetService("Players"):GetPlayerFromCharacter(v_u_17)
                                        local v_u_5 = game:GetService("Players").LocalPlayer
                                        
                                        if p15 == "Start" then
                                            local v_u_22
                                            if v_u_21 and v_u_21 == v_u_5 then
                                                -- Проверяем, находится ли игрок в воздухе
                                                local isInAir = v19.FloorMaterial == Enum.Material.Air
                                                
                                                if isInAir then
                                                    v_u_22 = v19.Animator:LoadAnimation(ReplicatedStorage.Assets.Animations.Moves.Akaza.AirType.Air)
                                                    v_u_22:Play()
                                                    
                                                    -- ПАТЧ: Если включен Air Control, убираем ограничения
                                                    if akazaAirControlEnabled then
                                                        -- Просто сбрасываем скорость, не создаем BodyGyro/BodyVelocity
                                                        v_u_18.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                                                        
                                                        -- Создаем только минимальный BodyGyro для поворота камеры
                                                        local v_u_24 = Instance.new("BodyGyro")
                                                        v_u_24.Parent = v_u_18
                                                        v_u_24.D = 10
                                                        v_u_24.P = 20000
                                                        v_u_24.MaxTorque = Vector3.new(0, 20000, 0) -- Только Y ось
                                                        
                                                        local v_u_25 = game:GetService("RunService").RenderStepped:Connect(function()
                                                            if v_u_24 and v_u_24.Parent then
                                                                v_u_24.CFrame = CFrame.new(v_u_24.CFrame.Position) * CFrame.Angles(0, workspace.CurrentCamera.CFrame.Y, 0)
                                                            else
                                                                v_u_25:Disconnect()
                                                            end
                                                        end)
                                                        
                                                        -- Удаляем через 0.9 секунды
                                                        task.delay(0.9, function()
                                                            if v_u_24 and v_u_24.Parent then
                                                                v_u_18.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                                                                v_u_25:Disconnect()
                                                                v_u_24:Destroy()
                                                            end
                                                        end)
                                                    else
                                                        -- Оригинальная логика для воздуха
                                                        local v_u_23 = v_u_18.CFrame * CFrame.new(0, 0, -3)
                                                        v_u_18.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                                                        local v_u_24 = Instance.new("BodyGyro")
                                                        v_u_24.Parent = v_u_18
                                                        v_u_24.D = 10
                                                        v_u_24.P = 20000
                                                        v_u_24.MaxTorque = Vector3.new(20000, 20000, 20000)
                                                        local v_u_25 = game:GetService("RunService").RenderStepped:Connect(function()
                                                            v_u_24.CFrame = workspace.CurrentCamera.CFrame
                                                        end)
                                                        local v26 = v_u_18:FindFirstChildWhichIsA("BodyVelocity")
                                                        if v26 then
                                                            v26:Destroy()
                                                        end
                                                        local v_u_27 = Instance.new("BodyVelocity")
                                                        v_u_27.Parent = v_u_18
                                                        v_u_27.MaxForce = Vector3.new(30000, 30000, 30000)
                                                        v_u_27.P = 30000
                                                        v_u_27.Velocity = Vector3.new(0, 0, 0)
                                                        task.delay(0.9, function()
                                                            v_u_18.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                                                            v_u_25:Disconnect()
                                                            v_u_24.CFrame = v_u_23
                                                            v_u_27:Destroy()
                                                            task.wait(0.1)
                                                            v_u_18.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                                                            v_u_24:Destroy()
                                                        end)
                                                    end
                                                else
                                                    v_u_22 = v19.Animator:LoadAnimation(ReplicatedStorage.Assets.Animations.Moves.Akaza.AirType.Ground)
                                                    v_u_22:Play()
                                                end
                                            else
                                                v_u_22 = v19.Animator:LoadAnimation(ReplicatedStorage.Assets.Animations.Moves.Akaza.AirType.Ground)
                                                v_u_22:Play()
                                            end
                                            
                                            -- Остальная логика остается без изменений
                                            local v_u_14 = {}
                                            v_u_14[v_u_17] = true
                                            local v_u_28 = ReplicatedStorage.Assets.VFX.Shockwave.AirType
                                            local function v_u_31()
                                                if v_u_14[v_u_17] == "Cancel" then
                                                    if v_u_22 and v_u_22.IsPlaying then
                                                        v_u_22:Stop()
                                                    end
                                                else
                                                    if v_u_21 == v_u_5 then
                                                        local CameraShakeController = Knit.GetController("CameraShakeController")
                                                        if CameraShakeController then
                                                            CameraShakeController.CameraShaker:Shake(CameraShakeController.CameraShaker.Presets.BigBump)
                                end
                            end
                                                    local v29 = v_u_28.VFX.shoot:Clone()
                                                    v29.Parent = v_u_18
                                                    require(ReplicatedStorage.Knit.Modules.EmitController).Emit(v29, 4)
                                                    local v30 = ReplicatedStorage.Assets.Sounds.Moves.Akaza.AirTypeThrow:Clone()
                                                    v30.Parent = v_u_18
                                                    v30.PlaybackSpeed = math.random(9, 12) / 10
                                                    v30:Play()
                                                    game:GetService("Debris"):AddItem(v30, v30.TimeLength)
                                                    if v_u_5 == v_u_21 then
                                                        AirTypeService.Shoot:Fire(v_u_20)
                                                    end
                                                end
                                            end
                                            task.delay(0.25, v_u_31)
                                            task.delay(0.56, v_u_31)
                                            task.delay(0.85, v_u_31)
                                            task.delay(1.1, function()
                                                v_u_14[v_u_17] = nil
                                            end)
                                        elseif p15 == "Hit" then
                                            if v_u_20 then
                                                local v32 = v_u_20:FindFirstChild("HumanoidRootPart")
                                                if v32 then
                                                    local v33 = ReplicatedStorage.Assets.VFX.Shockwave.AirType.VFX.hit:Clone()
                                                    v33.Parent = v32
                                                    require(ReplicatedStorage.Knit.Modules.EmitController).Emit(v33, 4)
                                                    local v34 = ReplicatedStorage.Assets.Sounds.Moves.Akaza.AirTypeHit:Clone()
                                                    v34.Parent = v_u_20.PrimaryPart
                                                    v34.PlaybackSpeed = math.random(9, 12) / 10
                                                    v34:Play()
                                                    game:GetService("Debris"):AddItem(v34, v34.TimeLength)
                                                end
                                            end
                                        elseif p15 == "StartParry" then
                                            v19.Animator:LoadAnimation(ReplicatedStorage.Assets.Animations.Moves.Akaza.AirType.Parry):Play()
                                            local v35 = v_u_18:FindFirstChildWhichIsA("BodyVelocity")
                                            if v35 then
                                                v35:Destroy()
                                            end
                                            local v_u_36 = ReplicatedStorage.Assets.VFX.Shockwave.AirType
                                            local function v_u_39()
                                                if v_u_21 == v_u_5 then
                                                    local CameraShakeController = Knit.GetController("CameraShakeController")
                                                    if CameraShakeController then
                                                        CameraShakeController.CameraShaker:Shake(CameraShakeController.CameraShaker.Presets.BigBump)
                                                    end
                                                end
                                                local v37 = v_u_36.VFX.shoot:Clone()
                                                v37.Parent = v_u_18
                                                require(ReplicatedStorage.Knit.Modules.EmitController).Emit(v37, 4)
                                                local v38 = ReplicatedStorage.Assets.Sounds.Moves.Akaza.AirTypeThrow:Clone()
                                                v38.Parent = v_u_18
                                                v38.PlaybackSpeed = math.random(9, 12) / 10
                                                v38:Play()
                                                game:GetService("Debris"):AddItem(v38, v38.TimeLength)
                                                AirTypeService.Shoot:Fire(v_u_20)
                                            end
                                            local v_u_40 = Instance.new("BodyVelocity")
                                            v_u_40.Parent = v_u_18
                                            v_u_40.MaxForce = Vector3.new(30000, 30000, 30000)
                                            v_u_40.P = 30000
                                            v_u_40.Velocity = -v_u_18.CFrame.LookVector + Vector3.new(0, 1, 0)
                                            task.delay(0.2, v_u_39)
                                            task.delay(0.6, v_u_39)
                                            task.spawn(function()
                                                local v41 = tick()
                                                local v42 = tick() + 0.5
                                                while tick() <= v42 and v_u_40 do
                                                    local v43 = -((tick() - v41) / (v42 - v41) - 1)
                                                    v_u_40.Velocity = (-v_u_18.CFrame.LookVector + Vector3.new(0, 1, 0)) * (v43 * 90)
                                                    task.wait(0.02)
                                                end
                                                task.wait(0.4)
                                                if v_u_40 then
                                                    v_u_40:Destroy()
                                                end
                                            end)
                                        elseif p15 == "Cancel" then
                                            -- Обработка отмены
                                        end
                                    end
                                end
                            end
                        end
                        
                        -- Подключаем патченный обработчик
                        AirTypeService.Effect:Connect(patchedEffectHandler)
                    end
                end
                
                airTypePatched = true
            end
        end
        
        if state then
                Library:Notify({
                    Title = "Akaza: Air Control",
                    Content = "Akaza Air Control ENABLED.",
                    Duration = 2
                })
            else
                Library:Notify({
                    Title = "Akaza: Air Control",
                    Content = "Akaza Air Control DISABLED.",
                    Duration = 2
            })
        end
    end
})

-- Reapply Akaza patches
if akazaAirControlEnabled then
    local akazaAirControlToggle = AkazaBox.Flags.AkazaAirControlToggle
    if akazaAirControlToggle then
        akazaAirControlToggle:Set(true)
    end
end

-- Free Movesets
local movesetList = {"Akaza", "Default", "Gyutaro", "Rengoku", "Tanjiro", "Tengen"}
local selectedMoveset = nil

local FreeMovesetsBox = MainTab:AddLeftGroupbox("Free Movesets")
FreeMovesetsBox:AddLabel("Select a moveset style:")
FreeMovesetsBox:AddDropdown("MovesetDropdown", {
    Values = movesetList,
    Default = "Default",
    Multi = false,
    Text = "Choose moveset",
    Tooltip = "Change your moveset style instantly",
    Callback = function(val)
        selectedMoveset = val
    end
})
FreeMovesetsBox:AddButton("Apply Moveset", function()
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local Workspace = game:GetService("Workspace")
    local chars = Workspace:FindFirstChild("Characters")
    if LocalPlayer and selectedMoveset then
        LocalPlayer:SetAttribute("Moveset", selectedMoveset)
        local char = LocalPlayer.Character
        if char then
            char:SetAttribute("Moveset", selectedMoveset)
            
            local Knit = require(game:GetService("ReplicatedStorage").Knit.Packages.Knit)
            local MoveController = Knit.GetController("MoveController")
            local GlobalMoveset = require(game:GetService("ReplicatedStorage").Knit.Modules.GlobalMoveset)

            if MoveController and GlobalMoveset then
                MoveController:MovesSetup() 
                GlobalMoveset.SetupControls()
            else
                Library:Notify({
                    Title = "Error",
                    Content = "Failed to load MoveController or GlobalMoveset!",
                    Duration = 3
                })
            end

            local humanoid = char:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.Health = 0
            end

            Library:Notify({
                Title = "Moveset Changed",
                Content = "Your moveset is now: " .. selectedMoveset .. ". Character will reset.",
                Duration = 3
            })
        else
            Library:Notify({
                Title = "Error",
                Content = "Character not found! Cannot set Moveset on character.",
                Duration = 2
            })
        end
    else
        Library:Notify({
            Title = "Error",
            Content = "Select a moveset first!",
            Duration = 2
        })
    end
end)

-- Универсальный обработчик для повторного применения патчей после смерти персонажа
local function reapplyAllPatches()
    if noStunEnabled and MainLeft.Flags and MainLeft.Flags.NoStunToggle then
        MainLeft.Flags.NoStunToggle:Set(true)
    end
    if autoBlockEnabled and MainLeft.Flags and MainLeft.Flags.AutoBlockToggle then
        MainLeft.Flags.AutoBlockToggle:Set(true)
    end
    if attackWhileStunnedEnabled and MainLeft.Flags and MainLeft.Flags.AttackWhileStunnedToggle then
        MainLeft.Flags.AttackWhileStunnedToggle:Set(true)
    end
    if antiKnockbackEnabled and CombatExploitsBox.Flags and CombatExploitsBox.Flags.AntiKnockbackToggle then
        CombatExploitsBox.Flags.AntiKnockbackToggle:Set(true)
    end
    if antiHitboxEnabled and CombatExploitsBox.Flags and CombatExploitsBox.Flags.AntiHitboxToggle then
        CombatExploitsBox.Flags.AntiHitboxToggle:Set(true)
    end
    if noSmokeEnabled and ESPBox.Flags and ESPBox.Flags.NoSmokeToggle then
        ESPBox.Flags.NoSmokeToggle:Set(true)
    end
    if hidePostureBarEnabled and UIBox.Flags and UIBox.Flags.HidePostureBarToggle then
        UIBox.Flags.HidePostureBarToggle:Set(true)
    end
    if hideParryBarEnabled and UIBox.Flags and UIBox.Flags.HideParryBarToggle then
        UIBox.Flags.HideParryBarToggle:Set(true)
    end

    patchGyutaroSkills()
    if akazaAirControlEnabled then
        local akazaAirControlToggle = AkazaBox.Flags.AkazaAirControlToggle
        if akazaAirControlToggle then
            akazaAirControlToggle:Set(true)
        end
    end
    updateNoKnockbackPatch()
end

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    reapplyAllPatches()
end)


-- Настройки для анти-статусов
local antiStatusSettings = {
    Bleed = false,
    Poison = false,
    Slow = false,
    Root = false,
    Freeze = false,
    Stun = false,
    CombatTag = false,
}

-- === Переносим UI из AntiStatusBox в BypassMainBox ===
BypassMainBox:AddLabel("Select statuses to remove:")
antiBleedToggle = BypassMainBox:AddToggle("AntiBleedToggle", {
    Text = "Anti-Bleed",
    Default = false,
    Tooltip = "Automatically removes bleed effect",
    Callback = function(state) antiStatusSettings.Bleed = state end
})
antiPoisonToggle = BypassMainBox:AddToggle("AntiPoisonToggle", {
    Text = "Anti-Poison",
    Default = false,
    Tooltip = "Automatically removes poison",
    Callback = function(state) antiStatusSettings.Poison = state end
})
antiSlowToggle = BypassMainBox:AddToggle("AntiSlowToggle", {
    Text = "Anti-Slow",
    Default = false,
    Tooltip = "Automatically removes slowdown",
    Callback = function(state) antiStatusSettings.Slow = state end
})
antiRootToggle = BypassMainBox:AddToggle("AntiRootToggle", {
    Text = "Anti-Root",
    Default = false,
    Tooltip = "Automatically removes root/immobilization",
    Callback = function(state) antiStatusSettings.Root = state end
})
antiFreezeToggle = BypassMainBox:AddToggle("AntiFreezeToggle", {
    Text = "Anti-Freeze",
    Default = false,
    Tooltip = "Automatically removes freezing",
    Callback = function(state) antiStatusSettings.Freeze = state end
})
antiStunToggle = BypassMainBox:AddToggle("AntiStunToggle", {
    Text = "Anti-Stun",
    Default = false,
    Tooltip = "Automatically removes stun",
    Callback = function(state) antiStatusSettings.Stun = state end
})
antiCombatTagToggle = BypassMainBox:AddToggle("AntiCombatTagToggle", {
    Text = "Anti-CombatTag",
    Default = false,
    Tooltip = "Automatically removes CombatTag from character model",
    Callback = function(state) antiStatusSettings.CombatTag = state end
})

-- === Новые патчи с тогглами для обхода ограничений ===
-- 1. Атака при статусах (CanAttack и GetData)
local attackAnyStatusEnabled = false
local originalCanAttackBypass = MovesetHandler.CanAttack
local originalGetDataBypass = CharacterDataModule.GetData
attackAnyStatusToggle = BypassMainBox:AddToggle("AttackAnyStatusToggle", {
    Text = "No slow",
    Default = false,
    Tooltip = "No slowing even when stunned, blocked, etc.",
    Callback = function(state)
        attackAnyStatusEnabled = state
        if state then
            MovesetHandler.CanAttack = function(...)
                return true
            end
            CharacterDataModule.GetData = function(self, ...)
                local data = originalGetDataBypass(self, ...)
                data.Stun = 0
                data.HardStun = 0
                data.PunchStun = 0
                data.Blocking = false
                return data
            end
        else
            MovesetHandler.CanAttack = originalCanAttackBypass
            CharacterDataModule.GetData = originalGetDataBypass
        end
    end
})

-- 2. Быстрый HeavyClash (патч TagModule.Cooldown)
local fastHeavyClashEnabled = false
local heavyClashCooldown = 1
local originalCooldownBypass = TagModule.Cooldown
fastHeavyClashToggle = BypassMainBox:AddToggle("FastHeavyClashToggle", {
    Text = "Fast HeavyClash",
    Default = false,
    Tooltip = "Reduces HeavyClash cooldown to the specified value (sec)",
    Callback = function(state)
        fastHeavyClashEnabled = state
        if state then
            TagModule.Cooldown = function(self, obj, time, tag, ...)
                if tag == "HeavyClash" then
                    return originalCooldownBypass(self, obj, heavyClashCooldown, tag, ...)
                else
                    return originalCooldownBypass(self, obj, time, tag, ...)
                end
            end
        else
            TagModule.Cooldown = originalCooldownBypass
        end
    end
})
heavyClashCooldownSlider = BypassMainBox:AddSlider("HeavyClashCooldownSlider", {
    Text = "HeavyClash CD (sec)",
    Default = 1,
    Min = 0.1,
    Max = 10,
    Rounding = 1,
    Tooltip = "HeavyClash cooldown time (sec)",
    Callback = function(val)
        heavyClashCooldown = val
    end
})

-- 4. Снятие ограничений движения (PauseMovement, Knocked, Anchored)
local removeMovementLimitsEnabled = false
local removeMovementLimitsConn = nil
removeMovementLimitsToggle = BypassMainBox:AddToggle("RemoveMovementLimitsToggle", {
    Text = "Remove Movement Limits",
    Default = false,
    Tooltip = "Removes movement restrictions: PauseMovement, Knocked, Anchored, etc.",
    Callback = function(state)
        removeMovementLimitsEnabled = state
        if removeMovementLimitsConn then
            removeMovementLimitsConn:Disconnect()
            removeMovementLimitsConn = nil
        end
        if state then
            removeMovementLimitsConn = RunService.Heartbeat:Connect(function()
                local char = LocalPlayer.Character
                if char then
                    if char:GetAttribute("PauseMovement") then
                        char:SetAttribute("PauseMovement", nil)
                    end
                    if char:GetAttribute("Knocked") then
                        char:SetAttribute("Knocked", nil)
                    end
                    if char:FindFirstChild("HumanoidRootPart") then
                        char.HumanoidRootPart.Anchored = false
                    end
                end
            end)
        end
    end
})


-- === Сброс Blocking на каждом кадре для обхода блокировки атаки ===
local removeBlockingConn = nil
if removeBlockingConn then removeBlockingConn:Disconnect() end
removeBlockingConn = RunService.Heartbeat:Connect(function()
    local char = LocalPlayer.Character
    if char and char:GetAttribute("Blocking") then
        char:SetAttribute("Blocking", false)
    end
end)

-- === Attack Speed Slider (скорость при атаке) ===
local attackSpeedValue = 10
local punchStunSpeedValue = 10

attackSpeedSlider = MainRight:AddSlider("AttackSpeedSlider", {
    Text = "Attack Speed (requires No knockback)",
    Default = 10,
    Min = 1,
    Max = 50,
    Rounding = 0,
    Tooltip = "Set WalkSpeed while Attacking.",
    Callback = function(val)
        attackSpeedValue = val
        print("[Config] AttackSpeedSlider set to:", val)
    end
})

punchStunSpeedSlider = MainRight:AddSlider("PunchStunSpeedSlider", {
    Text = "PunchStun Speed",
    Default = 10,
    Min = 1,
    Max = 50,
    Rounding = 0,
    Tooltip = "Set WalkSpeed while in PunchStun.",
    Callback = function(val)
        punchStunSpeedValue = val
        print("[Config] PunchStunSpeedSlider set to:", val)
    end
})

-- Удаляем старые RenderStepped/Heartbeat патчи, связанные с этими слайдерами
if speedPatchConn then speedPatchConn:Disconnect() end
speedPatchConn = nil

-- Жёсткий патч скорости: выставляем WalkSpeed каждый кадр после всех изменений
local forceSpeedConn = nil
if forceSpeedConn then forceSpeedConn:Disconnect() end
forceSpeedConn = game:GetService("RunService").RenderStepped:Connect(function()
    local char = LocalPlayer.Character
    if not char then return end
    local hum = char:FindFirstChildWhichIsA("Humanoid")
    if not hum then return end
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local CharacterDataModule = require(ReplicatedStorage.Knit.Modules.Data.CharacterData)
    local data = nil
    pcall(function()
        data = CharacterDataModule.GetData()
    end)
    if not data then return end
    -- Жёстко выставляем скорость в нужных состояниях
    if data.PunchStun and data.PunchStun > 0 then
        hum.WalkSpeed = punchStunSpeedValue
    elseif data.Attacking and data.Attacking > 0 then
        hum.WalkSpeed = attackSpeedValue
    end
end)

-- Патчируем SpeedController
local speedControllerPatched = false
local originalRenderStepped = nil

local function patchSpeedController()
    if speedControllerPatched then return end
    speedControllerPatched = true
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local CharacterDataModule = require(ReplicatedStorage.Knit.Modules.Data.CharacterData)
    local function onStep()
        local char = LocalPlayer.Character
        if not char then return end
        local hum = char:FindFirstChildWhichIsA("Humanoid")
        if not hum then return end
        local data = CharacterDataModule.GetData(char)
        if not data then return end
        if (data.HardStun or 0) > 0 then
            hum.WalkSpeed = 0
            hum.JumpPower = 0
        elseif (data.Stun or 0) > 0 then
            hum.WalkSpeed = 4
            hum.JumpPower = 0
        elseif data.Blocking then
            hum.WalkSpeed = 2
            hum.JumpPower = 0
        elseif (data.PunchStun or 0) > 0 then
            hum.WalkSpeed = punchStunSpeedValue
            hum.JumpPower = 0
        elseif (data.Attacking or 0) > 0 then
            hum.WalkSpeed = attackSpeedValue
            hum.JumpPower = 0
        elseif data.Running then
            hum.WalkSpeed = data.Agility or 20
            hum.JumpPower = 0
        else
            hum.WalkSpeed = 10
            hum.JumpPower = 30
        end
    end
    originalRenderStepped = RunService.RenderStepped:Connect(onStep)
end

patchSpeedController()

-- === Speed Settings (MainRight) ===
local speedValues = speedValues or {
    HardStun = 4,
    Stun = 4,
    Blocking = 2,
    PunchStun = 10,
    Attacking = 10,
    Knocked = 0,
}
local autoRemoveKnocked = autoRemoveKnocked or false

MainRight:AddLabel("Speed Settings")
hardStunSpeedSlider = MainRight:AddSlider("HardStunSpeedSlider", {
    Text = "HardStun Speed (requires no Knockback)",
    Min = 0,
    Max = 30,
    Default = speedValues.HardStun,
    Rounding = 0,
    Tooltip = "Speed during HardStun (requires No Knockback)",
    Callback = function(val) speedValues.HardStun = val end
})
stunSpeedSlider = MainRight:AddSlider("StunSpeedSlider", {
    Text = "Stun Speed (requires No Knockback)",
    Min = 0,
    Max = 30,
    Default = speedValues.Stun,
    Rounding = 0,
    Tooltip = "Speed during Stun (requires No Knockback)",
    Callback = function(val) speedValues.Stun = val end
})
blockingSpeedSlider = MainRight:AddSlider("BlockingSpeedSlider", {
    Text = "Blocking Speed (requires No Knockback)",
    Min = 0,
    Max = 30,
    Default = speedValues.Blocking,
    Rounding = 0,
    Tooltip = "Speed during Blocking (requires No Knockback)",
    Callback = function(val) speedValues.Blocking = val end
})
knockedSpeedSlider = MainRight:AddSlider("KnockedSpeedSlider", {
    Text = "Knocked Speed (requires No Knockback)",
    Min = 0,
    Max = 30,
    Default = speedValues.Knocked,
    Rounding = 0,
    Tooltip = "Speed during Knocked (requires No Knockback)",
    Callback = function(val) speedValues.Knocked = val end
})
autoRemoveKnockedToggle = MainRight:AddToggle("AutoRemoveKnockedToggle", {
    Text = "Auto Remove Knocked",
    Default = autoRemoveKnocked,
    Tooltip = "Automatically removes Knocked status if enabled.",
    Callback = function(state) autoRemoveKnocked = state end
})

-- === Dash Settings (MainRight) ===
local dashAmounts = dashAmounts or {
    Front = 95,
    Back = 110,
    Left = 130,
    Right = 130
}
local dashDuration = dashDuration or 0.15
local dashTowardsCameraEnabled = dashTowardsCameraEnabled or false

MainRight:AddLabel("Dash Settings")
dashTowardsCameraToggle = MainRight:AddToggle("DashTowardsCameraToggle", {
    Text = "Dash Towards Camera",
    Default = dashTowardsCameraEnabled,
    Tooltip = "If enabled, dash uses camera direction. If disabled, uses character direction.",
    Callback = function(state)
        dashTowardsCameraEnabled = state
    end
})
frontDashAmountInput = MainRight:AddInput("FrontDashAmount", {
    Text = "Front Dash Amount",
    Default = tostring(dashAmounts.Front),
    Numeric = true,
    Finished = true,
    Tooltip = "Amount for forward dash (default: 90)",
    Placeholder = "5-900",
    Callback = function(value)
        local num = tonumber(value)
        if num and num >= 5 and num <= 900 then
            dashAmounts.Front = num
        end
    end
})
backDashAmountInput = MainRight:AddInput("BackDashAmount", {
    Text = "Back Dash Amount",
    Default = tostring(dashAmounts.Back),
    Numeric = true,
    Finished = true,
    Tooltip = "Amount for backward dash (default: 90)",
    Placeholder = "5-900",
    Callback = function(value)
        local num = tonumber(value)
        if num and num >= 5 and num <= 900 then
            dashAmounts.Back = num
        end
    end
})
leftDashAmountInput = MainRight:AddInput("LeftDashAmount", {
    Text = "Left Dash Amount",
    Default = tostring(dashAmounts.Left),
    Numeric = true,
    Finished = true,
    Tooltip = "Amount for left dash (default: 90)",
    Placeholder = "5-900",
    Callback = function(value)
        local num = tonumber(value)
        if num and num >= 5 and num <= 900 then
            dashAmounts.Left = num
        end
    end
})
rightDashAmountInput = MainRight:AddInput("RightDashAmount", {
    Text = "Right Dash Amount",
    Default = tostring(dashAmounts.Right),
    Numeric = true,
    Finished = true,
    Tooltip = "Amount for right dash (default: 90)",
    Placeholder = "5-900",
    Callback = function(value)
        local num = tonumber(value)
        if num and num >= 5 and num <= 900 then
            dashAmounts.Right = num
        end
    end
})

-- Функция для получения направления даша
local function getDashDirection(char)
    local camera = workspace.CurrentCamera
    if not camera then return Vector3.new(0, 0, -1) end
    
    local baseCFrame
    if dashTowardsCameraEnabled then
        baseCFrame = camera.CFrame
    else
        -- Используем CFrame персонажа, если тоггл выключен
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then 
            return camera.CFrame.LookVector -- Fallback to camera if HRP not found
        end
        baseCFrame = hrp.CFrame
    end
    
    -- Получаем базовое направление от CFrame
    local lookVector = baseCFrame.LookVector
    local rightVector = baseCFrame.RightVector
    
    -- Определяем нажатые клавиши
    local moveDir = Vector3.new(0, 0, 0)
    if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveDir = moveDir + lookVector end
    if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveDir = moveDir - lookVector end
    if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveDir = moveDir + rightVector end
    if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveDir = moveDir - rightVector end
    
    -- Если нет инпута, используем направление вперед
    if moveDir.Magnitude < 0.1 then
        return lookVector
    end
    
    -- Нормализуем вектор движения
    return moveDir.Unit
end

-- Патчируем функцию ClientDash для изменения dash только у LocalPlayer
local originalClientDash = GlobalMoveset.ClientDash
GlobalMoveset.ClientDash = function(p29, p_u_30, p31, p32)
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local char = p29 or LocalPlayer.Character
    
    if char and char == LocalPlayer.Character then
        p32 = p32 or {}
        
        -- Получаем направление даша
        local dashDir = getDashDirection(char)
        
        -- Определяем тип даша на основе нажатых клавиш
        local dashAmount = dashAmounts.Front -- По умолчанию используем передний даш
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            dashAmount = dashAmounts.Back
        elseif UserInputService:IsKeyDown(Enum.KeyCode.A) then
            dashAmount = dashAmounts.Left
        elseif UserInputService:IsKeyDown(Enum.KeyCode.D) then
            dashAmount = dashAmounts.Right
        end
        
        -- Применяем выбранное значение DashAmount
        p32.DashAmount = dashAmount
        
        -- Вызов оригинальной функции с обновленными параметрами
        originalClientDash(p29, p_u_30, p31, p32)
        
        -- Получаем HumanoidRootPart
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then
            local bv = hrp:FindFirstChild("DashVelocity")
            if bv and bv:IsA("BodyVelocity") then
                -- Применяем направление и скорость
                bv.MaxForce = Vector3.new(50000, 50000, 50000)
                bv.Velocity = dashDir * dashAmount
                
                -- Удаляем через dashDuration
                task.delay(dashDuration, function()
                    if bv and bv.Parent then
                        bv:Destroy()
                    end
                end)
            end
        end
    else
        -- Вызываем оригинальную функцию для всех остальных игроков
        return originalClientDash(p29, p_u_30, p31, p32)
    end
end

-- === Patch Cooldowns/Delays Toggles ===
local patchCooldowns = {
    Dash = {enabled = false},
    Attack = {enabled = false},
    Jump = {enabled = false},
    HeavyAttack = {enabled = false},
}
local originalCheckCD = TagModule.CheckCD
local originalCooldown = TagModule.Cooldown

local function patchTagModule()
    TagModule.CheckCD = function(self, char, tag, ...)
        tag = tostring(tag)
        if patchCooldowns.Dash.enabled and tag:find("Dash") then
            return false
        end
        if patchCooldowns.Jump.enabled and tag:find("Super Jump") then
            return false
        end
        if patchCooldowns.Attack.enabled and (tag:find("Attack") or tag:find("Swing")) then
            return false
        end
        if patchCooldowns.HeavyAttack.enabled and tag:find("HeavyClash") then
            return false
        end
        return originalCheckCD(self, char, tag, ...)
    end
    TagModule.Cooldown = function(self, char, time, tag, ...)
        tag = tostring(tag)
        if patchCooldowns.Dash.enabled and tag:find("Dash") then
            return -- No cooldown
        end
        if patchCooldowns.Jump.enabled and tag:find("Super Jump") then
            return -- No cooldown
        end
        if patchCooldowns.Attack.enabled and (tag:find("Attack") or tag:find("Swing")) then
            return -- No cooldown
        end
        if patchCooldowns.HeavyAttack.enabled and tag:find("HeavyClash") then
            return -- No cooldown
        end
        return originalCooldown(self, char, time, tag, ...)
    end
end

local function restoreTagModule()
    TagModule.CheckCD = originalCheckCD
    TagModule.Cooldown = originalCooldown
end

-- === UI Toggles ===
BypassMainBox:AddLabel("No Cooldown Options")
noDashCooldownToggle = BypassMainBox:AddToggle("NoDashCooldownToggle", {
    Text = "No Dash Cooldown",
    Default = false,
    Tooltip = "Removes the cooldown between dashes.",
    Callback = function(state)
        patchCooldowns.Dash.enabled = state
        patchTagModule()
    end
})
noAttackCooldownToggle = BypassMainBox:AddToggle("NoAttackCooldownToggle", {
    Text = "No Attack Cooldown",
    Default = false,
    Tooltip = "Removes the cooldown between attacks (M1/M2).",
    Callback = function(state)
        patchCooldowns.Attack.enabled = state
        patchTagModule()
    end
})
noJumpCooldownToggle = BypassMainBox:AddToggle("NoJumpCooldownToggle", {
    Text = "No Jump Cooldown",
    Default = false,
    Tooltip = "Removes the cooldown for Super Jumps.",
    Callback = function(state)
        patchCooldowns.Jump.enabled = state
        patchTagModule()
    end
})
noHeavyAttackCooldownToggle = BypassMainBox:AddToggle("NoHeavyAttackCooldownToggle", {
    Text = "No Heavy Attack Cooldown",
    Default = false,
    Tooltip = "Removes the cooldown for heavy attacks (HeavyClash).",
    Callback = function(state)
        patchCooldowns.HeavyAttack.enabled = state
        patchTagModule()
    end
})

-- === Custom Features (Advanced Patches) - Перенесено в BypassMainBox ===
BypassMainBox:AddLabel("Advanced Features")

universalAttackToggle = BypassMainBox:AddToggle("UniversalAttackToggle", {
    Text = "Universal Attack",
    Default = false,
    Tooltip = "Allows attacking while stunned or blocking.",
    Callback = function(state)
        universalAttackEnabled = state
        pcall(function()
            local Knit = require(game:GetService("ReplicatedStorage").Knit.Packages.Knit)
            local CombatController = Knit.GetController("CombatController")
            local CharacterDataModule = require(game:GetService("ReplicatedStorage").Knit.Modules.Data.CharacterData)
            local UserInputService = game:GetService("UserInputService")
            if not originalLeftClick then
                originalLeftClick = CombatController.LeftClick
            end
            if universalAttackConn then
                universalAttackConn:Disconnect()
                universalAttackConn = nil
            end
            if state then
                universalAttackConn = RunService.Heartbeat:Connect(function()
                    if universalAttackEnabled then
                        local data = CharacterDataModule.GetData(LocalPlayer.Character)
                        if data then
                            data.Stun = 0
                            data.HardStun = 0
                            data.PunchStun = 0
                        end
                    end
                end)
                CombatController.LeftClick = function(...)
                    if universalAttackEnabled and UserInputService:IsKeyDown(Enum.KeyCode.F) then
                        CombatController:StopBlock()
                        task.wait()
                        originalLeftClick(...)
                        task.delay(0.1, function()
                            if UserInputService:IsKeyDown(Enum.KeyCode.F) and universalAttackEnabled then
                               CombatController:Block()
                            end
                        end)
                    else
                        originalLeftClick(...)
                    end
                end
            else
                CombatController.LeftClick = originalLeftClick
            end
        end)
    end
})

forceBlockToggle = BypassMainBox:AddToggle("ForceBlockToggle", {
    Text = "Force Block",
    Default = false,
    Tooltip = "Prevents your block from being interrupted as long as you hold the F key.",
    Callback = function(state)
        forceBlockEnabled = state
        pcall(function()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local Knit = require(ReplicatedStorage.Knit.Packages.Knit)
            local CombatController = Knit.GetController("CombatController")
            if not originalStopBlock then
                originalStopBlock = CombatController.StopBlock
            end
            if state then
                CombatController.StopBlock = function(self, ...)
                    local UserInputService = game:GetService("UserInputService")
                    if forceBlockEnabled and UserInputService:IsKeyDown(Enum.KeyCode.F) then
                        return -- Do nothing, keep blocking
                    end
                    return originalStopBlock(self, ...)
                end
            else
                if originalStopBlock then
                    CombatController.StopBlock = originalStopBlock
                end
            end
        end)
    end
})

-- === Custom Attack Range (исправленная логика) - Перенесено в BypassMainBox ===
customAttackRangeToggle = BypassMainBox:AddToggle("CustomAttackRangeToggle", {
    Text = "Custom Attack Range",
    Default = false,
    Tooltip = "Allows you to hit enemies at any distance (customizable).",
    Callback = function(state)
        customAttackRangeEnabled = state
        local GlobalMoveset = require(game:GetService("ReplicatedStorage").Knit.Modules.GlobalMoveset)
        if not originalGetHitCharacters then
            originalGetHitCharacters = GlobalMoveset.GetHitCharacters
        end
        if not originalAttackFunc then
            originalAttackFunc = GlobalMoveset.Attack
        end
        if state then
            GlobalMoveset.GetHitCharacters = function(self, cframe, size, ...)
                if customAttackRangeEnabled then
                    size = Vector3.new(customAttackRangeValue, customAttackRangeValue, customAttackRangeValue)
                end
                return originalGetHitCharacters(self, cframe, size, ...)
            end
            GlobalMoveset.Attack = function(p_u_93, p_u_94, p_u_95, p_u_96, p_u_97, p98)
                if customAttackRangeEnabled and p_u_97 then
                    p_u_97.FarAmount = customAttackFarAmount
                    p_u_97.CloseAmount = customAttackCloseAmount
                    p_u_97.CloseUpRange = customAttackCloseUpRange
                    p_u_97.TooFarRange = customAttackTooFarRange
                end
                return originalAttackFunc(p_u_93, p_u_94, p_u_95, p_u_96, p_u_97, p98)
            end
        else
            if originalGetHitCharacters then
                GlobalMoveset.GetHitCharacters = originalGetHitCharacters
            end
            if originalAttackFunc then
                GlobalMoveset.Attack = originalAttackFunc
            end
        end
    end
})
BypassMainBox:AddSlider("CustomAttackRangeSlider", {
    Text = "Attack Range Size",
    Min = 10,
    Max = 300,
    Default = 20,
    Rounding = 0,
    Tooltip = "Custom attack hitbox size (cube side length)",
    Callback = function(val)
        customAttackRangeValue = val
    end
})
customAttackFarAmountSlider = BypassMainBox:AddSlider("CustomAttackFarAmountSlider", {
    Text = "Far Amount",
    Min = 10,
    Max = 400,
    Default = 70,
    Rounding = 0,
    Tooltip = "FarAmount (distance for far dash in attack)",
    Callback = function(val)
        customAttackFarAmount = val
    end
})
customAttackCloseAmountSlider = BypassMainBox:AddSlider("CustomAttackCloseAmountSlider", {
    Text = "Close Amount",
    Min = 10,
    Max = 400,
    Default = 90,
    Rounding = 0,
    Tooltip = "CloseAmount (distance for close dash in attack)",
    Callback = function(val)
        customAttackCloseAmount = val
    end
})
BypassMainBox:AddSlider("CustomAttackCloseUpRangeSlider", {
    Text = "CloseUp Range",
    Min = 5,
    Max = 150,
    Default = 10,
    Rounding = 0,
    Tooltip = "CloseUpRange (distance for close-up hit)",
    Callback = function(val)
        customAttackCloseUpRange = val
    end
})
BypassMainBox:AddSlider("CustomAttackTooFarRangeSlider", {
    Text = "TooFar Range",
    Min = 50,
    Max = 400,
    Default = 120,
    Rounding = 0,
    Tooltip = "TooFarRange (max distance for attack)",
    Callback = function(val)
        customAttackTooFarRange = val
    end
})

infinitePostureToggle = BypassMainBox:AddToggle("InfinitePostureToggle", {
    Text = "Infinite Posture",
    Default = false,
    Tooltip = "Your posture bar will never decrease.",
    Callback = function(state)
        infinitePostureEnabled = state
        if infinitePostureConn then infinitePostureConn:Disconnect() infinitePostureConn = nil end
        if state then
            local Players = game:GetService("Players")
            local LocalPlayer = Players.LocalPlayer
            infinitePostureConn = game:GetService("RunService").RenderStepped:Connect(function()
                local char = LocalPlayer.Character
                if char then
                    char:SetAttribute("Posture", 100)
                end
            end)
        end
    end
})


infiniteJumpsToggle = BypassMainBox:AddToggle("InfiniteJumpsToggle", {
    Text = "Infinite Jumps",
    Default = false,
    Tooltip = "Allows you to jump infinitely in the air.",
    Callback = function(state)
        infiniteJumpsEnabled = state
        local PlayerController = require(game:GetService("ReplicatedStorage").Knit.Controllers.PlayerController)
        if not originalGroundCheck then
            originalGroundCheck = PlayerController.GroundCheck
        end
        if state then
            PlayerController.GroundCheck = function(...)
                return true
            end
        else
            if originalGroundCheck then
                PlayerController.GroundCheck = originalGroundCheck
            end
        end
    end
})

instantAttackToggle = BypassMainBox:AddToggle("InstantAttackToggle", {
    Text = "Instant Attack",
    Default = false,
    Tooltip = "Removes attack delay and makes attack animation instant.",
    Callback = function(state)
        instantAttackEnabled = state
        pcall(function()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local GlobalMoveset = require(ReplicatedStorage.Knit.Modules.GlobalMoveset)
            local CharacterDataModule = require(ReplicatedStorage.Knit.Modules.Data.CharacterData)
            local MovesetHandler = require(ReplicatedStorage.Knit.Modules.MovesetHandler)
            if not originalAttack then
                originalAttack = GlobalMoveset.Attack
            end
            if state then
                GlobalMoveset.Attack = function(p_u_93, p_u_94, p_u_95, p_u_96, p_u_97, p98)
                    local v99 = p_u_93:FindFirstChild("HumanoidRootPart")
                    if not v99 then return end
                    local v_u_100 = p_u_93:FindFirstChild("Humanoid")
                    if not v_u_100 then return end
                    if not MovesetHandler.CanAttack(p_u_93) then return end
                    local v_u_101 = CharacterDataModule.GetData(p_u_93)
                    local v_u_103 = v_u_101.CurrentCombo or 1
                    local v_u_108 = GlobalMoveset.GetMovesetAnims(p_u_93)
                    local v_u_135 = nil
                    -- Запуск анимации с ускорением
                    if p_u_96 then
                        v_u_135 = v_u_100.Animator:LoadAnimation(v_u_108.M2)
                    else
                        v_u_135 = v_u_100.Animator:LoadAnimation(v_u_108.M1s:FindFirstChild("M1-" .. v_u_103))
                    end
                    if v_u_135 then
                        v_u_135:Play()
                        v_u_135:AdjustSpeed(999)
                    end
                    -- Мгновенно увеличиваем комбо
                    if v_u_103 > 4 then
                        v_u_101.CurrentCombo = 1
                    else
                        v_u_101.CurrentCombo = v_u_103 + 1
                    end
                    -- Мгновенно наносим урон всем целям в зоне поражения
                    local v_u_137 = v99.CFrame
                    local v138 = GlobalMoveset.GetHitCharacters(nil, v_u_137 * CFrame.new(0, 0, -3.2), Vector3.new(8, 6, 8))
                    local v_u_139 = p_u_97 and p_u_97.DamageSettings or {Damage = 1, Stun = 0.1, Effect = nil, UseStats = false, Knockback = 0}
                    for _, v_u_141 in v138 do
                        if v_u_141 ~= p_u_93 then
                            local v142 = v_u_141:FindFirstChild("Humanoid")
                            if v142 and v_u_141:FindFirstChild("Torso") then
                                GlobalMoveset.MovesetHandler.GlobalMoveset.CombatService:Damage(v_u_141, {
                                    ["AttackedBy"] = p_u_93,
                                    ["Damage"] = v_u_139.Damage,
                                    ["Stun"] = v_u_139.Stun,
                                    ["Effect"] = v_u_139.Effect,
                                    ["UseStats"] = v_u_139.UseStats,
                                    ["Knockback"] = v_u_139.Knockback
                                })
                            end
                        end
                    end
                end
            else
                GlobalMoveset.Attack = originalAttack
            end
        end)
    end
})

-- === Godmode, No Knockback, etc. (Перенесено в BypassMainBox) ===
noKnockbackToggle = BypassMainBox:AddToggle("NoKnockbackToggle", {
    Text = "No Knockback",
    Default = false,
    Tooltip = "Prevents your character from being knocked back or ragdolled.",
    Callback = function(state)
        noKnockbackEnabled = state
        if noKnockbackConn then
            noKnockbackConn:Disconnect()
            noKnockbackConn = nil
        end
        pcall(function()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local MovesetHandler = require(ReplicatedStorage.Knit.Modules.MovesetHandler)
            if not originalKnockbackVelocity then
                originalKnockbackVelocity = MovesetHandler.KnockbackVelocity
            end
            if state then
                MovesetHandler.KnockbackVelocity = function(...) end
                -- Удаляем все BodyVelocity и BodyAngularVelocity кроме dash
                noKnockbackConn = game:GetService("RunService").RenderStepped:Connect(function()
                    local char = LocalPlayer.Character
                    if char then
                        local hrp = char:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            local hasJumpTrails = hrp:FindFirstChild("JumpTrails")
                            if not hasJumpTrails then
                                for _, obj in ipairs(hrp:GetChildren()) do
                                    if (obj:IsA("BodyVelocity") or obj:IsA("BodyAngularVelocity")) and not obj.Name:find("Dash") then
                                        obj:Destroy()
                                    end
                                end
                            end
                        end
                    end
                end)
            else
                MovesetHandler.KnockbackVelocity = originalKnockbackVelocity
                if noKnockbackConn then
                    noKnockbackConn:Disconnect()
                    noKnockbackConn = nil
                end
            end
        end)
    end
})


stopStunAnimsToggle = BypassMainBox:AddToggle("StopStunAnimsToggle", {
    Text = "Stop All Stun/Flinch Anims",
    Default = false,
    Tooltip = "Instantly stops all stun, flinch, and block animations.",
    Callback = function(state)
        stopStunAnimsEnabled = state
        pcall(function()
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local MovesetHandler = require(ReplicatedStorage.Knit.Modules.MovesetHandler)
            if not originalStopEssentialAnims then
                originalStopEssentialAnims = MovesetHandler.StopEssentialAnims
            end
            if state then
                MovesetHandler.StopEssentialAnims = function(char)
                    local hum = char:FindFirstChild("Humanoid")
                    if hum then
                        for _, track in hum.Animator:GetPlayingAnimationTracks() do
                            track:Stop(0)
                        end
                    end
                end
            else
                MovesetHandler.StopEssentialAnims = originalStopEssentialAnims
            end
        end)
    end
})


-- === Knockback Toggles (новая рабочая версия) - Перенесено в BypassMainBox ===
noKnockbackMeleeToggle = BypassMainBox:AddToggle("NoKnockbackMeleeToggle", {
    Text = "No Knockback (Melee Only)",
    Default = false,
    Tooltip = "Blocks knockback from normal attacks (BUGGY) For full protection enable normal no knockback'.",
    Callback = function(state)
        noKnockbackMeleeEnabled = state
        updateNoKnockbackPatch()
    end
})

function updateNoKnockbackPatch()
    -- Отключаем старый RenderStepped
    if noKnockbackConn then
        noKnockbackConn:Disconnect()
        noKnockbackConn = nil
    end
    -- Если оба выключены — возвращаем оригинал
    if not noKnockbackMeleeEnabled and not noKnockbackAllEnabled then
        MovesetHandler.KnockbackVelocity = originalKnockbackVelocity
        return
    end
    -- Патчим KnockbackVelocity
    MovesetHandler.KnockbackVelocity = function(p45, p46, p47)
        local char = LocalPlayer.Character
        if p45 and char and p45 == char then
            local force = tonumber(p46) or 0
            if noKnockbackAllEnabled then
                return -- Блокируем всё
            elseif noKnockbackMeleeEnabled and force > 0 and force <= 150 then
                return -- Блокируем только обычные удары
            else
                return originalKnockbackVelocity(p45, p46, p47)
            end
        else
            return originalKnockbackVelocity(p45, p46, p47)
        end
    end
    -- RenderStepped: удаляем BodyVelocity/BodyAngularVelocity
    noKnockbackConn = RunService.RenderStepped:Connect(function()
        local char = LocalPlayer.Character
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local hasJumpTrails = hrp:FindFirstChild("JumpTrails")
        for _, obj in ipairs(hrp:GetChildren()) do
            if (obj:IsA("BodyVelocity") or obj:IsA("BodyAngularVelocity")) and not obj.Name:find("Dash") then
                if not hasJumpTrails then
                    if noKnockbackAllEnabled then
                        obj:Destroy()
                    elseif noKnockbackMeleeEnabled then
                        local vel = obj.Velocity or obj.AngularVelocity or Vector3.new(0,0,0)
                        if vel.Magnitude <= 150 then
                            obj:Destroy()
                        end
                    end
                end
            end
        end
    end)
end

-- === Sound (Tengen) Skill Exploits ===
local soundSkillNoSlowEnabled = false
local soundSkillAnimSpeed = 1
local soundSkillVFXScale = {
    LoudAct = 1,
    MusicalScore = 1,
    Performance = 1,
    Resounding = 1
}
local soundSkillNoCDEnabled = false
local TagModule = require(game:GetService("ReplicatedStorage").Knit.Modules.TagModule)
local originalSkillCooldown = TagModule.Cooldown

local TengenBox = ExploitsTab:AddRightGroupbox("Tengen Exploits (MAY NOT WORK)")

soundSkillAnimSpeedSlider = TengenBox:AddSlider("SoundSkillAnimSpeedSlider", {
    Text = "Skill Animation Speed",
    Min = 0.5,
    Max = 3,
    Default = 1,
    Rounding = 2,
    Tooltip = "Adjusts animation speed for Sound skills.",
    Callback = function(val)
        soundSkillAnimSpeed = val
    end
})
loudActVFXScaleSlider = TengenBox:AddSlider("LoudActVFXScaleSlider", {
    Text = "LoudAct VFX Scale",
    Min = 1,
    Max = 5,
    Default = 1,
    Rounding = 1,
    Tooltip = "VFX scale for LoudAct skill.",
    Callback = function(val)
        soundSkillVFXScale.LoudAct = val
    end
})
musicalScoreVFXScaleSlider = TengenBox:AddSlider("MusicalScoreVFXScaleSlider", {
    Text = "MusicalScore VFX Scale",
    Min = 1,
    Max = 5,
    Default = 1,
    Rounding = 1,
    Tooltip = "VFX scale for MusicalScore skill.",
    Callback = function(val)
        soundSkillVFXScale.MusicalScore = val
    end
})
performanceVFXScaleSlider = TengenBox:AddSlider("PerformanceVFXScaleSlider", {
    Text = "Performance VFX Scale",
    Min = 1,
    Max = 5,
    Default = 1,
    Rounding = 1,
    Tooltip = "VFX scale for Performance skill.",
    Callback = function(val)
        soundSkillVFXScale.Performance = val
    end
})
resoundingVFXScaleSlider = TengenBox:AddSlider("ResoundingVFXScaleSlider", {
    Text = "Resounding VFX Scale",
    Min = 1,
    Max = 5,
    Default = 1,
    Rounding = 1,
    Tooltip = "VFX scale for Resounding skill.",
    Callback = function(val)
        soundSkillVFXScale.Resounding = val
    end
})
soundLoudActAutoAimToggle = TengenBox:AddToggle("SoundLoudActAutoAimToggle", {
    Text = "LoudAct Auto-Aim",
    Default = false,
    Tooltip = "Automatically aims LoudAct throws at the nearest enemy.",
    Callback = function(state)
        soundLoudActAutoAimEnabled = state
    end
})
soundSkillRealRangeToggle = TengenBox:AddToggle("SoundSkillRealRangeToggle", {
    Text = "Sound Skills: Real Range+",
    Default = false,
    Tooltip = "Increases real hit/area range for Sound skills (LoudAct, Performance, MusicalScore, Resounding).",
    Callback = function(state)
        soundSkillRealRangeEnabled = state
    end
})

-- Реализация патчей для Sound Skills
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local soundSkillConn = nil
if soundSkillConn then soundSkillConn:Disconnect() end
soundSkillConn = RunService.RenderStepped:Connect(function()
    local char = LocalPlayer.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hum then return end
    for _, track in ipairs(hum.Animator:GetPlayingAnimationTracks()) do
        -- No Slow: если активна анимация скилла, выставляем WalkSpeed = 10
        if soundSkillNoSlowEnabled and (
            track.Name:find("LoudAct") or track.Name:find("MusicalScore") or track.Name:find("Performance") or track.Name:find("Resounding")
        ) then
            hum.WalkSpeed = 10
        end
        -- Skill Animation Speed: ускоряем анимацию
        if (
            track.Name:find("LoudAct") or track.Name:find("MusicalScore") or track.Name:find("Performance") or track.Name:find("Resounding")
        ) then
            track:AdjustSpeed(soundSkillAnimSpeed)
        end
    end
end)

-- Патчируем создание VFX для увеличения масштаба
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Knit = require(ReplicatedStorage.Knit.Packages.Knit)

local function patchVFXScale(controllerName, skillKey)
    local success, controller = pcall(function()
        return Knit.GetController(controllerName)
    end)
    if success and controller and controller.Effect then
        -- Сохраняем оригинальную функцию Connect
        if not controller._originalConnect then
            controller._originalConnect = controller.Effect.Connect
        end
        
        -- Патчим Connect только если еще не патчили
        if not controller._VFXScalePatched then
            controller._VFXScalePatched = true
            controller.Effect.Connect = function(callback)
                return controller._originalConnect(function(p1, p2, p3)
                    -- Патчим VFX объекты
                    if p2 then
                        for _, obj in ipairs(p2:GetDescendants()) do
                            if obj:IsA("BasePart") or obj:IsA("ParticleEmitter") then
                                if obj.Size then
                                    obj.Size = obj.Size * (soundSkillVFXScale[skillKey] or 1)
                                end
                                if obj.Scale then
                                    obj.Scale = obj.Scale * (soundSkillVFXScale[skillKey] or 1)
                                end
                            end
                        end
                    end
                    callback(p1, p2, p3)
                end)
            end
        end
    end
end

patchVFXScale("LoudActController", "LoudAct")
patchVFXScale("MusicalScoreController", "MusicalScore")
patchVFXScale("PerformanceController", "Performance")
patchVFXScale("ResoundingController", "Resounding")

-- Удаляем No Skill Cooldown (Sound)
soundSkillNoCDEnabled = nil
if StyleBox.Flags and StyleBox.Flags.SoundSkillNoCDToggle then
    StyleBox.Flags.SoundSkillNoCDToggle = nil
end
TagModule.Cooldown = originalSkillCooldown

-- Патч LoudAct: автонаведение бросков
local function patchLoudActAutoAim()
    local success, controller = pcall(function()
        return Knit.GetController("LoudActController")
    end)
    if success and controller and controller.Effect then
        -- Сохраняем оригинальную функцию Connect
        if not controller._originalLoudActConnect then
            controller._originalLoudActConnect = controller.Effect.Connect
        end
        
        -- Патчим Connect только если еще не патчили
        if not controller._AutoAimPatched then
            controller._AutoAimPatched = true
            controller.Effect.Connect = function(callback)
                return controller._originalLoudActConnect(function(p15, p_u_16, p17)
                    if soundLoudActAutoAimEnabled and p15 == "Throw" and p_u_16 and p17 then
                        local myChar = game.Players.LocalPlayer.Character
                        if myChar and myChar == p_u_16 then
                            local hrp = myChar:FindFirstChild("HumanoidRootPart")
                            local target = getNearestEnemyModel(hrp.Position, 100)
                            if target and target:FindFirstChild("HumanoidRootPart") then
                                for _, v_u_26 in ipairs(p17) do
                                    v_u_26.Position = target.HumanoidRootPart.Position + Vector3.new(0,2,0)
                                end
                            end
                        end
                    end
                    callback(p15, p_u_16, p17)
                end)
            end
        end
    end
end
patchLoudActAutoAim()

-- Патч увеличения реального радиуса/дальности урона для Sound Skills
local function patchSoundSkillRealRange()
    local function patchController(controllerName, skillKey)
        local success, controller = pcall(function()
            return Knit.GetController(controllerName)
        end)
        if success and controller and controller.Effect then
            -- Сохраняем оригинальную функцию Connect
            if not controller["_originalConnect_"..skillKey] then
                controller["_originalConnect_"..skillKey] = controller.Effect.Connect
            end
            
            -- Патчим Connect только если еще не патчили
            if not controller["_RealRangePatched_"..skillKey] then
                controller["_RealRangePatched_"..skillKey] = true
                controller.Effect.Connect = function(callback)
                    return controller["_originalConnect_"..skillKey](function(p1, p2, p3)
                        if soundSkillRealRangeEnabled and p2 then
                            for _, obj in ipairs(p2:GetDescendants()) do
                                if obj:IsA("BasePart") and obj.Name:find("Hitbox") then
                                    obj.Size = obj.Size * 2 -- Увеличиваем реальный hitbox в 2 раза
                                end
                            end
                        end
                        callback(p1, p2, p3)
                    end)
                end
            end
        end
    end
    patchController("LoudActController", "LoudAct")
    patchController("MusicalScoreController", "MusicalScore")
    patchController("PerformanceController", "Performance")
    patchController("ResoundingController", "Resounding")
end
patchSoundSkillRealRange()

-- === Fast Skill Toggles ===
local fastAirTypeEnabled = false
local fastFreshCleaveEnabled = false
local fastPoisonVeinEnabled = false
local fastRampantArcEnabled = false
local fastFlyingSickleEnabled = false

fastFlyingSickleToggle = StyleBox:AddToggle("FastFlyingSickleToggle", {
    Text = "Fast FlyingSickle (Gyutaro)",
    Default = false,
    Tooltip = "Makes Gyutaro's FlyingSickle skill play almost instantly.",
    Callback = function(state)
        fastFlyingSickleEnabled = state
    end
})

-- === Fast Skill Animation Patches ===
local function patchFastSkillAnimations()
    -- Akaza AirType
    local successAkaza, AirTypeController = pcall(function()
        return require(ReplicatedStorage.Knit.Controllers.MoveControllers.Akaza.AirTypeController)
    end)
    if successAkaza and AirTypeController then
        local origAkazaKnitStart = AirTypeController.KnitStart
        AirTypeController.KnitStart = function(self, ...)
            origAkazaKnitStart(self, ...)
            local Knit = require(ReplicatedStorage.Knit.Packages.Knit)
            local AirTypeService = Knit.GetService("AirTypeService")
            if AirTypeService and AirTypeService.Effect then
                AirTypeService.Effect:Connect(function(p15, p16)
                    if (p15 == "Start" and fastAirTypeEnabled) or (p15 == "Shoot" and fastAirTypeEnabled) then
                        local char = p16.Character
                        if char then
                            local hum = char:FindFirstChild("Humanoid")
                            if hum then
                                for _, track in ipairs(hum.Animator:GetPlayingAnimationTracks()) do
                                    track:AdjustSpeed(10)
                                end
                            end
                        end
                    end
                end)
            end
        end
    end
    -- FreshCleave
    local successFC, FreshCleaveController = pcall(function()
        return require(ReplicatedStorage.Knit.Controllers.MoveControllers.Gyutaro.FreshCleaveController)
    end)
    if successFC and FreshCleaveController then
        local origFCKnitStart = FreshCleaveController.KnitStart
        FreshCleaveController.KnitStart = function(self, ...)
            origFCKnitStart(self, ...)
            local Knit = require(ReplicatedStorage.Knit.Packages.Knit)
            local FreshCleaveService = Knit.GetService("FreshCleaveService")
            if FreshCleaveService and FreshCleaveService.Effect then
                FreshCleaveService.Effect:Connect(function(p18, p19)
                    if (p18 == "Start" and fastFreshCleaveEnabled) or (p18 == "Shoot" and fastFreshCleaveEnabled) then
                        local char = p19.Character or p19
                        if char then
                            local hum = char:FindFirstChild("Humanoid")
                            if hum then
                                for _, track in ipairs(hum.Animator:GetPlayingAnimationTracks()) do
                                    track:AdjustSpeed(10)
                                end
                            end
                        end
                    end
                end)
            end
        end
    end
    -- PoisonVein
    local successPV, PoisonVeinController = pcall(function()
        return require(ReplicatedStorage.Knit.Controllers.MoveControllers.Gyutaro.PoisonVeinController)
    end)
    if successPV and PoisonVeinController then
        local origPVKnitStart = PoisonVeinController.KnitStart
        PoisonVeinController.KnitStart = function(self, ...)
            origPVKnitStart(self, ...)
            local Knit = require(ReplicatedStorage.Knit.Packages.Knit)
            local PoisonVeinService = Knit.GetService("PoisonVeinService")
            if PoisonVeinService and PoisonVeinService.Effect then
                PoisonVeinService.Effect:Connect(function(p13, p14)
                    if (p13 == "Start" and fastPoisonVeinEnabled) or (p13 == "Shoot" and fastPoisonVeinEnabled) then
                        local char = p14.Character or p14
                        if char then
                            local hum = char:FindFirstChild("Humanoid")
                            if hum then
                                for _, track in ipairs(hum.Animator:GetPlayingAnimationTracks()) do
                                    track:AdjustSpeed(10)
                                end
                            end
                        end
                    end
                end)
            end
        end
    end
    -- RampantArc
    local successRA, RampantArcController = pcall(function()
        return require(ReplicatedStorage.Knit.Controllers.MoveControllers.Gyutaro.RampantArcController)
    end)
    if successRA and RampantArcController then
        local origRAKnitStart = RampantArcController.KnitStart
        RampantArcController.KnitStart = function(self, ...)
            origRAKnitStart(self, ...)
            local Knit = require(ReplicatedStorage.Knit.Packages.Knit)
            local RampantArcService = Knit.GetService("RampantArcService")
            if RampantArcService and RampantArcService.Effect then
                RampantArcService.Effect:Connect(function(p13, p14)
                    if (p13 == "Start" and fastRampantArcEnabled) or (p13 == "Shoot" and fastRampantArcEnabled) then
                        local char = p14.Character or p14
                        if char then
                            local hum = char:FindFirstChild("Humanoid")
                            if hum then
                                for _, track in ipairs(hum.Animator:GetPlayingAnimationTracks()) do
                                    track:AdjustSpeed(10)
                                end
                            end
                        end
                    end
                end)
            end
        end
    end
    -- FlyingSickleController
    local successFS, FlyingSickleController = pcall(function()
        return require(ReplicatedStorage.Knit.Controllers.MoveControllers.Gyutaro.FlyingSickleController)
    end)
    if successFS and FlyingSickleController then
        local origFSKnitStart = FlyingSickleController.KnitStart
        FlyingSickleController.KnitStart = function(self, ...)
            origFSKnitStart(self, ...)
            local Knit = require(ReplicatedStorage.Knit.Packages.Knit)
            local EmitController = require(ReplicatedStorage.Knit.Modules.EmitController)
            if EmitController and EmitController.Effect then
                EmitController.Effect:Connect(function(p15, p16)
                    if ((p15 == "Start" or p15 == "Shoot") and fastFlyingSickleEnabled) then
                        local char = p16.Character
                        if char then
                            local hum = char:FindFirstChild("Humanoid")
                            if hum then
                                for _, track in ipairs(hum.Animator:GetPlayingAnimationTracks()) do
                                    track:AdjustSpeed(10)
                                end
                            end
                        end
                    end
                end)
            end
        end
    end
end
patchFastSkillAnimations()

-- === MultiCast Moves Exploit ===
local multiCastMovesEnabled = false
CombatExploitsBox:AddToggle("MultiCastMovesToggle", {
    Text = "Multi-Cast Moves",
    Default = false,
    Tooltip = "Casts each move several times per press (may work only if server is not strict)",
    Callback = function(state)
        multiCastMovesEnabled = state
    end
})

-- Патч UseMove:Fire для мульти-каста
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Knit = require(ReplicatedStorage.Knit.Packages.Knit)
local MoveController = Knit.GetController("MoveController")
local originalUseMoveFire = nil
if MoveController and MoveController.UseMove and MoveController.UseMove.Fire then
    originalUseMoveFire = MoveController.UseMove.Fire
    MoveController.UseMove.Fire = function(self, ...)
        if multiCastMovesEnabled then
            for i = 1, 3 do -- 3 раза подряд
                originalUseMoveFire(self, ...)
                task.wait(0.05)
            end
        else
            originalUseMoveFire(self, ...)
        end
    end
end

-- === Auto QE Win Exploit ===
local autoQEWinEnabled = false
autoQEWinToggle = CombatExploitsBox:AddToggle("AutoQEWinToggle", {
    Text = "Auto QE Win",
    Default = false,
    Tooltip = "Automatically clicks in Quick Event (Clash) for instant win.",
    Callback = function(state)
        autoQEWinEnabled = state
    end
})

local QEController = nil
pcall(function()
    QEController = Knit.GetController("QEController")
end)
local CharacterDataModule = require(ReplicatedStorage.Knit.Modules.Data.CharacterData)
local RunService = game:GetService("RunService")
local autoQEConn = nil
if autoQEConn then autoQEConn:Disconnect() end
autoQEConn = RunService.Heartbeat:Connect(function()
    if autoQEWinEnabled and QEController and QEController.Click then
        local data = CharacterDataModule.GetDataSoft and CharacterDataModule.GetDataSoft() or CharacterDataModule.GetData()
        if data and data.InQE then
            QEController:Click()
        end
    end
end)

-- === Новая вкладка Settings ===
local SettingsTab = Window:AddTab("Settings", "settings")
local ThemeBox = SettingsTab:AddLeftGroupbox("UI Theme")
local ConfigBox = SettingsTab:AddRightGroupbox("Config")

-- === Темы ===
local themes = {
    night = {
        MainColor = Color3.fromRGB(25, 25, 25),
        AccentColor = Color3.fromRGB(125, 85, 255),
        BackgroundColor = Color3.fromRGB(15, 15, 15),
        FontColor = Color3.new(1, 1, 1),
    },
    blood = {
        MainColor = Color3.fromRGB(40, 0, 0),
        AccentColor = Color3.fromRGB(200, 0, 0),
        BackgroundColor = Color3.fromRGB(15, 0, 0),
        FontColor = Color3.new(1, 0.8, 0.8),
    },
    blue = {
        MainColor = Color3.fromRGB(20, 20, 40),
        AccentColor = Color3.fromRGB(80, 120, 255),
        BackgroundColor = Color3.fromRGB(10, 10, 30),
        FontColor = Color3.fromRGB(200, 220, 255),
    },
    green = {
        MainColor = Color3.fromRGB(20, 40, 20),
        AccentColor = Color3.fromRGB(80, 255, 120),
        BackgroundColor = Color3.fromRGB(10, 30, 10),
        FontColor = Color3.fromRGB(220, 255, 200),
    },
    white = {
        MainColor = Color3.fromRGB(220, 220, 220),
        AccentColor = Color3.fromRGB(125, 85, 255),
        BackgroundColor = Color3.fromRGB(245, 245, 245),
        FontColor = Color3.fromRGB(30, 30, 30),
    },
}
local themeNames = {}
for name, _ in pairs(themes) do table.insert(themeNames, name) end
local defaultTheme = "night"
local currentTheme = defaultTheme
local function applyTheme(themeName)
    local theme = themes[themeName:lower()]
    if not theme then
        Library:Notify("Theme '"..themeName.."' not found! Using default.")
        theme = themes[defaultTheme]
        currentTheme = defaultTheme
    else
        currentTheme = themeName:lower()
    end
    -- Сначала применяем пресет
    Library.Scheme.MainColor = theme.MainColor
    Library.Scheme.AccentColor = theme.AccentColor
    Library.Scheme.BackgroundColor = theme.BackgroundColor
    Library.Scheme.FontColor = theme.FontColor
    -- Если кастомные цвета включены, они имеют приоритет
    if ThemeBox.Flags then
        if ThemeBox.Flags.CustomMainColorToggle and ThemeBox.Flags.CustomMainColorToggle.Value and customColors.Main then
            Library.Scheme.MainColor = customColors.Main
        end
        if ThemeBox.Flags.CustomAccentColorToggle and ThemeBox.Flags.CustomAccentColorToggle.Value and customColors.Accent then
            Library.Scheme.AccentColor = customColors.Accent
        end
        if ThemeBox.Flags.CustomBackgroundColorToggle and ThemeBox.Flags.CustomBackgroundColorToggle.Value and customColors.Background then
            Library.Scheme.BackgroundColor = customColors.Background
        end
        if ThemeBox.Flags.CustomFontColorToggle and ThemeBox.Flags.CustomFontColorToggle.Value and customColors.Font then
            Library.Scheme.FontColor = customColors.Font
        end
    end
    Library:UpdateColorsUsingRegistry()
end

ThemeBox:AddDropdown("ThemeDropdown", {
    Text = "Theme",
    Values = themeNames,
    Default = currentTheme,
    Callback = function(val)
        applyTheme(val)
    end
})

ThemeBox:AddDivider()
ThemeBox:AddLabel("Custom Colors")

local customColors = {
    Main = nil,
    Accent = nil,
    Background = nil,
    Font = nil
}

local MainColorToggle = ThemeBox:AddToggle("CustomMainColorToggle", {
    Text = "Custom Main Color",
    Default = false,
    Callback = function(state)
        if not state then
            customColors.Main = nil
            applyTheme(currentTheme)
        end
    end
})
MainColorToggle:AddColorPicker("CustomMainColor", {
    Default = Library.Scheme.MainColor,
    Title = "Main Color",
    Callback = function(val)
        customColors.Main = val
        Library.Scheme.MainColor = val
        Library:UpdateColorsUsingRegistry()
    end
})

local AccentColorToggle = ThemeBox:AddToggle("CustomAccentColorToggle", {
    Text = "Custom Accent Color",
    Default = false,
    Callback = function(state)
        if not state then
            customColors.Accent = nil
            applyTheme(currentTheme)
        end
    end
})
AccentColorToggle:AddColorPicker("CustomAccentColor", {
    Default = Library.Scheme.AccentColor,
    Title = "Accent Color",
    Callback = function(val)
        customColors.Accent = val
        Library.Scheme.AccentColor = val
        Library:UpdateColorsUsingRegistry()
    end
})

local BackgroundColorToggle = ThemeBox:AddToggle("CustomBackgroundColorToggle", {
    Text = "Custom Background Color",
    Default = false,
    Callback = function(state)
        if not state then
            customColors.Background = nil
            applyTheme(currentTheme)
        end
    end
})
BackgroundColorToggle:AddColorPicker("CustomBackgroundColor", {
    Default = Library.Scheme.BackgroundColor,
    Title = "Background Color",
    Callback = function(val)
        customColors.Background = val
        Library.Scheme.BackgroundColor = val
        Library:UpdateColorsUsingRegistry()
    end
})

local FontColorToggle = ThemeBox:AddToggle("CustomFontColorToggle", {
    Text = "Custom Font Color",
    Default = false,
    Callback = function(state)
        if not state then
            customColors.Font = nil
            applyTheme(currentTheme)
        end
    end
})
FontColorToggle:AddColorPicker("CustomFontColor", {
    Default = Library.Scheme.FontColor,
    Title = "Font Color",
    Callback = function(val)
        customColors.Font = val
        Library.Scheme.FontColor = val
        Library:UpdateColorsUsingRegistry()
    end
})

-- === Конфиги ===
local configFolder = "INVHubMugen"
local configExt = ".json"
if not isfolder(configFolder) then makefolder(configFolder) end
local function getConfigs()
    local files = listfiles(configFolder)
    local configs = {}
    for _, file in ipairs(files) do
        if file:sub(-#configExt) == configExt then
            table.insert(configs, file:match("([^/\\]+)%"..configExt.."$") )
        end
    end
    table.sort(configs)
    return configs
end

-- === saveConfig ===
local function safeSet(toggle, value)
    if not toggle then return end
    if typeof(toggle.SetValue) == "function" then
        toggle:SetValue(value)
    elseif typeof(toggle.Set) == "function" then
        toggle:Set(value)
    elseif toggle.Value ~= nil then
        toggle.Value = value
    end
end

local function saveConfig(name)
    local data = { Theme = currentTheme }
    data.NoStun = noStunToggle and noStunToggle.Value or false
    data.AutoBlock = autoBlockToggle and autoBlockToggle.Value or false
    data.AntiHitbox = antiHitboxToggle and antiHitboxToggle.Value or false
    data.ESPPlayers = espPlayersToggle and espPlayersToggle.Value or false
    data.ESPDistance = espDistanceSlider and espDistanceSlider.Value or 400.5
    data.HidePostureBar = hidePostureBarToggle and hidePostureBarToggle.Value or false
    data.HideParryBar = hideParryBarToggle and hideParryBarToggle.Value or false
    data.GyutaroAutoAim = gyutaroAutoAimToggle and gyutaroAutoAimToggle.Value or false
    data.GyutaroMultiThrow = gyutaroMultiThrowToggle and gyutaroMultiThrowToggle.Value or false
    data.GyutaroMultiThrowCount = gyutaroMultiThrowCountSlider and gyutaroMultiThrowCountSlider.Value or 3
    data.GyutaroAutoTarget = gyutaroAutoTargetToggle and gyutaroAutoTargetToggle.Value or false
    data.GyutaroAutoTargetRadius = gyutaroAutoTargetRadiusSlider and gyutaroAutoTargetRadiusSlider.Value or 60
    data.AkazaAirControl = akazaAirControlToggle and akazaAirControlToggle.Value or false
    data.AntiBleed = antiBleedToggle and antiBleedToggle.Value or false
    data.AntiPoison = antiPoisonToggle and antiPoisonToggle.Value or false
    data.AntiSlow = antiSlowToggle and antiSlowToggle.Value or false
    data.AntiRoot = antiRootToggle and antiRootToggle.Value or false
    data.AntiFreeze = antiFreezeToggle and antiFreezeToggle.Value or false
    data.AntiStun = antiStunToggle and antiStunToggle.Value or false
    data.AntiCombatTag = antiCombatTagToggle and antiCombatTagToggle.Value or false
    data.AttackAnyStatus = attackAnyStatusToggle and attackAnyStatusToggle.Value or false
    data.FastHeavyClash = fastHeavyClashToggle and fastHeavyClashToggle.Value or false
    data.HeavyClashCooldown = heavyClashCooldownSlider and heavyClashCooldownSlider.Value or 1
    data.RemoveMovementLimits = removeMovementLimitsToggle and removeMovementLimitsToggle.Value or false
    data.AttackSpeed = attackSpeedSlider and attackSpeedSlider.Value or 10
    data.PunchStunSpeed = punchStunSpeedSlider and punchStunSpeedSlider.Value or 10
    data.HardStunSpeed = hardStunSpeedSlider and hardStunSpeedSlider.Value or 4
    data.StunSpeed = stunSpeedSlider and stunSpeedSlider.Value or 4
    data.BlockingSpeed = blockingSpeedSlider and blockingSpeedSlider.Value or 2
    data.KnockedSpeed = knockedSpeedSlider and knockedSpeedSlider.Value or 0
    data.AutoRemoveKnocked = autoRemoveKnockedToggle and autoRemoveKnockedToggle.Value or false
    data.DashTowardsCamera = dashTowardsCameraToggle and dashTowardsCameraToggle.Value or false
    data.FrontDashAmount = frontDashAmountInput and tonumber(frontDashAmountInput.Value) or 95
    data.BackDashAmount = backDashAmountInput and tonumber(backDashAmountInput.Value) or 110
    data.LeftDashAmount = leftDashAmountInput and tonumber(leftDashAmountInput.Value) or 130
    data.RightDashAmount = rightDashAmountInput and tonumber(rightDashAmountInput.Value) or 130
    data.NoDashCooldown = noDashCooldownToggle and noDashCooldownToggle.Value or false
    data.NoAttackCooldown = noAttackCooldownToggle and noAttackCooldownToggle.Value or false
    data.NoJumpCooldown = noJumpCooldownToggle and noJumpCooldownToggle.Value or false
    data.NoHeavyAttackCooldown = noHeavyAttackCooldownToggle and noHeavyAttackCooldownToggle.Value or false
    data.UniversalAttack = universalAttackToggle and universalAttackToggle.Value or false
    data.ForceBlock = forceBlockToggle and forceBlockToggle.Value or false
    data.CustomAttackRange = customAttackRangeToggle and customAttackRangeToggle.Value or false
    data.CustomAttackRangeValue = customAttackRangeSlider and customAttackRangeSlider.Value or 20
    data.CustomAttackFarAmount = customAttackFarAmountSlider and customAttackFarAmountSlider.Value or 70
    data.CustomAttackCloseAmount = customAttackCloseAmountSlider and customAttackCloseAmountSlider.Value or 90
    data.CustomAttackCloseUpRange = customAttackCloseUpRangeSlider and customAttackCloseUpRangeSlider.Value or 10
    data.CustomAttackTooFarRange = customAttackTooFarRangeSlider and customAttackTooFarRangeSlider.Value or 120
    data.InfinitePosture = infinitePostureToggle and infinitePostureToggle.Value or false
    data.InfiniteJumps = infiniteJumpsToggle and infiniteJumpsToggle.Value or false
    data.FastRunKey = fastRunKeyDropdown and fastRunKeyDropdown.Value or "E"
    data.FastRunAlwaysOn = fastRunAlwaysOnToggle and fastRunAlwaysOnToggle.Value or false
    data.FastRun = fastRunToggle and fastRunToggle.Value or false
    data.InstantAttack = instantAttackToggle and instantAttackToggle.Value or false
    data.NoKnockback = noKnockbackToggle and noKnockbackToggle.Value or false
    data.StopStunAnims = stopStunAnimsToggle and stopStunAnimsToggle.Value or false
    data.NoKnockbackMelee = noKnockbackMeleeToggle and noKnockbackMeleeToggle.Value or false
    data.SoundSkillNoSlow = soundSkillNoSlowToggle and soundSkillNoSlowToggle.Value or false
    data.SoundLoudActAutoAim = soundLoudActAutoAimToggle and soundLoudActAutoAimToggle.Value or false
    data.SoundSkillRealRange = soundSkillRealRangeToggle and soundSkillRealRangeToggle.Value or false
    data.LoudActVFXScale = loudActVFXScaleSlider and loudActVFXScaleSlider.Value or 1
    data.MusicalScoreVFXScale = musicalScoreVFXScaleSlider and musicalScoreVFXScaleSlider.Value or 1
    data.PerformanceVFXScale = performanceVFXScaleSlider and performanceVFXScaleSlider.Value or 1
    data.ResoundingVFXScale = resoundingVFXScaleSlider and resoundingVFXScaleSlider.Value or 1
    data.FastFlyingSickle = fastFlyingSickleToggle and fastFlyingSickleToggle.Value or false
    data.MultiCastMoves = multiCastMovesToggle and multiCastMovesToggle.Value or false
    data.AutoQEWin = autoQEWinToggle and autoQEWinToggle.Value or false
    data.Moveset = movesetDropdown and movesetDropdown.Value or "Default"
    data.CustomColors = {Main = customColors.Main, Accent = customColors.Accent, Background = customColors.Background, Font = customColors.Font}
    data.CustomColorToggles = {
        Main = ThemeBox.Flags and ThemeBox.Flags.CustomMainColorToggle and ThemeBox.Flags.CustomMainColorToggle.Value or false,
        Accent = ThemeBox.Flags and ThemeBox.Flags.CustomAccentColorToggle and ThemeBox.Flags.CustomAccentColorToggle.Value or false,
        Background = ThemeBox.Flags and ThemeBox.Flags.CustomBackgroundColorToggle and ThemeBox.Flags.CustomBackgroundColorToggle.Value or false,
        Font = ThemeBox.Flags and ThemeBox.Flags.CustomFontColorToggle and ThemeBox.Flags.CustomFontColorToggle.Value or false
    }
    data.ShowDisplayNick = showDisplayNickToggle and showDisplayNickToggle.Value or false
    data.ShowRealNick = showRealNickToggle and showRealNickToggle.Value or true
    -- === Auto Block Settings ===
    data.AutoBlockReleaseTime = AUTO_BLOCK_RELEASE_TIME
    data.AutoBlockIgnoreTime = AUTO_BLOCK_IGNORE_TIME
    data.AutoBlockAnimFlags = _G.AutoBlockAnimFlags or {}
    writefile(configFolder.."/"..name..configExt, game:GetService("HttpService"):JSONEncode(data))
    Library:Notify("Config saved: "..name)
    print("[Config] Saving config with AttackSpeed:", attackSpeedSlider and attackSpeedSlider.Value)
    print("[Config] Saving config with PunchStunSpeed:", punchStunSpeedSlider and punchStunSpeedSlider.Value)
end

local function loadConfig(name)
    local filePath = configFolder.."/"..name..configExt
    if not isfile(filePath) then
        Library:Notify("Config not found: "..name)
        return
    end
    local success, data = pcall(function()
        local content = readfile(filePath)
        return game:GetService("HttpService"):JSONDecode(content)
    end)
    if not success then
        Library:Notify("Failed to load config: "..(data or "Unknown error"))
        return
    end
    -- Сбросить все тогглы и слайдеры (вызывая safeSet)
    safeSet(noStunToggle, false)
    safeSet(autoBlockToggle, false)
    safeSet(antiHitboxToggle, false)
    safeSet(espPlayersToggle, false)
    safeSet(hidePostureBarToggle, false)
    safeSet(hideParryBarToggle, false)
    safeSet(gyutaroAutoAimToggle, false)
    safeSet(gyutaroMultiThrowToggle, false)
    safeSet(gyutaroAutoTargetToggle, false)
    safeSet(akazaAirControlToggle, false)
    safeSet(antiBleedToggle, false)
    safeSet(antiPoisonToggle, false)
    safeSet(antiSlowToggle, false)
    safeSet(antiRootToggle, false)
    safeSet(antiFreezeToggle, false)
    safeSet(antiStunToggle, false)
    safeSet(antiCombatTagToggle, false)
    safeSet(attackAnyStatusToggle, false)
    safeSet(fastHeavyClashToggle, false)
    safeSet(removeMovementLimitsToggle, false)
    safeSet(autoRemoveKnockedToggle, false)
    safeSet(dashTowardsCameraToggle, false)
    safeSet(noDashCooldownToggle, false)
    safeSet(noAttackCooldownToggle, false)
    safeSet(noJumpCooldownToggle, false)
    safeSet(noHeavyAttackCooldownToggle, false)
    safeSet(universalAttackToggle, false)
    safeSet(forceBlockToggle, false)
    safeSet(customAttackRangeToggle, false)
    safeSet(infinitePostureToggle, false)
    safeSet(infiniteJumpsToggle, false)
    safeSet(fastRunAlwaysOnToggle, false)
    safeSet(fastRunToggle, false)
    safeSet(instantAttackToggle, false)
    safeSet(noKnockbackToggle, false)
    safeSet(stopStunAnimsToggle, false)
    safeSet(noKnockbackMeleeToggle, false)
    safeSet(soundSkillNoSlowToggle, false)
    safeSet(soundLoudActAutoAimToggle, false)
    safeSet(soundSkillRealRangeToggle, false)
    safeSet(fastFlyingSickleToggle, false)
    safeSet(multiCastMovesToggle, false)
    safeSet(autoQEWinToggle, false)
    -- Применить тему
    if data.Theme then applyTheme(data.Theme) end
    -- Восстановить значения (вызывая safeSet)
    safeSet(noStunToggle, data.NoStun)
    safeSet(autoBlockToggle, data.AutoBlock)
    safeSet(antiHitboxToggle, data.AntiHitbox)
    safeSet(espPlayersToggle, data.ESPPlayers)
    if espDistanceSlider then safeSet(espDistanceSlider, data.ESPDistance or 400.5) end
    safeSet(hidePostureBarToggle, data.HidePostureBar)
    safeSet(hideParryBarToggle, data.HideParryBar)
    safeSet(gyutaroAutoAimToggle, data.GyutaroAutoAim)
    safeSet(gyutaroMultiThrowToggle, data.GyutaroMultiThrow)
    if gyutaroMultiThrowCountSlider then safeSet(gyutaroMultiThrowCountSlider, data.GyutaroMultiThrowCount or 3) end
    safeSet(gyutaroAutoTargetToggle, data.GyutaroAutoTarget)
    if gyutaroAutoTargetRadiusSlider then safeSet(gyutaroAutoTargetRadiusSlider, data.GyutaroAutoTargetRadius or 60) end
    safeSet(akazaAirControlToggle, data.AkazaAirControl)
    safeSet(antiBleedToggle, data.AntiBleed)
    safeSet(antiPoisonToggle, data.AntiPoison)
    safeSet(antiSlowToggle, data.AntiSlow)
    safeSet(antiRootToggle, data.AntiRoot)
    safeSet(antiFreezeToggle, data.AntiFreeze)
    safeSet(antiStunToggle, data.AntiStun)
    safeSet(antiCombatTagToggle, data.AntiCombatTag)
    safeSet(attackAnyStatusToggle, data.AttackAnyStatus)
    safeSet(fastHeavyClashToggle, data.FastHeavyClash)
    if heavyClashCooldownSlider then safeSet(heavyClashCooldownSlider, data.HeavyClashCooldown or 1) end
    safeSet(removeMovementLimitsToggle, data.RemoveMovementLimits)
    if attackSpeedSlider then safeSet(attackSpeedSlider, data.AttackSpeed or 10) end
    if punchStunSpeedSlider then safeSet(punchStunSpeedSlider, data.PunchStunSpeed or 10) end
    if hardStunSpeedSlider then safeSet(hardStunSpeedSlider, data.HardStunSpeed or 4) end
    if stunSpeedSlider then safeSet(stunSpeedSlider, data.StunSpeed or 4) end
    if blockingSpeedSlider then safeSet(blockingSpeedSlider, data.BlockingSpeed or 2) end
    if knockedSpeedSlider then safeSet(knockedSpeedSlider, data.KnockedSpeed or 0) end
    safeSet(autoRemoveKnockedToggle, data.AutoRemoveKnocked)
    safeSet(dashTowardsCameraToggle, data.DashTowardsCamera)
    if frontDashAmountInput then safeSet(frontDashAmountInput, tostring(data.FrontDashAmount or 95)) end
    if backDashAmountInput then safeSet(backDashAmountInput, tostring(data.BackDashAmount or 110)) end
    if leftDashAmountInput then safeSet(leftDashAmountInput, tostring(data.LeftDashAmount or 130)) end
    if rightDashAmountInput then safeSet(rightDashAmountInput, tostring(data.RightDashAmount or 130)) end
    safeSet(noDashCooldownToggle, data.NoDashCooldown)
    safeSet(noAttackCooldownToggle, data.NoAttackCooldown)
    safeSet(noJumpCooldownToggle, data.NoJumpCooldown)
    safeSet(noHeavyAttackCooldownToggle, data.NoHeavyAttackCooldown)
    safeSet(universalAttackToggle, data.UniversalAttack)
    safeSet(forceBlockToggle, data.ForceBlock)
    safeSet(customAttackRangeToggle, data.CustomAttackRange)
    if customAttackRangeSlider then safeSet(customAttackRangeSlider, data.CustomAttackRangeValue or 20) end
    if customAttackFarAmountSlider then safeSet(customAttackFarAmountSlider, data.CustomAttackFarAmount or 70) end
    if customAttackCloseAmountSlider then safeSet(customAttackCloseAmountSlider, data.CustomAttackCloseAmount or 90) end
    if customAttackCloseUpRangeSlider then safeSet(customAttackCloseUpRangeSlider, data.CustomAttackCloseUpRange or 10) end
    if customAttackTooFarRangeSlider then safeSet(customAttackTooFarRangeSlider, data.CustomAttackTooFarRange or 120) end
    safeSet(infinitePostureToggle, data.InfinitePosture)
    safeSet(infiniteJumpsToggle, data.InfiniteJumps)
    if fastRunKeyDropdown then safeSet(fastRunKeyDropdown, data.FastRunKey or "E") end
    safeSet(fastRunAlwaysOnToggle, data.FastRunAlwaysOn)
    safeSet(fastRunToggle, data.FastRun)
    safeSet(instantAttackToggle, data.InstantAttack)
    safeSet(noKnockbackToggle, data.NoKnockback)
    safeSet(stopStunAnimsToggle, data.StopStunAnims)
    safeSet(noKnockbackMeleeToggle, data.NoKnockbackMelee)
    safeSet(soundSkillNoSlowToggle, data.SoundSkillNoSlow)
    safeSet(soundLoudActAutoAimToggle, data.SoundLoudActAutoAim)
    safeSet(soundSkillRealRangeToggle, data.SoundSkillRealRange)
    if loudActVFXScaleSlider then safeSet(loudActVFXScaleSlider, data.LoudActVFXScale or 1) end
    if musicalScoreVFXScaleSlider then safeSet(musicalScoreVFXScaleSlider, data.MusicalScoreVFXScale or 1) end
    if performanceVFXScaleSlider then safeSet(performanceVFXScaleSlider, data.PerformanceVFXScale or 1) end
    if resoundingVFXScaleSlider then safeSet(resoundingVFXScaleSlider, data.ResoundingVFXScale or 1) end
    safeSet(fastFlyingSickleToggle, data.FastFlyingSickle)
    safeSet(multiCastMovesToggle, data.MultiCastMoves)
    safeSet(autoQEWinToggle, data.AutoQEWin)
    if movesetDropdown then safeSet(movesetDropdown, data.Moveset or "Default") end
    if data.CustomColors then
        customColors.Main = data.CustomColors.Main
        customColors.Accent = data.CustomColors.Accent
        customColors.Background = data.CustomColors.Background
        customColors.Font = data.CustomColors.Font
        Library.Scheme.MainColor = data.CustomColors.Main
        Library.Scheme.AccentColor = data.CustomColors.Accent
        Library.Scheme.BackgroundColor = data.CustomColors.Background
        Library.Scheme.FontColor = data.CustomColors.Font
        Library:UpdateColorsUsingRegistry()
    end
    if data.CustomColorToggles and ThemeBox.Flags then
        if ThemeBox.Flags.CustomMainColorToggle then ThemeBox.Flags.CustomMainColorToggle:Set(data.CustomColorToggles.Main) end
        if ThemeBox.Flags.CustomAccentColorToggle then ThemeBox.Flags.CustomAccentColorToggle:Set(data.CustomColorToggles.Accent) end
        if ThemeBox.Flags.CustomBackgroundColorToggle then ThemeBox.Flags.CustomBackgroundColorToggle:Set(data.CustomColorToggles.Background) end
        if ThemeBox.Flags.CustomFontColorToggle then ThemeBox.Flags.CustomFontColorToggle:Set(data.CustomColorToggles.Font) end
    end
    if showDisplayNickToggle then safeSet(showDisplayNickToggle, data.ShowDisplayNick or false) end
    if showRealNickToggle then safeSet(showRealNickToggle, data.ShowRealNick or true) end
    -- === Auto Block Settings ===
    if data.AutoBlockReleaseTime then
        AUTO_BLOCK_RELEASE_TIME = data.AutoBlockReleaseTime
        if AutoBlockSettingsBox and AutoBlockSettingsBox.Flags and AutoBlockSettingsBox.Flags.AutoBlockReleaseTimeSlider then
            safeSet(AutoBlockSettingsBox.Flags.AutoBlockReleaseTimeSlider, data.AutoBlockReleaseTime)
        end
    end
    if data.AutoBlockIgnoreTime then
        AUTO_BLOCK_IGNORE_TIME = data.AutoBlockIgnoreTime
        if AutoBlockSettingsBox and AutoBlockSettingsBox.Flags and AutoBlockSettingsBox.Flags.AutoBlockIgnoreTimeSlider then
            safeSet(AutoBlockSettingsBox.Flags.AutoBlockIgnoreTimeSlider, data.AutoBlockIgnoreTime)
        end
    end
    if data.AutoBlockAnimFlags then
        _G.AutoBlockAnimFlags = _G.AutoBlockAnimFlags or {}
        for k, v in pairs(data.AutoBlockAnimFlags) do
            _G.AutoBlockAnimFlags[k] = v
            if AutoBlockAnimsBox and AutoBlockAnimsBox.Flags and AutoBlockAnimsBox.Flags["AutoBlockAnim_"..k] then
                safeSet(AutoBlockAnimsBox.Flags["AutoBlockAnim_"..k], v)
            end
        end
    end
    print("[Config] Loaded config value for AttackSpeed:", data.AttackSpeed)
    print("[Config] Loaded config value for PunchStunSpeed:", data.PunchStunSpeed)

    -- После загрузки конфига повторно применяем все патчи и состояния
    if type(reapplyAllPatches) == "function" then
        reapplyAllPatches()
    end

    Library:Notify("Config loaded: "..name)
end

ConfigBox:AddInput("ConfigName", {
    Text = "Config Name",
    Default = "Default",
    Placeholder = "Enter config name...",
    Callback = function(val) currentConfig = val end
})
configDropdown = ConfigBox:AddDropdown("ConfigList", {
    Text = "Saved Configs",
    Values = getConfigs(),
    Default = 1,
    Callback = function(val) currentConfig = val end
})
ConfigBox:AddButton({
    Text = "Save Config",
    Func = function() saveConfig(currentConfig) end
})
ConfigBox:AddButton({
    Text = "Load Config",
    Func = function() loadConfig(currentConfig) end
})
ConfigBox:AddButton({
    Text = "Delete Config",
    Func = function()
        local path = configFolder.."/"..currentConfig..configExt
        if isfile(path) then delfile(path) if configDropdown and configDropdown.SetValues then configDropdown:SetValues(getConfigs()) end Library:Notify({Title = "Config", Content = "Удалено: "..currentConfig, Duration = 2}) end
    end
})
ConfigBox:AddButton({
    Text = "Refresh list",
    Func = function()
        if configDropdown and configDropdown.SetValues then
            configDropdown:SetValues(getConfigs())
            Library:Notify({Title = "Config", Content = "Список конфигов обновлён", Duration = 2})
        end
    end
})

-- Автоматическое восстановление ESP для всех игроков (раз в 0.1 сек)
spawn(function()
    while true do
        if NametagsEnabled then
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    local head = player.Character:FindFirstChild("Head")
                    if head then
                        if not head:FindFirstChild("Nametag") then
                            CreateNametag(player)
                        end
                    end
                    local hasHighlight = false
                    for _, v in ipairs(player.Character:GetChildren()) do
                        if v:IsA("Highlight") then
                            hasHighlight = true
                            break
                        end
                    end
                    if not hasHighlight then
                        ApplyHighlight(player)
                    end
                end
            end
        end
        task.wait(0.1)
    end
end)

showDisplayNickToggle = ESPBox:AddToggle("ShowDisplayNickToggle", {
    Text = "Show Display Nick",
    Default = true,
    Tooltip = "Show player's display name (custom nickname)",
    Callback = function(state)
        ShowDisplayNick = state
        if state then ShowRealNick = false end
        UpdateAllNametags()
    end
})

showRealNickToggle = ESPBox:AddToggle("ShowRealNickToggle", {
    Text = "Show Real Nick",
    Default = false,
    Tooltip = "Show player's real username (registration name)",
    Callback = function(state)
        ShowRealNick = state
        if state then ShowDisplayNick = false end
        UpdateAllNametags()
    end
})

local autoBlockEnabled = false
local autoBlockRadius = 15
local autoBlockConn = nil

local ignoreAnimNames = {
    Running = true, Walking = true, FallDefault = true, FallKatana = true, FlungAir = true, Jump = true, JumpFar = true,
    Idle = true, IdleKatana = true, Blocking = true, DashAnims = true, BlockBreak = true
}
local mustBlockNames = { ["M1-1"] = true, ["M1-2"] = true, ["M1-3"] = true, ["M1-4"] = true, ["M2"] = true }

function isDangerousAnimation(animName)
    local lower = animName:lower()
    for ignore, _ in pairs(ignoreAnimNames) do
        if lower:find(ignore:lower()) then return false end
    end
    for must, _ in pairs(mustBlockNames) do
        if lower == must:lower() then return true end
    end
    return true
end

local Remotes = ReplicatedStorage:FindFirstChild("Remotes")
local BlockRemote = Remotes and Remotes:FindFirstChild("Block")

local AUTO_BLOCK_RELEASE_TIME = 0.26 -- Время отпускания блока после атаки (сек)
local AUTO_BLOCK_IGNORE_TIME = 0.23   -- Время, в течение которого новые атаки игнорируются (сек)

local lastAttackTime = 0
local ignoreAttackUntil = 0

-- Обработчик нажатий для авто-блока
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1
        or input.KeyCode == Enum.KeyCode.One
        or input.KeyCode == Enum.KeyCode.Two
        or input.KeyCode == Enum.KeyCode.Three
        or input.KeyCode == Enum.KeyCode.Four
        or input.KeyCode == Enum.KeyCode.R then
        local now = tick()
        if now > ignoreAttackUntil then
            lastAttackTime = now
            ignoreAttackUntil = now + AUTO_BLOCK_IGNORE_TIME
        end
    end
end)

local dangerousAnims = {
    -- Akaza
    Parry = true, Destruct = true, Disorder = true,
    -- Gyutaro
    RampantArc = true, SickleThrow = true,
    -- Rengoku
    FlameBarrage = true, FlameBarrageFinisher = true, RisingSun = true,
    -- Tanjiro (SunDance)
    FlowingDance = true, FlowingDanceNew = true, ShiningSun = true, WaterSurfaceSlash = true, WaterWheel = true,
    -- Tengen (MusicalScoreEnd)
    LoudAct = true, MusicalScore = true, Performance = true, Resounding = true,
    -- Zenitsu
    EightFoldLand = true, EightFoldWindUp = true, FallAsleep = true, SixFoldBlocked = true, SixFoldEnd = true,
    SixFoldRush = true, SixFoldWindUp = true, ThunderClapEnd = true, ThunderClapStartup = true
}

local lastAttacking = 0
autoBlockToggle = MainLeft:AddToggle("AutoBlockToggle", {
    Text = "Auto Block [REQUIRES NO SLOW]",
    Default = false,
    Tooltip = "Automatically blocks if dangerous animation is near you (radius 15)",
    Callback = function(state)
        autoBlockEnabled = state
        if autoBlockConn then autoBlockConn:Disconnect() autoBlockConn = nil end
        local CharacterDataModule = require(ReplicatedStorage.Knit.Modules.Data.CharacterData)
        local myData = CharacterDataModule.GetData()
        if state then
            autoBlockConn = task.spawn(function()
                while autoBlockEnabled do
                    local now = tick()
                    local danger = false
                    local myChar = LocalPlayer.Character
                    if myChar and myChar:FindFirstChild("HumanoidRootPart") then
                        local myPos = myChar.HumanoidRootPart.Position
                        for _, player in ipairs(Players:GetPlayers()) do
                            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                                local dist = (player.Character.HumanoidRootPart.Position - myPos).Magnitude
                                if dist <= autoBlockRadius then
                                    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                                    if humanoid and humanoid.Animator then
                                        for _, track in ipairs(humanoid.Animator:GetPlayingAnimationTracks()) do
                                            local animName = track.Name
                                            if animName == "M1-1" or animName == "M1-2" or animName == "M1-3" or animName == "M1-4" or animName == "M2" or dangerousAnims[animName] then
                                                danger = true
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                            if danger then break end
                        end
                    end
                    local shouldBlock
                    if danger then
                        shouldBlock = true
                        lastAttackTime = 0 -- сбрасываем отпускание блока, если опасность
                        ignoreAttackUntil = 0
                    else
                        if myData and myData.Attacking and myData.Attacking > 0 and lastAttacking == 0 then
                            -- Только что началась атака!
                            lastAttackTime = now
                            ignoreAttackUntil = now + AUTO_BLOCK_IGNORE_TIME
                        end
                        lastAttacking = myData and myData.Attacking or 0
                        if now < lastAttackTime + AUTO_BLOCK_RELEASE_TIME then
                            shouldBlock = false
                        elseif now < ignoreAttackUntil then
                            shouldBlock = true
                        else
                            shouldBlock = true
                        end
                    end
                    if myData then
                        myData.Blocking = shouldBlock
                    end
                    if BlockRemote then
                        BlockRemote:FireServer(shouldBlock)
                    end
                    task.wait(0.05)
                end
            end)
        else
            if myData then
                myData.Blocking = false
            end
            if BlockRemote then
                BlockRemote:FireServer(false)
            end
        end
    end
})

-- === Auto Block Settings Tab ===
local AutoBlockTab = Window:AddTab("Auto Block Settings", "shield")
local AutoBlockSettingsBox = AutoBlockTab:AddLeftGroupbox("Timing Settings")
local AutoBlockAnimsBox = AutoBlockTab:AddRightGroupbox("Dangerous Animations")

-- Тайминги (слайдеры)
AUTO_BLOCK_RELEASE_TIME = AUTO_BLOCK_RELEASE_TIME or 0.3
AUTO_BLOCK_IGNORE_TIME = AUTO_BLOCK_IGNORE_TIME or 0.25

AutoBlockSettingsBox:AddSlider("AutoBlockReleaseTimeSlider", {
    Text = "Release Time (sec)",
    Min = 0.1,
    Max = 1.0,
    Default = AUTO_BLOCK_RELEASE_TIME,
    Rounding = 2,
    Tooltip = "How long to release block after attack",
    Callback = function(val) AUTO_BLOCK_RELEASE_TIME = val end
})
AutoBlockSettingsBox:AddSlider("AutoBlockIgnoreTimeSlider", {
    Text = "Ignore Time (sec)",
    Min = 0.1,
    Max = 1.0,
    Default = AUTO_BLOCK_IGNORE_TIME,
    Rounding = 2,
    Tooltip = "How long to ignore new attacks after block release",
    Callback = function(val) AUTO_BLOCK_IGNORE_TIME = val end
})

-- Список всех опасных анимаций
local allDangerousAnims = {
    "M1-1", "M1-2", "M1-3", "M1-4", "M2",
    "Parry", "Destruct", "Disorder",
    "RampantArc", "SickleThrow",
    "FlameBarrage", "FlameBarrageFinisher", "RisingSun",
    "FlowingDance", "FlowingDanceNew", "ShiningSun", "WaterSurfaceSlash", "WaterWheel",
    "LoudAct", "MusicalScore", "Performance", "Resounding",
    "EightFoldLand", "EightFoldWindUp", "FallAsleep", "SixFoldBlocked", "SixFoldEnd",
    "SixFoldRush", "SixFoldWindUp", "ThunderClapEnd", "ThunderClapStartup"
}

-- Состояния чекбоксов для анимаций
_G.AutoBlockAnimFlags = _G.AutoBlockAnimFlags or {}
for _, anim in ipairs(allDangerousAnims) do
    if _G.AutoBlockAnimFlags[anim] == nil then _G.AutoBlockAnimFlags[anim] = true end
    AutoBlockAnimsBox:AddToggle("AutoBlockAnim_"..anim, {
        Text = anim,
        Default = _G.AutoBlockAnimFlags[anim],
        Callback = function(state) _G.AutoBlockAnimFlags[anim] = state end
    })
end

local dangerousAnims = setmetatable({}, {
    __index = function(_, k)
        return _G.AutoBlockAnimFlags and _G.AutoBlockAnimFlags[k] or false
    end
})

-- === Infinite Posture (новая логика: анти-пробитие блока) ===
if infinitePostureConn then infinitePostureConn:Disconnect() infinitePostureConn = nil end
infinitePostureConn = game:GetService("RunService").RenderStepped:Connect(function()
    local char = LocalPlayer.Character
    if not char then return end
    local data = require(game:GetService("ReplicatedStorage").Knit.Modules.Data.CharacterData).GetData(char)
    if data then
        -- 1. Мгновенно восстанавливаем Posture, если оно упало
        if data.Posture and data.Posture < 100 then
            data.Posture = 100
            char:SetAttribute("Posture", 100)
        end
        -- 2. Снимаем статус BlockBreak/BlockStun, если он появился
        if (char:GetAttribute("BlockBreak") and char:GetAttribute("BlockBreak") > 0) or (char:GetAttribute("Stun") and char:GetAttribute("Stun") > 0) then
            char:SetAttribute("BlockBreak", 0)
            char:SetAttribute("Stun", 0)
        end
        -- 3. Останавливаем анимации BlockBreak/BlockFlinch
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then
            for _, track in ipairs(hum.Animator:GetPlayingAnimationTracks()) do
                if track.Name:find("BlockBreak") or track.Name:find("BlockFlinch") then
                    track:Stop(0)
                end
            end
        end
    end
end)
